/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxTreeListItem_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeListItem_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTreeListItem_php* object = static_cast<wxTreeListItem_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTreeListItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto bool wxTreeListItem::IsOk()
   Return true if the item is valid. */
PHP_METHOD(php_wxTreeListItem, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListItem::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListItem::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListItem){
				references = &((wxTreeListItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListItem::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListItem_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListItem::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListItem::wxTreeListItem()
   Only the default constructor is publicly accessible. */
PHP_METHOD(php_wxTreeListItem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListItem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeListItem_php();

				((wxTreeListItem_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeListItem);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxTreeListItem_php*) _this)->phpObj = getThis();
		
		((wxTreeListItem_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeListItem_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTreeListItem::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxTreeListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeListCtrl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTreeListCtrl_php* object = static_cast<wxTreeListCtrl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting object by calling destroy\n");
			#endif
			
			object->Destroy();
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTreeListCtrl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxTreeListCtrl::wxTreeListCtrl(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Full constructing, creating the object and its window. */
PHP_METHOD(php_wxTreeListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0, "wxTreeListCtrl::wxTreeListCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0, "wxTreeListCtrl::wxTreeListCtrl at call with 3 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0, "wxTreeListCtrl::wxTreeListCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0, "wxTreeListCtrl::wxTreeListCtrl at call with 4 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0, "wxTreeListCtrl::wxTreeListCtrl at call with 4 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0, "wxTreeListCtrl::wxTreeListCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0, "wxTreeListCtrl::wxTreeListCtrl at call with 5 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0, "wxTreeListCtrl::wxTreeListCtrl at call with 5 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0, "wxTreeListCtrl::wxTreeListCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxTreeListCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8));

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				((wxTreeListCtrl_php*) _this)->references.AddReference(parent0, "wxTreeListCtrl::wxTreeListCtrl at call with 6 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(pos0, "wxTreeListCtrl::wxTreeListCtrl at call with 6 argument(s)");
				((wxTreeListCtrl_php*) _this)->references.AddReference(size0, "wxTreeListCtrl::wxTreeListCtrl at call with 6 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeListCtrl_php();

				((wxTreeListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxTreeListCtrl_php*) _this)->phpObj = getThis();
		
		((wxTreeListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTreeListCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto int wxTreeListCtrl::WidthFor(string text)
   Get the width appropriate for showing the given text. */
PHP_METHOD(php_wxTreeListCtrl, WidthFor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::WidthFor\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::WidthFor\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::WidthFor(wxString(text0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->WidthFor(wxString(text0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::WidthFor\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::UpdateItemParentStateRecursively(wxTreeListItem item)
   Update the state of the parent item to reflect the checked state of its children. */
PHP_METHOD(php_wxTreeListCtrl, UpdateItemParentStateRecursively)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UpdateItemParentStateRecursively\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UpdateItemParentStateRecursively\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UpdateItemParentStateRecursively(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UpdateItemParentStateRecursively(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::UpdateItemParentStateRecursively\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::UnselectAll()
   Deselect all the control items. */
PHP_METHOD(php_wxTreeListCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UnselectAll()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::UnselectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::Unselect(wxTreeListItem item)
   Deselect the given item. */
PHP_METHOD(php_wxTreeListCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Unselect(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Unselect(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::Unselect\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::UncheckItem(wxTreeListItem item)
   Uncheck the given item. */
PHP_METHOD(php_wxTreeListCtrl, UncheckItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::UncheckItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::UncheckItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::UncheckItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->UncheckItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::UncheckItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetSortColumn(int col, bool ascendingOrder)
   Sorting. */
PHP_METHOD(php_wxTreeListCtrl, SetSortColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetSortColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetSortColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool ascendingOrder0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&col0, &ascendingOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &ascendingOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetSortColumn((unsigned) col0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetSortColumn((unsigned) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetSortColumn((unsigned) col0, ascendingOrder0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetSortColumn((unsigned) col0, ascendingOrder0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetSortColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetItemText(wxTreeListItem item, string text)
   Set the text of the first column of the given item. */
PHP_METHOD(php_wxTreeListCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* item1 = 0;
	void* object_pointer1_0 = 0;
	long col1;
	char* text1;
	long text_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxTreeListItem_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ols' (&item1, php_wxTreeListItem_entry, &col1, &text1, &text_len1)\n");
		#endif
		char parse_parameters_string[] = "Ols";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item1, php_wxTreeListItem_entry, &col1, &text1, &text_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemText(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemText(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemText(*(wxTreeListItem*) object_pointer1_0, (unsigned) col1, wxString(text1, wxConvUTF8))\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemText(*(wxTreeListItem*) object_pointer1_0, (unsigned) col1, wxString(text1, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetItemText\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetItemImage(wxTreeListItem item, int closed, int opened)
   Set the images for the given item. */
PHP_METHOD(php_wxTreeListCtrl, SetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long closed0;
	long opened0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|l' (&item0, php_wxTreeListItem_entry, &closed0, &opened0)\n");
		#endif
		char parse_parameters_string[] = "Ol|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &closed0, &opened0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0, (int) opened0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemImage(*(wxTreeListItem*) object_pointer0_0, (int) closed0, (int) opened0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetItemImage\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetItemData(wxTreeListItem item, wxClientData &data)
   Set the data associated with the given item. */
PHP_METHOD(php_wxTreeListCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxTreeListItem_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetItemData(*(wxTreeListItem*) object_pointer0_0, (wxClientData*) object_pointer0_1)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetItemData(*(wxTreeListItem*) object_pointer0_0, (wxClientData*) object_pointer0_1);

				references->AddReference(data0, "wxTreeListCtrl::SetItemData at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetItemData\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetImageList(wxImageList &imageList)
   Sets the image list. */
PHP_METHOD(php_wxTreeListCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeListCtrl::SetImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SetColumnWidth(int col, int width)
   Change the width of the given column. */
PHP_METHOD(php_wxTreeListCtrl, SetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SetColumnWidth((unsigned) col0, (int) width0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SetColumnWidth((unsigned) col0, (int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SetColumnWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::SelectAll()
   Select all the control items. */
PHP_METHOD(php_wxTreeListCtrl, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::SelectAll()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->SelectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::Select(wxTreeListItem item)
   Select the given item. */
PHP_METHOD(php_wxTreeListCtrl, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Select(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Select(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::Select\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::PrependItem(wxTreeListItem parent, string text, int imageClosed, int imageOpened, wxClientData &data)
   Same as InsertItem() with wxTLI_FIRST. */
PHP_METHOD(php_wxTreeListCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->PrependItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0, "wxTreeListCtrl::PrependItem at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::PrependItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::IsSelected(wxTreeListItem item)
   Return true if the item is selected. */
PHP_METHOD(php_wxTreeListCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::IsSelected(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->IsSelected(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::IsExpanded(wxTreeListItem item)
   Return whether the given item is expanded. */
PHP_METHOD(php_wxTreeListCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::IsExpanded(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->IsExpanded(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::IsExpanded\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::InsertItem(wxTreeListItem parent, wxTreeListItem previous, string text, int imageClosed, int imageOpened, wxClientData &data)
   Insert a new item into the tree. */
PHP_METHOD(php_wxTreeListCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxTreeListItem_entry, &previous0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &previous0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return6;
				value_to_return6 = ((wxTreeListCtrl_php*)_this)->InsertItem(*(wxTreeListItem*) object_pointer0_0, *(wxTreeListItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0, "wxTreeListCtrl::InsertItem at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::InsertItem\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxTreeListCtrl::GetView()
   View window. */
PHP_METHOD(php_wxTreeListCtrl, GetView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetView\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetView\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetView() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxTreeListCtrl_php*)_this)->GetView();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeListCtrl::GetView at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetView\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::GetSortColumn(int &col, bool &ascendingOrder)
   Return the column currently used for sorting, if any. */
PHP_METHOD(php_wxTreeListCtrl, GetSortColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetSortColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetSortColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* col0;
	zval* col0_ref;
	bool* ascendingOrder0;
	zval* ascendingOrder0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (col0, ascendingOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, col0, ascendingOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &col0_ref, &ascendingOrder0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::GetSortColumn((unsigned*) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->GetSortColumn((unsigned*) col0));

				size_t elements_returned0_0 = sizeof(col0)/sizeof(*col0);
				array_init(col0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(col0_ref, col0[i]);
				}

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::GetSortColumn((unsigned*) col0, ascendingOrder0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->GetSortColumn((unsigned*) col0, ascendingOrder0));

				size_t elements_returned0_0 = sizeof(col0)/sizeof(*col0);
				array_init(col0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(col0_ref, col0[i]);
				}
				size_t elements_returned0_1 = sizeof(ascendingOrder0)/sizeof(*ascendingOrder0);
				array_init(ascendingOrder0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(ascendingOrder0_ref, ascendingOrder0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetSortColumn\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetSelection()
   Selection methods. */
PHP_METHOD(php_wxTreeListCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetSelection() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetRootItem()
   Methods for the tree navigation. */
PHP_METHOD(php_wxTreeListCtrl, GetRootItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetRootItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetRootItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetRootItem() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetRootItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetRootItem\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetNextSibling(wxTreeListItem item)
   Return the next sibling of the given item. */
PHP_METHOD(php_wxTreeListCtrl, GetNextSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetNextSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetNextSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetNextSibling(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetNextSibling(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetNextSibling\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetNextItem(wxTreeListItem item)
   Get item after the given one in the depth-first tree-traversal order. */
PHP_METHOD(php_wxTreeListCtrl, GetNextItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetNextItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetNextItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetNextItem(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetNextItem(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetNextItem\n");
	}
}
/* }}} */

/* {{{ proto string wxTreeListCtrl::GetItemText(wxTreeListItem item, int col)
   Items attributes. */
PHP_METHOD(php_wxTreeListCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeListCtrl::GetItemText(*(wxTreeListItem*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetItemText(*(wxTreeListItem*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeListCtrl::GetItemText(*(wxTreeListItem*) object_pointer0_0, (unsigned) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->GetItemText(*(wxTreeListItem*) object_pointer0_0, (unsigned) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetItemText\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetItemParent(wxTreeListItem item)
   Return the parent of the given item. */
PHP_METHOD(php_wxTreeListCtrl, GetItemParent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetItemParent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetItemParent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetItemParent(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetItemParent(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetItemParent\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetFirstItem()
   Return the first item in the tree. */
PHP_METHOD(php_wxTreeListCtrl, GetFirstItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetFirstItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetFirstItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetFirstItem() to return new object\n\n");
				#endif
				wxTreeListItem value_to_return0;
				value_to_return0 = ((wxTreeListCtrl_php*)_this)->GetFirstItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetFirstItem\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::GetFirstChild(wxTreeListItem item)
   Return the first child of the given item. */
PHP_METHOD(php_wxTreeListCtrl, GetFirstChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetFirstChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetFirstChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetFirstChild(*(wxTreeListItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return1;
				value_to_return1 = ((wxTreeListCtrl_php*)_this)->GetFirstChild(*(wxTreeListItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetFirstChild\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewCtrl wxTreeListCtrl::GetDataView()
   Return the view part of this control as wxDataViewCtrl. */
PHP_METHOD(php_wxTreeListCtrl, GetDataView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetDataView\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetDataView\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::GetDataView() to return object pointer\n\n");
				#endif
				wxDataViewCtrl_php* value_to_return0;
				value_to_return0 = (wxDataViewCtrl_php*) ((wxTreeListCtrl_php*)_this)->GetDataView();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeListCtrl::GetDataView at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetDataView\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeListCtrl::GetColumnWidth(int col)
   Get the current width of the given column in pixels. */
PHP_METHOD(php_wxTreeListCtrl, GetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetColumnWidth((unsigned) col0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetColumnWidth((unsigned) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetColumnWidth\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeListCtrl::GetColumnCount()
   Return the total number of columns. */
PHP_METHOD(php_wxTreeListCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto wxCheckBoxState wxTreeListCtrl::GetCheckedState(wxTreeListItem item)
   Return the checked state of the item. */
PHP_METHOD(php_wxTreeListCtrl, GetCheckedState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::GetCheckedState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::GetCheckedState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::GetCheckedState(*(wxTreeListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->GetCheckedState(*(wxTreeListItem*) object_pointer0_0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::GetCheckedState\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::Expand(wxTreeListItem item)
   Expanding and collapsing tree branches. */
PHP_METHOD(php_wxTreeListCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Expand(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Expand(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::Expand\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::DeleteItem(wxTreeListItem item)
   Delete the specified item. */
PHP_METHOD(php_wxTreeListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::DeleteItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->DeleteItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::DeleteItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::DeleteColumn(int col)
   Delete the column with the given index. */
PHP_METHOD(php_wxTreeListCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::DeleteColumn((unsigned) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->DeleteColumn((unsigned) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::DeleteColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::DeleteAllItems()
   Delete all tree items. */
PHP_METHOD(php_wxTreeListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::DeleteAllItems()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::DeleteAllItems\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Create the control window. */
PHP_METHOD(php_wxTreeListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxTreeListCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxTreeListCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxTreeListCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxTreeListCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxTreeListCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxTreeListCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxTreeListCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxTreeListCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxTreeListCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxTreeListCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxTreeListCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxTreeListCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::Collapse(wxTreeListItem item)
   Collapse the given tree branch. */
PHP_METHOD(php_wxTreeListCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::Collapse(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->Collapse(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::Collapse\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::ClearColumns()
   Delete all columns. */
PHP_METHOD(php_wxTreeListCtrl, ClearColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::ClearColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::ClearColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::ClearColumns()\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->ClearColumns();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::ClearColumns\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::CheckItemRecursively(wxTreeListItem item, wxCheckBoxState state)
   Change the checked state of the given item and all its children. */
PHP_METHOD(php_wxTreeListCtrl, CheckItemRecursively)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::CheckItemRecursively\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::CheckItemRecursively\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItemRecursively(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::CheckItemRecursively\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::CheckItem(wxTreeListItem item, wxCheckBoxState state)
   Checkbox handling. */
PHP_METHOD(php_wxTreeListCtrl, CheckItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::CheckItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::CheckItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItem(*(wxTreeListItem*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItem(*(wxTreeListItem*) object_pointer0_0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::CheckItem(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->CheckItem(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::CheckItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeListCtrl::AssignImageList(wxImageList &imageList)
   Sets the image list and gives its ownership to the control. */
PHP_METHOD(php_wxTreeListCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeListCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeListCtrl::AssignImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::AssignImageList\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeListCtrl::AreAllChildrenInState(wxTreeListItem item, wxCheckBoxState state)
   Return true if all children of the given item are in the specified state. */
PHP_METHOD(php_wxTreeListCtrl, AreAllChildrenInState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AreAllChildrenInState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AreAllChildrenInState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&item0, php_wxTreeListItem_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeListItem_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeListCtrl::AreAllChildrenInState(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeListCtrl_php*)_this)->AreAllChildrenInState(*(wxTreeListItem*) object_pointer0_0, (wxCheckBoxState) state0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::AreAllChildrenInState\n");
	}
}
/* }}} */

/* {{{ proto wxTreeListItem wxTreeListCtrl::AppendItem(wxTreeListItem parent, string text, int imageClosed, int imageOpened, wxClientData &data)
   Adding and removing items. */
PHP_METHOD(php_wxTreeListCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long imageClosed0;
	long imageOpened0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeListItem_entry, &text0, &text_len0, &imageClosed0, &imageOpened0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return2;
				value_to_return2 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return3;
				value_to_return3 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return4;
				value_to_return4 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeListCtrl::AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeListItem value_to_return5;
				value_to_return5 = ((wxTreeListCtrl_php*)_this)->AppendItem(*(wxTreeListItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) imageClosed0, (int) imageOpened0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeListItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeListItem));
				object_init_ex(return_value, php_wxTreeListItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeListItem));

				references->AddReference(data0, "wxTreeListCtrl::AppendItem at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::AppendItem\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeListCtrl::AppendColumn(string title, int width, wxAlignment align, int flags)
   Column methods. */
PHP_METHOD(php_wxTreeListCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeListCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeListCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeListCtrl){
				references = &((wxTreeListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&title0, &title_len0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeListCtrl::AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeListCtrl_php*)_this)->AppendColumn(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeListCtrl::AppendColumn\n");
	}
}
/* }}} */

void php_wxAnimationCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxAnimationCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxAnimationCtrl::Create(wxWindow &parent, int id, wxAnimation anim, wxPoint pos, wxSize size, int style, string name)
   Creates the control with the given anim animation. */
PHP_METHOD(php_wxAnimationCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* anim0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOOls' (&parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 3 argument(s)");
				references->AddReference(anim0, "wxAnimationCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 4 argument(s)");
				references->AddReference(anim0, "wxAnimationCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxAnimationCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 5 argument(s)");
				references->AddReference(anim0, "wxAnimationCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxAnimationCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxAnimationCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 6 argument(s)");
				references->AddReference(anim0, "wxAnimationCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxAnimationCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxAnimationCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxAnimationCtrl::Create at call with 7 argument(s)");
				references->AddReference(anim0, "wxAnimationCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxAnimationCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxAnimationCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto wxAnimation wxAnimationCtrl::GetAnimation()
   Returns the animation associated with this control. */
PHP_METHOD(php_wxAnimationCtrl, GetAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::GetAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::GetAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::GetAnimation() to return new object\n\n");
				#endif
				wxAnimation value_to_return0;
				value_to_return0 = ((wxAnimationCtrl_php*)_this)->GetAnimation();
				void* ptr = safe_emalloc(1, sizeof(wxAnimation_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxAnimation));
				object_init_ex(return_value, php_wxAnimation_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxAnimation));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::GetAnimation\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnimationCtrl::GetInactiveBitmap()
   Returns the inactive bitmap shown in this control when the; see SetInactiveBitmap() for more info. */
PHP_METHOD(php_wxAnimationCtrl, GetInactiveBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::GetInactiveBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::GetInactiveBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::GetInactiveBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnimationCtrl_php*)_this)->GetInactiveBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::GetInactiveBitmap\n");
	}
}
/* }}} */

/* {{{ proto bool wxAnimationCtrl::IsPlaying()
   Returns true if the animation is being played. */
PHP_METHOD(php_wxAnimationCtrl, IsPlaying)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::IsPlaying\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::IsPlaying\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::IsPlaying())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->IsPlaying());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::IsPlaying\n");
	}
}
/* }}} */

/* {{{ proto bool wxAnimationCtrl::LoadFile(string file, wxAnimationType animType)
   Loads the animation from the given file and calls SetAnimation(). */
PHP_METHOD(php_wxAnimationCtrl, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::LoadFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* file0;
	long file_len0;
	long animType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&file0, &file_len0, &animType0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, &file_len0, &animType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::LoadFile(wxString(file0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->LoadFile(wxString(file0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::LoadFile(wxString(file0, wxConvUTF8), (wxAnimationType) animType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->LoadFile(wxString(file0, wxConvUTF8), (wxAnimationType) animType0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxAnimationCtrl::Play()
   Starts playing the animation. */
PHP_METHOD(php_wxAnimationCtrl, Play)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Play\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Play\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Play())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Play());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::Play\n");
	}
}
/* }}} */

/* {{{ proto  wxAnimationCtrl::SetAnimation(wxAnimation anim)
   Sets the animation to play in this control. */
PHP_METHOD(php_wxAnimationCtrl, SetAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::SetAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::SetAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* anim0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&anim0, php_wxAnimation_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &anim0, php_wxAnimation_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::SetAnimation(*(wxAnimation*) object_pointer0_0)\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->SetAnimation(*(wxAnimation*) object_pointer0_0);

				references->AddReference(anim0, "wxAnimationCtrl::SetAnimation at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::SetAnimation\n");
	}
}
/* }}} */

/* {{{ proto  wxAnimationCtrl::SetInactiveBitmap(wxBitmap bmp)
   Sets the bitmap to show on the control when it's not playing an animation. */
PHP_METHOD(php_wxAnimationCtrl, SetInactiveBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::SetInactiveBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::SetInactiveBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmp0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::SetInactiveBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->SetInactiveBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0, "wxAnimationCtrl::SetInactiveBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::SetInactiveBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAnimationCtrl::Stop()
   Stops playing the animation. */
PHP_METHOD(php_wxAnimationCtrl, Stop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Stop\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Stop\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimationCtrl::Stop()\n\n");
				#endif
				((wxAnimationCtrl_php*)_this)->Stop();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::Stop\n");
	}
}
/* }}} */

/* {{{ proto  wxAnimationCtrl::wxAnimationCtrl(wxWindow &parent, int id, wxAnimation anim, wxPoint pos, wxSize size, int style, string name)
   Initializes the object and calls Create() with all the parameters. */
PHP_METHOD(php_wxAnimationCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* anim0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOOls' (&parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &anim0, php_wxAnimation_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(anim0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(anim0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 3 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0, "wxAnimationCtrl::wxAnimationCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 4 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0, "wxAnimationCtrl::wxAnimationCtrl at call with 4 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0, "wxAnimationCtrl::wxAnimationCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 5 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0, "wxAnimationCtrl::wxAnimationCtrl at call with 5 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0, "wxAnimationCtrl::wxAnimationCtrl at call with 5 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0, "wxAnimationCtrl::wxAnimationCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 6 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0, "wxAnimationCtrl::wxAnimationCtrl at call with 6 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0, "wxAnimationCtrl::wxAnimationCtrl at call with 6 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0, "wxAnimationCtrl::wxAnimationCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxAnimationCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxAnimation*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8));

				((wxAnimationCtrl_php*) _this)->references.Initialize();
				((wxAnimationCtrl_php*) _this)->references.AddReference(parent0, "wxAnimationCtrl::wxAnimationCtrl at call with 7 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(anim0, "wxAnimationCtrl::wxAnimationCtrl at call with 7 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(pos0, "wxAnimationCtrl::wxAnimationCtrl at call with 7 argument(s)");
				((wxAnimationCtrl_php*) _this)->references.AddReference(size0, "wxAnimationCtrl::wxAnimationCtrl at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAnimationCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxAnimationCtrl_php*) _this)->phpObj = getThis();
		
		((wxAnimationCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAnimationCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAnimationCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxAnimationCtrl::Load(wxInputStream &file, wxAnimationType animType)
   Loads the animation from the given stream and calls SetAnimation(). */
PHP_METHOD(php_wxAnimationCtrl, Load)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimationCtrl::Load\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAnimationCtrl::Load\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAnimationCtrl){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* file0 = 0;
	void* object_pointer0_0 = 0;
	long animType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&file0, php_wxInputStream_entry, &animType0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, php_wxInputStream_entry, &animType0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(file0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(file0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(file0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Load(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Load(*(wxInputStream*) object_pointer0_0));

				references->AddReference(file0, "wxAnimationCtrl::Load at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimationCtrl::Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) animType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAnimationCtrl_php*)_this)->Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) animType0));

				references->AddReference(file0, "wxAnimationCtrl::Load at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimationCtrl::Load\n");
	}
}
/* }}} */

void php_wxBitmapButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxBitmapButton::Create(wxWindow &parent, int id, wxBitmap bitmap, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Button creation function for two-step creation. */
PHP_METHOD(php_wxBitmapButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapButton){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* bitmap0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent0, &id0, &bitmap0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &bitmap0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 3 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 4 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxBitmapButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 5 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxBitmapButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxBitmapButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 6 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxBitmapButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxBitmapButton::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 7 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxBitmapButton::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxBitmapButton::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxBitmapButton::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxBitmapButton::Create at call with 8 argument(s)");
				references->AddReference(bitmap0, "wxBitmapButton::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxBitmapButton::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxBitmapButton::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxBitmapButton::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapButton::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapButton::wxBitmapButton()
   Default ctor. */
PHP_METHOD(php_wxBitmapButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* bitmap1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent1, &id1, &bitmap1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &bitmap1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapButton_php();

				((wxBitmapButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 3 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 4 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 4 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(pos1, "wxBitmapButton::wxBitmapButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 5 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 5 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(pos1, "wxBitmapButton::wxBitmapButton at call with 5 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(size1, "wxBitmapButton::wxBitmapButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 6 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 6 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(pos1, "wxBitmapButton::wxBitmapButton at call with 6 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(size1, "wxBitmapButton::wxBitmapButton at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 7 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 7 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(pos1, "wxBitmapButton::wxBitmapButton at call with 7 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(size1, "wxBitmapButton::wxBitmapButton at call with 7 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(validator1, "wxBitmapButton::wxBitmapButton at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxBitmapButton_php*) _this)->references.Initialize();
				((wxBitmapButton_php*) _this)->references.AddReference(parent1, "wxBitmapButton::wxBitmapButton at call with 8 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(bitmap1, "wxBitmapButton::wxBitmapButton at call with 8 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(pos1, "wxBitmapButton::wxBitmapButton at call with 8 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(size1, "wxBitmapButton::wxBitmapButton at call with 8 argument(s)");
				((wxBitmapButton_php*) _this)->references.AddReference(validator1, "wxBitmapButton::wxBitmapButton at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxBitmapButton_php*) _this)->phpObj = getThis();
		
		((wxBitmapButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmapButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxBitmapComboBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapComboBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto int wxBitmapComboBox::Append(string item, wxBitmap bitmap)
   Adds the item to the end of the combo box. */
PHP_METHOD(php_wxBitmapComboBox, Append)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Append\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Append\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|O' (&item0, &item_len0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "s|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Append(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Append(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0, "wxBitmapComboBox::Append at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::Append\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmapComboBox::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Creates the combobox for two-step construction. */
PHP_METHOD(php_wxBitmapComboBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 7  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOla|lOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOla|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_5;
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5));

				references->AddReference(parent0, "wxBitmapComboBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxBitmapComboBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxBitmapComboBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0));

				references->AddReference(parent0, "wxBitmapComboBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxBitmapComboBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxBitmapComboBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0, "wxBitmapComboBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxBitmapComboBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxBitmapComboBox::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxBitmapComboBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxBitmapComboBox::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxBitmapComboBox::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxBitmapComboBox::Create at call with 9 argument(s)");
				references->AddReference(validator0, "wxBitmapComboBox::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_6 = 1;
		HashTable* arr_hash1_6;
		if(arguments_received > 6)
		{
			arr_hash1_6 = Z_ARRVAL_P(choices1);
			array_count1_6 = zend_hash_num_elements(arr_hash1_6);
		}
		wxString* strings_array1_6 = new wxString[array_count1_6];
		bool strings_continue1_6 = true;

		switch(arguments_received)
		{
			case 7:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6));

				references->AddReference(parent1, "wxBitmapComboBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxBitmapComboBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxBitmapComboBox::Create at call with 7 argument(s)");
				delete[] strings_array1_6;

				return;
				break;
			}
			case 8:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1));

				references->AddReference(parent1, "wxBitmapComboBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxBitmapComboBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxBitmapComboBox::Create at call with 8 argument(s)");
				delete[] strings_array1_6;

				return;
				break;
			}
			case 9:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8));

				references->AddReference(parent1, "wxBitmapComboBox::Create at call with 9 argument(s)");
				references->AddReference(pos1, "wxBitmapComboBox::Create at call with 9 argument(s)");
				references->AddReference(size1, "wxBitmapComboBox::Create at call with 9 argument(s)");
				delete[] strings_array1_6;
				references->AddReference(validator1, "wxBitmapComboBox::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				int array_index1_6 = 0;
				zval** temp_array_value1_6 = 0;
				while(strings_continue1_6)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_6, (void**)&temp_array_value1_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_6);
						strings_array1_6[array_index1_6] = wxString(Z_STRVAL_PP(temp_array_value1_6), wxConvUTF8);
						array_index1_6++;
					}
					else
					{
						strings_continue1_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (int) n1, strings_array1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxBitmapComboBox::Create at call with 10 argument(s)");
				references->AddReference(pos1, "wxBitmapComboBox::Create at call with 10 argument(s)");
				references->AddReference(size1, "wxBitmapComboBox::Create at call with 10 argument(s)");
				delete[] strings_array1_6;
				references->AddReference(validator1, "wxBitmapComboBox::Create at call with 10 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::Create\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxBitmapComboBox::GetBitmapSize()
   Returns the size of the bitmaps used in the combo box. */
PHP_METHOD(php_wxBitmapComboBox, GetBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::GetBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::GetBitmapSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::GetBitmapSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetBitmapSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::GetBitmapSize\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxBitmapComboBox::GetItemBitmap(int n)
   Returns the bitmap of the item with the given index. */
PHP_METHOD(php_wxBitmapComboBox, GetItemBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::GetItemBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::GetItemBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::GetItemBitmap((unsigned int) n0) to return new object\n\n");
				#endif
				wxBitmap value_to_return1;
				value_to_return1 = ((wxBitmapComboBox_php*)_this)->GetItemBitmap((unsigned int) n0);
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::GetItemBitmap\n");
	}
}
/* }}} */

/* {{{ proto int wxBitmapComboBox::Insert(string item, wxBitmap bitmap, int pos)
   Inserts the item into the list before pos. */
PHP_METHOD(php_wxBitmapComboBox, Insert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::Insert\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::Insert\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sOl' (&item0, &item_len0, &bitmap0, php_wxBitmap_entry, &pos0)\n");
		#endif
		char parse_parameters_string[] = "sOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &bitmap0, php_wxBitmap_entry, &pos0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapComboBox::Insert(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1, (unsigned int) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), *(wxBitmap*) object_pointer0_1, (unsigned int) pos0));

				references->AddReference(bitmap0, "wxBitmapComboBox::Insert at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::Insert\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapComboBox::SetItemBitmap(int n, wxBitmap bitmap)
   Sets the bitmap for the given item. */
PHP_METHOD(php_wxBitmapComboBox, SetItemBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::SetItemBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapComboBox::SetItemBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapComboBox){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&n0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapComboBox::SetItemBitmap((unsigned int) n0, *(wxBitmap*) object_pointer0_1)\n\n");
				#endif
				((wxBitmapComboBox_php*)_this)->SetItemBitmap((unsigned int) n0, *(wxBitmap*) object_pointer0_1);

				references->AddReference(bitmap0, "wxBitmapComboBox::SetItemBitmap at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapComboBox::SetItemBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapComboBox::wxBitmapComboBox()
   Default ctor. */
PHP_METHOD(php_wxBitmapComboBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapComboBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 7  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOal|Os' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOal|Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapComboBox_php();

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1)\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1);

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1, "wxBitmapComboBox::wxBitmapComboBox at call with 7 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1, "wxBitmapComboBox::wxBitmapComboBox at call with 7 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1, "wxBitmapComboBox::wxBitmapComboBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7)\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7);

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1, "wxBitmapComboBox::wxBitmapComboBox at call with 8 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1, "wxBitmapComboBox::wxBitmapComboBox at call with 8 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1, "wxBitmapComboBox::wxBitmapComboBox at call with 8 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(validator1, "wxBitmapComboBox::wxBitmapComboBox at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapComboBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8));

				((wxBitmapComboBox_php*) _this)->references.Initialize();
				((wxBitmapComboBox_php*) _this)->references.AddReference(parent1, "wxBitmapComboBox::wxBitmapComboBox at call with 9 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(pos1, "wxBitmapComboBox::wxBitmapComboBox at call with 9 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(size1, "wxBitmapComboBox::wxBitmapComboBox at call with 9 argument(s)");
				((wxBitmapComboBox_php*) _this)->references.AddReference(validator1, "wxBitmapComboBox::wxBitmapComboBox at call with 9 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapComboBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxBitmapComboBox_php*) _this)->phpObj = getThis();
		
		((wxBitmapComboBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapComboBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmapComboBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxButton::wxButton(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Constructor, creating and showing a button. */
PHP_METHOD(php_wxButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 4 argument(s)");
				((wxButton_php*) _this)->references.AddReference(pos0, "wxButton::wxButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 5 argument(s)");
				((wxButton_php*) _this)->references.AddReference(pos0, "wxButton::wxButton at call with 5 argument(s)");
				((wxButton_php*) _this)->references.AddReference(size0, "wxButton::wxButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 6 argument(s)");
				((wxButton_php*) _this)->references.AddReference(pos0, "wxButton::wxButton at call with 6 argument(s)");
				((wxButton_php*) _this)->references.AddReference(size0, "wxButton::wxButton at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 7 argument(s)");
				((wxButton_php*) _this)->references.AddReference(pos0, "wxButton::wxButton at call with 7 argument(s)");
				((wxButton_php*) _this)->references.AddReference(size0, "wxButton::wxButton at call with 7 argument(s)");
				((wxButton_php*) _this)->references.AddReference(validator0, "wxButton::wxButton at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxButton_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxButton_php*) _this)->references.Initialize();
				((wxButton_php*) _this)->references.AddReference(parent0, "wxButton::wxButton at call with 8 argument(s)");
				((wxButton_php*) _this)->references.AddReference(pos0, "wxButton::wxButton at call with 8 argument(s)");
				((wxButton_php*) _this)->references.AddReference(size0, "wxButton::wxButton at call with 8 argument(s)");
				((wxButton_php*) _this)->references.AddReference(validator0, "wxButton::wxButton at call with 8 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxButton_php();

				((wxButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxButton_php*) _this)->phpObj = getThis();
		
		((wxButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxButton::SetLabel(string label)
   Sets the string label for the button. */
PHP_METHOD(php_wxButton, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetLabel(wxString(label0, wxConvUTF8))\n\n");
				#endif
				((wxButton_php*)_this)->SetLabel(wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::SetLabel\n");
	}
}
/* }}} */

/* {{{ proto bool wxButton::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Button creation function for two-step creation. */
PHP_METHOD(php_wxButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxButton::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxButton::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxButton::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxButton::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxButton::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxButton::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxButton::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxButton::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxButton::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxButton::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::Create\n");
	}
}
/* }}} */

/* {{{ proto string wxButton::GetLabel()
   Returns the string label for the button. */
PHP_METHOD(php_wxButton, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxButton::GetLabel().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxButton_php*)_this)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::GetLabel\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxButton::SetDefault()
   This sets the button to be the default item in its top-level window (e.g. */
PHP_METHOD(php_wxButton, SetDefault)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetDefault\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetDefault\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetDefault() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxButton_php*)_this)->SetDefault();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxButton::SetDefault at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::SetDefault\n");
	}
}
/* }}} */

/* {{{ proto  wxButton::SetAuthNeeded(bool needed)
   Sets whether an authentication needed symbol should be displayed on the button. */
PHP_METHOD(php_wxButton, SetAuthNeeded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::SetAuthNeeded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::SetAuthNeeded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool needed0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&needed0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &needed0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetAuthNeeded()\n\n");
				#endif
				((wxButton_php*)_this)->SetAuthNeeded();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxButton::SetAuthNeeded(needed0)\n\n");
				#endif
				((wxButton_php*)_this)->SetAuthNeeded(needed0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::SetAuthNeeded\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxButton::GetDefaultSize()
   Returns the default size for the buttons. */
PHP_METHOD(php_wxButton, GetDefaultSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetDefaultSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetDefaultSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxButton::GetDefaultSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = wxButton::GetDefaultSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, _wxResource, zend_list_insert(ptr, le_wxSize));
				((wxSize_php*)ptr)->phpObj = return_value;
				((wxSize_php*)ptr)->InitProperties();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::GetDefaultSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxButton::GetAuthNeeded()
   Returns true if an authentication needed symbol is displayed on the button. */
PHP_METHOD(php_wxButton, GetAuthNeeded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxButton::GetAuthNeeded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxButton::GetAuthNeeded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxButton){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxButton::GetAuthNeeded())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxButton_php*)_this)->GetAuthNeeded());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxButton::GetAuthNeeded\n");
	}
}
/* }}} */

void php_wxCalendarCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCalendarCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxCalendarCtrl::Create(wxWindow &parent, int id, timestamp date, wxPoint pos, wxSize size, int style, string name)
   Creates the control. */
PHP_METHOD(php_wxCalendarCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long date0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|lOOls' (&parent0, &id0, &date0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &date0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0)));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxCalendarCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxCalendarCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxCalendarCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxCalendarCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxCalendarCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxDateTime(date0), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxCalendarCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxCalendarCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxCalendarCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::EnableHolidayDisplay(bool display)
   This function should be used instead of changing wxCAL_SHOW_HOLIDAYS style bit directly. */
PHP_METHOD(php_wxCalendarCtrl, EnableHolidayDisplay)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::EnableHolidayDisplay\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::EnableHolidayDisplay\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool display0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&display0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &display0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::EnableHolidayDisplay()\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->EnableHolidayDisplay();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::EnableHolidayDisplay(display0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->EnableHolidayDisplay(display0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::EnableHolidayDisplay\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarCtrl::EnableMonthChange(bool enable)
   This function should be used instead of changing wxCAL_NO_MONTH_CHANGE style bit. */
PHP_METHOD(php_wxCalendarCtrl, EnableMonthChange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::EnableMonthChange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::EnableMonthChange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::EnableMonthChange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->EnableMonthChange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::EnableMonthChange(enable0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->EnableMonthChange(enable0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::EnableMonthChange\n");
	}
}
/* }}} */

/* {{{ proto wxCalendarDateAttr wxCalendarCtrl::GetAttr(int day)
   Returns the attribute for the given date (should be in the range 1...31). */
PHP_METHOD(php_wxCalendarCtrl, GetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetAttr((size_t) day0) to return object pointer\n\n");
				#endif
				wxCalendarDateAttr_php* value_to_return1;
				value_to_return1 = (wxCalendarDateAttr_php*) ((wxCalendarCtrl_php*)_this)->GetAttr((size_t) day0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxCalendarDateAttr_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxCalendarDateAttr));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxCalendarCtrl::GetAttr at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetAttr\n");
	}
}
/* }}} */

/* {{{ proto timestamp wxCalendarCtrl::GetDate()
   Gets the currently selected date. */
PHP_METHOD(php_wxCalendarCtrl, GetDate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetDate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetDate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetDate() to return timestamp\n\n");
				#endif
				long value_to_return0;
				value_to_return0 = ((wxCalendarCtrl_php*)_this)->GetDate().GetTicks();
				ZVAL_LONG(return_value, value_to_return0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetDate\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarCtrl::GetDateRange(timestamp &lowerdate, timestamp &upperdate)
   Returns the limits currently being used. */
PHP_METHOD(php_wxCalendarCtrl, GetDateRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetDateRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetDateRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long lowerdate0;
	zval* lowerdate0_ref;
	long upperdate0;
	zval* upperdate0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&lowerdate0, &upperdate0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lowerdate0, &upperdate0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &lowerdate0_ref, &upperdate0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				wxDateTime date_time0_0 = wxDateTime(lowerdate0);
				wxDateTime date_time0_1 = wxDateTime(upperdate0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::GetDateRange(&date_time0_0, &date_time0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->GetDateRange(&date_time0_0, &date_time0_1));

				ZVAL_LONG(lowerdate0_ref, date_time0_0.GetTicks());
				ZVAL_LONG(upperdate0_ref, date_time0_1.GetTicks());

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetDateRange\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHeaderColourBg()
   Gets the background colour of the header part of the calendar window. */
PHP_METHOD(php_wxCalendarCtrl, GetHeaderColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHeaderColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHeaderColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHeaderColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHeaderColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHeaderColourBg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHeaderColourBg\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHeaderColourFg()
   Gets the foreground colour of the header part of the calendar window. */
PHP_METHOD(php_wxCalendarCtrl, GetHeaderColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHeaderColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHeaderColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHeaderColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHeaderColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHeaderColourFg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHeaderColourFg\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHighlightColourBg()
   Gets the background highlight colour. */
PHP_METHOD(php_wxCalendarCtrl, GetHighlightColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHighlightColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHighlightColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHighlightColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHighlightColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHighlightColourBg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHighlightColourBg\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHighlightColourFg()
   Gets the foreground highlight colour. */
PHP_METHOD(php_wxCalendarCtrl, GetHighlightColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHighlightColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHighlightColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHighlightColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHighlightColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHighlightColourFg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHighlightColourFg\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHolidayColourBg()
   Return the background colour currently used for holiday highlighting. */
PHP_METHOD(php_wxCalendarCtrl, GetHolidayColourBg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHolidayColourBg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHolidayColourBg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHolidayColourBg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHolidayColourBg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHolidayColourBg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHolidayColourBg\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarCtrl::GetHolidayColourFg()
   Return the foreground colour currently used for holiday highlighting. */
PHP_METHOD(php_wxCalendarCtrl, GetHolidayColourFg)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::GetHolidayColourFg\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::GetHolidayColourFg\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::GetHolidayColourFg() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarCtrl_php*)_this)->GetHolidayColourFg();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarCtrl::GetHolidayColourFg at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::GetHolidayColourFg\n");
	}
}
/* }}} */

/* {{{ proto wxCalendarHitTestResult wxCalendarCtrl::HitTest(wxPoint pos, timestamp &date, wxDateTime::WeekDay &wd)
   Returns one of wxCalendarHitTestResult constants and fills either date or wd pointer with the corresponding value depending on the hit test code. */
PHP_METHOD(php_wxCalendarCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pos0 = 0;
	void* object_pointer0_0 = 0;
	long date0;
	zval* date0_ref;
	long* wd0;
	zval* wd0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|ll' (&pos0, php_wxPoint_entry, &date0, wd0)\n");
		#endif
		char parse_parameters_string[] = "O|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, php_wxPoint_entry, &date0, wd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &date0_ref, &wd0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0));

				references->AddReference(pos0, "wxCalendarCtrl::HitTest at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				wxDateTime date_time0_1 = wxDateTime(date0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1));

				references->AddReference(pos0, "wxCalendarCtrl::HitTest at call with 2 argument(s)");
				ZVAL_LONG(date0_ref, date_time0_1.GetTicks());

				return;
				break;
			}
			case 3:
			{
				wxDateTime date_time0_1 = wxDateTime(date0);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarCtrl::HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1, (wxDateTime::WeekDay*) wd0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCalendarCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, &date_time0_1, (wxDateTime::WeekDay*) wd0));

				references->AddReference(pos0, "wxCalendarCtrl::HitTest at call with 3 argument(s)");
				ZVAL_LONG(date0_ref, date_time0_1.GetTicks());
				size_t elements_returned0_2 = sizeof(wd0)/sizeof(*wd0);
				array_init(wd0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(wd0_ref, wd0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::HitTest\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::Mark(int day, bool mark)
   Mark or unmark the day. */
PHP_METHOD(php_wxCalendarCtrl, Mark)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::Mark\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::Mark\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long day0;
	bool mark0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&day0, &mark0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0, &mark0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::Mark((size_t) day0, mark0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->Mark((size_t) day0, mark0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::Mark\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::ResetAttr(int day)
   Clears any attributes associated with the given day (in the range 1...31). */
PHP_METHOD(php_wxCalendarCtrl, ResetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::ResetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::ResetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::ResetAttr((size_t) day0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->ResetAttr((size_t) day0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::ResetAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::SetAttr(int day, wxCalendarDateAttr &attr)
   Associates the attribute with the specified date (in the range 1...31). */
PHP_METHOD(php_wxCalendarCtrl, SetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetAttr\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long day0;
	zval* attr0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&day0, &attr0)\n");
		#endif
		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(attr0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetAttr((size_t) day0, (wxCalendarDateAttr*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetAttr((size_t) day0, (wxCalendarDateAttr*) object_pointer0_1);

				references->AddReference(attr0, "wxCalendarCtrl::SetAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetAttr\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarCtrl::SetDate(timestamp date)
   Sets the current date. */
PHP_METHOD(php_wxCalendarCtrl, SetDate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetDate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetDate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long date0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&date0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &date0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDate(wxDateTime(date0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDate(wxDateTime(date0)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetDate\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarCtrl::SetDateRange(timestamp lowerdate, timestamp upperdate)
   Restrict the dates that can be selected in the control to the specified range. */
PHP_METHOD(php_wxCalendarCtrl, SetDateRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetDateRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetDateRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long lowerdate0;
	long upperdate0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&lowerdate0, &upperdate0)\n");
		#endif
		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lowerdate0, &upperdate0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange(wxDateTime(lowerdate0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange(wxDateTime(lowerdate0)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarCtrl::SetDateRange(wxDateTime(lowerdate0), wxDateTime(upperdate0)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCalendarCtrl_php*)_this)->SetDateRange(wxDateTime(lowerdate0), wxDateTime(upperdate0)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetDateRange\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::SetHeaderColours(wxColour colFg, wxColour colBg)
   Set the colours used for painting the weekdays at the top of the control. */
PHP_METHOD(php_wxCalendarCtrl, SetHeaderColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHeaderColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHeaderColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHeaderColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHeaderColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0, "wxCalendarCtrl::SetHeaderColours at call with 2 argument(s)");
				references->AddReference(colBg0, "wxCalendarCtrl::SetHeaderColours at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetHeaderColours\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::SetHighlightColours(wxColour colFg, wxColour colBg)
   Set the colours to be used for highlighting the currently selected date. */
PHP_METHOD(php_wxCalendarCtrl, SetHighlightColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHighlightColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHighlightColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHighlightColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHighlightColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0, "wxCalendarCtrl::SetHighlightColours at call with 2 argument(s)");
				references->AddReference(colBg0, "wxCalendarCtrl::SetHighlightColours at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetHighlightColours\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::SetHoliday(int day)
   Marks the specified day as being a holiday in the current month. */
PHP_METHOD(php_wxCalendarCtrl, SetHoliday)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHoliday\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHoliday\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long day0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&day0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &day0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHoliday((size_t) day0)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHoliday((size_t) day0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetHoliday\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::SetHolidayColours(wxColour colFg, wxColour colBg)
   Sets the colours to be used for the holidays highlighting. */
PHP_METHOD(php_wxCalendarCtrl, SetHolidayColours)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::SetHolidayColours\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCalendarCtrl::SetHolidayColours\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCalendarCtrl){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colFg0 = 0;
	void* object_pointer0_0 = 0;
	zval* colBg0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colFg0, php_wxColour_entry, &colBg0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colFg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colFg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colFg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBg0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colBg0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBg0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarCtrl::SetHolidayColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxCalendarCtrl_php*)_this)->SetHolidayColours(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(colFg0, "wxCalendarCtrl::SetHolidayColours at call with 2 argument(s)");
				references->AddReference(colBg0, "wxCalendarCtrl::SetHolidayColours at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarCtrl::SetHolidayColours\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarCtrl::wxCalendarCtrl()
   Default constructor. */
PHP_METHOD(php_wxCalendarCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long date1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|lOOls' (&parent1, &id1, &date1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &date1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCalendarCtrl_php();

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1))\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1));

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 4 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1, "wxCalendarCtrl::wxCalendarCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 5 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1, "wxCalendarCtrl::wxCalendarCtrl at call with 5 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1, "wxCalendarCtrl::wxCalendarCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 6 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1, "wxCalendarCtrl::wxCalendarCtrl at call with 6 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1, "wxCalendarCtrl::wxCalendarCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxCalendarCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxDateTime(date1), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxCalendarCtrl_php*) _this)->references.Initialize();
				((wxCalendarCtrl_php*) _this)->references.AddReference(parent1, "wxCalendarCtrl::wxCalendarCtrl at call with 7 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(pos1, "wxCalendarCtrl::wxCalendarCtrl at call with 7 argument(s)");
				((wxCalendarCtrl_php*) _this)->references.AddReference(size1, "wxCalendarCtrl::wxCalendarCtrl at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCalendarCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxCalendarCtrl_php*) _this)->phpObj = getThis();
		
		((wxCalendarCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCalendarCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCalendarCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxCheckBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCheckBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxCheckBox::wxCheckBox(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Constructor, creating and showing a checkbox. */
PHP_METHOD(php_wxCheckBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 4 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(pos0, "wxCheckBox::wxCheckBox at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 5 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(pos0, "wxCheckBox::wxCheckBox at call with 5 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(size0, "wxCheckBox::wxCheckBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 6 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(pos0, "wxCheckBox::wxCheckBox at call with 6 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(size0, "wxCheckBox::wxCheckBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 7 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(pos0, "wxCheckBox::wxCheckBox at call with 7 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(size0, "wxCheckBox::wxCheckBox at call with 7 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(validator0, "wxCheckBox::wxCheckBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxCheckBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxCheckBox_php*) _this)->references.Initialize();
				((wxCheckBox_php*) _this)->references.AddReference(parent0, "wxCheckBox::wxCheckBox at call with 8 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(pos0, "wxCheckBox::wxCheckBox at call with 8 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(size0, "wxCheckBox::wxCheckBox at call with 8 argument(s)");
				((wxCheckBox_php*) _this)->references.AddReference(validator0, "wxCheckBox::wxCheckBox at call with 8 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCheckBox_php();

				((wxCheckBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCheckBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxCheckBox_php*) _this)->phpObj = getThis();
		
		((wxCheckBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCheckBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCheckBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxCheckBox::SetValue(bool state)
   Sets the checkbox to the given state. */
PHP_METHOD(php_wxCheckBox, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckBox::SetValue(state0)\n\n");
				#endif
				((wxCheckBox_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxCheckBox::Set3StateValue(wxCheckBoxState state)
   Sets the checkbox to the given state. */
PHP_METHOD(php_wxCheckBox, Set3StateValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Set3StateValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Set3StateValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&state0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckBox::Set3StateValue((wxCheckBoxState) state0)\n\n");
				#endif
				((wxCheckBox_php*)_this)->Set3StateValue((wxCheckBoxState) state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::Set3StateValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckBox::IsChecked()
   This is just a maybe more readable synonym for GetValue(): just as the latter, it returns true if the checkbox is checked and false otherwise. */
PHP_METHOD(php_wxCheckBox, IsChecked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::IsChecked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::IsChecked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::IsChecked())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->IsChecked());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::IsChecked\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckBox::Is3rdStateAllowedForUser()
   Returns whether or not the user can set the checkbox to the third state. */
PHP_METHOD(php_wxCheckBox, Is3rdStateAllowedForUser)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Is3rdStateAllowedForUser\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Is3rdStateAllowedForUser\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Is3rdStateAllowedForUser())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Is3rdStateAllowedForUser());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::Is3rdStateAllowedForUser\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckBox::Is3State()
   Returns whether or not the checkbox is a 3-state checkbox. */
PHP_METHOD(php_wxCheckBox, Is3State)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Is3State\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Is3State\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Is3State())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Is3State());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::Is3State\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckBox::GetValue()
   Gets the state of a 2-state checkbox. */
PHP_METHOD(php_wxCheckBox, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::GetValue\n");
	}
}
/* }}} */

/* {{{ proto wxCheckBoxState wxCheckBox::Get3StateValue()
   Gets the state of a 3-state checkbox. */
PHP_METHOD(php_wxCheckBox, Get3StateValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Get3StateValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Get3StateValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCheckBox::Get3StateValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxCheckBox_php*)_this)->Get3StateValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::Get3StateValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckBox::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the checkbox for two-step construction. */
PHP_METHOD(php_wxCheckBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckBox){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxCheckBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxCheckBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxCheckBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxCheckBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxCheckBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxCheckBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxCheckBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxCheckBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxCheckBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxCheckBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxCheckBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxCheckBox::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxCheckBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxCheckBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxCheckBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxCheckBox::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxCheckBox::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckBox::Create\n");
	}
}
/* }}} */

void php_wxCheckListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCheckListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxCheckListBox::Check(int item, bool check)
   Checks the given item. */
PHP_METHOD(php_wxCheckListBox, Check)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::Check\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::Check\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool check0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &check0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &check0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckListBox::Check((unsigned int) item0)\n\n");
				#endif
				((wxCheckListBox_php*)_this)->Check((unsigned int) item0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCheckListBox::Check((unsigned int) item0, check0)\n\n");
				#endif
				((wxCheckListBox_php*)_this)->Check((unsigned int) item0, check0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckListBox::Check\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckListBox::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int n, string choices, int style, wxValidator validator, string name)
   Creates the listbox for two-step construction. */
PHP_METHOD(php_wxCheckListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_5 = 1;
		HashTable* arr_hash0_5;
		if(arguments_received > 5)
		{
			arr_hash0_5 = Z_ARRVAL_P(choices0);
			array_count0_5 = zend_hash_num_elements(arr_hash0_5);
		}
		wxString* strings_array0_5 = new wxString[array_count0_5];
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 6 argument(s)");
				delete[] strings_array0_5;

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 7 argument(s)");
				delete[] strings_array0_5;

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 8 argument(s)");
				delete[] strings_array0_5;
				references->AddReference(validator0, "wxCheckListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxCheckListBox::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxCheckListBox::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxCheckListBox::Create at call with 9 argument(s)");
				delete[] strings_array0_5;
				references->AddReference(validator0, "wxCheckListBox::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4));

				references->AddReference(parent1, "wxCheckListBox::Create at call with 5 argument(s)");
				references->AddReference(pos1, "wxCheckListBox::Create at call with 5 argument(s)");
				references->AddReference(size1, "wxCheckListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1));

				references->AddReference(parent1, "wxCheckListBox::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxCheckListBox::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxCheckListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6));

				references->AddReference(parent1, "wxCheckListBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxCheckListBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxCheckListBox::Create at call with 7 argument(s)");
				references->AddReference(validator1, "wxCheckListBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxCheckListBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxCheckListBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxCheckListBox::Create at call with 8 argument(s)");
				references->AddReference(validator1, "wxCheckListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckListBox::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxCheckListBox::IsChecked(int item)
   Returns true if the given item is checked, false otherwise. */
PHP_METHOD(php_wxCheckListBox, IsChecked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::IsChecked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCheckListBox::IsChecked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCheckListBox){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCheckListBox::IsChecked((unsigned int) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCheckListBox_php*)_this)->IsChecked((unsigned int) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCheckListBox::IsChecked\n");
	}
}
/* }}} */

/* {{{ proto  wxCheckListBox::wxCheckListBox()
   Default constructor. */
PHP_METHOD(php_wxCheckListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCheckListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCheckListBox_php();

				((wxCheckListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1, "wxCheckListBox::wxCheckListBox at call with 5 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(pos1, "wxCheckListBox::wxCheckListBox at call with 5 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(size1, "wxCheckListBox::wxCheckListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1, "wxCheckListBox::wxCheckListBox at call with 6 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(pos1, "wxCheckListBox::wxCheckListBox at call with 6 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(size1, "wxCheckListBox::wxCheckListBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1, "wxCheckListBox::wxCheckListBox at call with 7 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(pos1, "wxCheckListBox::wxCheckListBox at call with 7 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(size1, "wxCheckListBox::wxCheckListBox at call with 7 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(validator1, "wxCheckListBox::wxCheckListBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxCheckListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxCheckListBox_php*) _this)->references.Initialize();
				((wxCheckListBox_php*) _this)->references.AddReference(parent1, "wxCheckListBox::wxCheckListBox at call with 8 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(pos1, "wxCheckListBox::wxCheckListBox at call with 8 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(size1, "wxCheckListBox::wxCheckListBox at call with 8 argument(s)");
				((wxCheckListBox_php*) _this)->references.AddReference(validator1, "wxCheckListBox::wxCheckListBox at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCheckListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxCheckListBox_php*) _this)->phpObj = getThis();
		
		((wxCheckListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCheckListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCheckListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxChoice_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxChoice_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxChoice::wxChoice()
   Default constructor. */
PHP_METHOD(php_wxChoice, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxChoice_php();

				((wxChoice_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1, "wxChoice::wxChoice at call with 5 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(pos1, "wxChoice::wxChoice at call with 5 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(size1, "wxChoice::wxChoice at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1, "wxChoice::wxChoice at call with 6 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(pos1, "wxChoice::wxChoice at call with 6 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(size1, "wxChoice::wxChoice at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1, "wxChoice::wxChoice at call with 7 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(pos1, "wxChoice::wxChoice at call with 7 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(size1, "wxChoice::wxChoice at call with 7 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(validator1, "wxChoice::wxChoice at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxChoice_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxChoice_php*) _this)->references.Initialize();
				((wxChoice_php*) _this)->references.AddReference(parent1, "wxChoice::wxChoice at call with 8 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(pos1, "wxChoice::wxChoice at call with 8 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(size1, "wxChoice::wxChoice at call with 8 argument(s)");
				((wxChoice_php*) _this)->references.AddReference(validator1, "wxChoice::wxChoice at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxChoice);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxChoice_php*) _this)->phpObj = getThis();
		
		((wxChoice_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxChoice_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxChoice::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxChoice::SetString(int n, string string)
   Sets the label for the given item. */
PHP_METHOD(php_wxChoice, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxChoice_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::SetString\n");
	}
}
/* }}} */

/* {{{ proto  wxChoice::SetSelection(int n)
   Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. */
PHP_METHOD(php_wxChoice, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetSelection((int) n0)\n\n");
				#endif
				((wxChoice_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxChoice::SetColumns(int n)
   Sets the number of columns in this choice item. */
PHP_METHOD(php_wxChoice, SetColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::SetColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::SetColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetColumns()\n\n");
				#endif
				((wxChoice_php*)_this)->SetColumns();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxChoice::SetColumns((int) n0)\n\n");
				#endif
				((wxChoice_php*)_this)->SetColumns((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::SetColumns\n");
	}
}
/* }}} */

/* {{{ proto bool wxChoice::IsSorted() */
PHP_METHOD(php_wxChoice, IsSorted)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::IsSorted\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::IsSorted\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::IsSorted())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->IsSorted());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::IsSorted\n");
	}
}
/* }}} */

/* {{{ proto string wxChoice::GetString(int n)
   Returns the label of the item with the given index. */
PHP_METHOD(php_wxChoice, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxChoice::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxChoice_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::GetString\n");
	}
}
/* }}} */

/* {{{ proto int wxChoice::GetSelection()
   Returns the index of the selected item or wxNOT_FOUND if no item is selected. */
PHP_METHOD(php_wxChoice, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto int wxChoice::GetCurrentSelection()
   Unlike wxControlWithItems::GetSelection() which only returns the accepted selection value, i.e. */
PHP_METHOD(php_wxChoice, GetCurrentSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetCurrentSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetCurrentSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetCurrentSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetCurrentSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::GetCurrentSelection\n");
	}
}
/* }}} */

/* {{{ proto int wxChoice::GetCount()
   Returns the number of items in the control. */
PHP_METHOD(php_wxChoice, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::GetCount\n");
	}
}
/* }}} */

/* {{{ proto int wxChoice::GetColumns()
   Gets the number of columns in this choice item. */
PHP_METHOD(php_wxChoice, GetColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::GetColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::GetColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::GetColumns())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->GetColumns());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::GetColumns\n");
	}
}
/* }}} */

/* {{{ proto int wxChoice::FindString(string string, bool caseSensitive)
   Finds an item whose label matches the given string. */
PHP_METHOD(php_wxChoice, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxChoice::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxChoice_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::FindString\n");
	}
}
/* }}} */

/* {{{ proto bool wxChoice::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Creates the choice for two-step construction. */
PHP_METHOD(php_wxChoice, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxChoice::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxChoice::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxChoice){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4));

				references->AddReference(parent0, "wxChoice::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxChoice::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxChoice::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0));

				references->AddReference(parent0, "wxChoice::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxChoice::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxChoice::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxChoice::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxChoice::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxChoice::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxChoice::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxChoice::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxChoice::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxChoice::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxChoice::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_5 = 1;
		HashTable* arr_hash1_5;
		if(arguments_received > 5)
		{
			arr_hash1_5 = Z_ARRVAL_P(choices1);
			array_count1_5 = zend_hash_num_elements(arr_hash1_5);
		}
		wxString* strings_array1_5 = new wxString[array_count1_5];
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1));

				references->AddReference(parent1, "wxChoice::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2));

				references->AddReference(parent1, "wxChoice::Create at call with 3 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3));

				references->AddReference(parent1, "wxChoice::Create at call with 4 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 4 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1));

				references->AddReference(parent1, "wxChoice::Create at call with 5 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 5 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5));

				references->AddReference(parent1, "wxChoice::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 6 argument(s)");
				delete[] strings_array1_5;

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1));

				references->AddReference(parent1, "wxChoice::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 7 argument(s)");
				delete[] strings_array1_5;

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1, "wxChoice::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 8 argument(s)");
				delete[] strings_array1_5;
				references->AddReference(validator1, "wxChoice::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxChoice::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxChoice::Create at call with 9 argument(s)");
				references->AddReference(pos1, "wxChoice::Create at call with 9 argument(s)");
				references->AddReference(size1, "wxChoice::Create at call with 9 argument(s)");
				delete[] strings_array1_5;
				references->AddReference(validator1, "wxChoice::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxChoice::Create\n");
	}
}
/* }}} */

void php_wxCollapsiblePane_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxCollapsiblePane_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxCollapsiblePane::wxCollapsiblePane(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Initializes the object and calls Create() with all the parameters. */
PHP_METHOD(php_wxCollapsiblePane, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8))\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8));

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 4 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0, "wxCollapsiblePane::wxCollapsiblePane at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 5 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0, "wxCollapsiblePane::wxCollapsiblePane at call with 5 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0, "wxCollapsiblePane::wxCollapsiblePane at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 6 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0, "wxCollapsiblePane::wxCollapsiblePane at call with 6 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0, "wxCollapsiblePane::wxCollapsiblePane at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 7 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0, "wxCollapsiblePane::wxCollapsiblePane at call with 7 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0, "wxCollapsiblePane::wxCollapsiblePane at call with 7 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(validator0, "wxCollapsiblePane::wxCollapsiblePane at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxCollapsiblePane_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				((wxCollapsiblePane_php*) _this)->references.AddReference(parent0, "wxCollapsiblePane::wxCollapsiblePane at call with 8 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(pos0, "wxCollapsiblePane::wxCollapsiblePane at call with 8 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(size0, "wxCollapsiblePane::wxCollapsiblePane at call with 8 argument(s)");
				((wxCollapsiblePane_php*) _this)->references.AddReference(validator0, "wxCollapsiblePane::wxCollapsiblePane at call with 8 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxCollapsiblePane_php();

				((wxCollapsiblePane_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxCollapsiblePane);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxCollapsiblePane_php*) _this)->phpObj = getThis();
		
		((wxCollapsiblePane_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxCollapsiblePane_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCollapsiblePane::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxCollapsiblePane::IsExpanded()
   Returns true if the pane window is currently shown. */
PHP_METHOD(php_wxCollapsiblePane, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::IsExpanded())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->IsExpanded());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::IsExpanded\n");
	}
}
/* }}} */

/* {{{ proto bool wxCollapsiblePane::IsCollapsed()
   Returns true if the pane window is currently hidden. */
PHP_METHOD(php_wxCollapsiblePane, IsCollapsed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::IsCollapsed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::IsCollapsed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::IsCollapsed())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->IsCollapsed());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::IsCollapsed\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxCollapsiblePane::GetPane()
   Returns a pointer to the pane window. */
PHP_METHOD(php_wxCollapsiblePane, GetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::GetPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::GetPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::GetPane() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxCollapsiblePane_php*)_this)->GetPane();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxCollapsiblePane::GetPane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::GetPane\n");
	}
}
/* }}} */

/* {{{ proto  wxCollapsiblePane::Expand()
   Same as calling Collapse(false). */
PHP_METHOD(php_wxCollapsiblePane, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Expand()\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Expand();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::Expand\n");
	}
}
/* }}} */

/* {{{ proto bool wxCollapsiblePane::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name) */
PHP_METHOD(php_wxCollapsiblePane, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxCollapsiblePane::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxCollapsiblePane::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxCollapsiblePane::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxCollapsiblePane::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxCollapsiblePane::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxCollapsiblePane::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxCollapsiblePane::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxCollapsiblePane::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCollapsiblePane::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxCollapsiblePane_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxCollapsiblePane::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxCollapsiblePane::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxCollapsiblePane::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxCollapsiblePane::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxCollapsiblePane::Collapse(bool collapse)
   Collapses or expands the pane window. */
PHP_METHOD(php_wxCollapsiblePane, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCollapsiblePane::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxCollapsiblePane::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxCollapsiblePane){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool collapse0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&collapse0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &collapse0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Collapse()\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Collapse();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCollapsiblePane::Collapse(collapse0)\n\n");
				#endif
				((wxCollapsiblePane_php*)_this)->Collapse(collapse0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCollapsiblePane::Collapse\n");
	}
}
/* }}} */

void php_wxComboPopup_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxComboPopup_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxComboPopup_php* object = static_cast<wxComboPopup_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxComboPopup done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxComboPopup::wxComboPopup()
   Default constructor. */
PHP_METHOD(php_wxComboPopup, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboPopup_php();

				((wxComboPopup_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboPopup);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxComboPopup_php*) _this)->phpObj = getThis();
		
		((wxComboPopup_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboPopup_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxComboPopup::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxComboPopup, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::__get\n");
	php_printf("===========================================\n");
	#endif
	
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	
	char* name;
	int name_len;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::wxComboPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_combo", name) == 0)
	{
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto  wxComboPopup::SetStringValue(string value)
   The derived class must implement this to receive string value changes from wxComboCtrl. */
PHP_METHOD(php_wxComboPopup, SetStringValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::SetStringValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::SetStringValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::SetStringValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboPopup_php*)_this)->SetStringValue(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::SetStringValue\n");
	}
}
/* }}} */

/* {{{ proto  wxComboPopup::PaintComboControl(wxDC &dc, wxRect rect)
   The derived class may implement this to paint the parent wxComboCtrl. */
PHP_METHOD(php_wxComboPopup, PaintComboControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::PaintComboControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::PaintComboControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&dc0, php_wxDC_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::PaintComboControl(*(wxDC*) object_pointer0_0, *(wxRect*) object_pointer0_1)\n\n");
				#endif
				((wxComboPopup_php*)_this)->PaintComboControl(*(wxDC*) object_pointer0_0, *(wxRect*) object_pointer0_1);

				references->AddReference(dc0, "wxComboPopup::PaintComboControl at call with 2 argument(s)");
				references->AddReference(rect0, "wxComboPopup::PaintComboControl at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::PaintComboControl\n");
	}
}
/* }}} */

/* {{{ proto  wxComboPopup::OnPopup()
   The derived class may implement this to do special processing when popup is shown. */
void wxComboPopup_php::OnPopup()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnPopup\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnPopup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnPopup", 7, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnPopup();
}
/* }}} */

/* {{{ proto  wxComboPopup::OnDismiss()
   The derived class may implement this to do special processing when popup is hidden. */
void wxComboPopup_php::OnDismiss()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnDismiss\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDismiss", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDismiss", 9, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnDismiss();
}
/* }}} */

/* {{{ proto  wxComboPopup::OnComboKeyEvent(wxKeyEvent &event)
   The derived class may implement this to receive key events from the parent wxComboCtrl. */
void wxComboPopup_php::OnComboKeyEvent(wxKeyEvent& event)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnComboKeyEvent\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnComboKeyEvent", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxKeyEvent_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&event, le_wxKeyEvent));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnComboKeyEvent", 15, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnComboKeyEvent(event);
}
/* }}} */

/* {{{ proto  wxComboPopup::OnComboDoubleClick()
   The derived class may implement this to do something when the parent wxComboCtrl gets double-clicked. */
void wxComboPopup_php::OnComboDoubleClick()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::OnComboDoubleClick\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnComboDoubleClick", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnComboDoubleClick", 18, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboPopup::OnComboDoubleClick();
}
/* }}} */

/* {{{ proto bool wxComboPopup::LazyCreate()
   The derived class may implement this to return true if it wants to delay call to Create() until the popup is shown for the first time. */
PHP_METHOD(php_wxComboPopup, LazyCreate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::LazyCreate\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::LazyCreate\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::LazyCreate())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->LazyCreate());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::LazyCreate\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboPopup::IsCreated()
   Utility method that returns true if Create has been called. */
PHP_METHOD(php_wxComboPopup, IsCreated)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::IsCreated\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::IsCreated\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::IsCreated())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->IsCreated());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::IsCreated\n");
	}
}
/* }}} */

/* {{{ proto  wxComboPopup::Init()
   The derived class must implement this to initialize its internal variables. */
PHP_METHOD(php_wxComboPopup, Init)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::Init\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::Init\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::Init()\n\n");
				#endif
				((wxComboPopup_php*)_this)->Init();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::Init\n");
	}
}
/* }}} */

/* {{{ proto string wxComboPopup::GetStringValue()
   The derived class must implement this to return string representation of the value. */
wxString wxComboPopup_php::GetStringValue()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::GetStringValue\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetStringValue", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetStringValue", 14, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxComboPopup::GetStringValue'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto wxWindow wxComboPopup::GetControl()
   The derived class must implement this to return pointer to the associated control created in Create(). */
wxWindow* wxComboPopup_php::GetControl()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::GetControl\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetControl", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetControl", 10, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxComboPopup::GetControl'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxWindow_php* var = (wxWindow_php*) return_object;
		var->references.UnInitialize();

		return (wxWindow*) return_object;
	
}
/* }}} */

/* {{{ proto wxComboCtrl wxComboPopup::GetComboCtrl()
   Returns pointer to the associated parent wxComboCtrl. */
PHP_METHOD(php_wxComboPopup, GetComboCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::GetComboCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::GetComboCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::GetComboCtrl() to return object pointer\n\n");
				#endif
				wxComboCtrl_php* value_to_return0;
				value_to_return0 = (wxComboCtrl_php*) ((wxComboPopup_php*)_this)->GetComboCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxComboCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxComboCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxComboPopup::GetComboCtrl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::GetComboCtrl\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxComboPopup::GetAdjustedSize(int minWidth, int prefHeight, int maxHeight)
   The derived class may implement this to return adjusted size for the popup control, according to the variables given. */
PHP_METHOD(php_wxComboPopup, GetAdjustedSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::GetAdjustedSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::GetAdjustedSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long minWidth0;
	long prefHeight0;
	long maxHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&minWidth0, &prefHeight0, &maxHeight0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minWidth0, &prefHeight0, &maxHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::GetAdjustedSize((int) minWidth0, (int) prefHeight0, (int) maxHeight0) to return new object\n\n");
				#endif
				wxSize value_to_return3;
				value_to_return3 = ((wxComboPopup_php*)_this)->GetAdjustedSize((int) minWidth0, (int) prefHeight0, (int) maxHeight0);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::GetAdjustedSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboPopup::FindItem(string item, string &trueItem)
   Implement to customize matching of value string to an item container entry. */
PHP_METHOD(php_wxComboPopup, FindItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::FindItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::FindItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	char* trueItem0;
	long trueItem_len0;
	zval* trueItem0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&item0, &item_len0, &trueItem0, &trueItem_len0)\n");
		#endif
		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &trueItem0, &trueItem_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &trueItem0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::FindItem(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->FindItem(wxString(item0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				wxString string_arg0_1 = wxString(trueItem0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboPopup::FindItem(wxString(item0, wxConvUTF8), &string_arg0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboPopup_php*)_this)->FindItem(wxString(item0, wxConvUTF8), &string_arg0_1));

				char* temp_string0_1;
				temp_string0_1 = (char*)malloc(sizeof(wxChar)*(string_arg0_1.size()+1));
				strcpy (temp_string0_1, (const char *) string_arg0_1.char_str() );
				ZVAL_STRING(trueItem0_ref, (char*) temp_string0_1, 1);
				free(temp_string0_1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::FindItem\n");
	}
}
/* }}} */

/* {{{ proto  wxComboPopup::Dismiss()
   Utility function that hides the popup. */
PHP_METHOD(php_wxComboPopup, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::Dismiss()\n\n");
				#endif
				((wxComboPopup_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::Dismiss\n");
	}
}
/* }}} */

/* {{{ proto  wxComboPopup::DestroyPopup()
   You only need to implement this member function if you create your popup class in non-standard way. */
PHP_METHOD(php_wxComboPopup, DestroyPopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboPopup::DestroyPopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboPopup::DestroyPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboPopup){
				references = &((wxComboPopup_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboPopup::DestroyPopup()\n\n");
				#endif
				((wxComboPopup_php*)_this)->DestroyPopup();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboPopup::DestroyPopup\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboPopup::Create(wxWindow &parent)
   The derived class must implement this to create the popup control. */
bool wxComboPopup_php::Create(wxWindow* parent)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboPopup::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Create", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)parent, le_wxWindow));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Create", 6, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxComboPopup::Create'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

void php_wxComboCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxComboCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxComboCtrl::wxComboCtrl()
   Default constructor. */
PHP_METHOD(php_wxComboCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboCtrl_php();

				((wxComboCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 4 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(pos1, "wxComboCtrl::wxComboCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 5 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(pos1, "wxComboCtrl::wxComboCtrl at call with 5 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(size1, "wxComboCtrl::wxComboCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 6 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(pos1, "wxComboCtrl::wxComboCtrl at call with 6 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(size1, "wxComboCtrl::wxComboCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 7 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(pos1, "wxComboCtrl::wxComboCtrl at call with 7 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(size1, "wxComboCtrl::wxComboCtrl at call with 7 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(validator1, "wxComboCtrl::wxComboCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxComboCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxComboCtrl_php*) _this)->references.Initialize();
				((wxComboCtrl_php*) _this)->references.AddReference(parent1, "wxComboCtrl::wxComboCtrl at call with 8 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(pos1, "wxComboCtrl::wxComboCtrl at call with 8 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(size1, "wxComboCtrl::wxComboCtrl at call with 8 argument(s)");
				((wxComboCtrl_php*) _this)->references.AddReference(validator1, "wxComboCtrl::wxComboCtrl at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxComboCtrl_php*) _this)->phpObj = getThis();
		
		((wxComboCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxComboCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxComboCtrl::UseAltPopupWindow(bool enable)
   Enable or disable usage of an alternative popup window, which guarantees ability to focus the popup control, and allows common native controls to function normally. */
PHP_METHOD(php_wxComboCtrl, UseAltPopupWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::UseAltPopupWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::UseAltPopupWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::UseAltPopupWindow()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->UseAltPopupWindow();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::UseAltPopupWindow(enable0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->UseAltPopupWindow(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::UseAltPopupWindow\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Undo()
   Undoes the last edit in the text field. */
PHP_METHOD(php_wxComboCtrl, Undo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Undo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Undo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Undo()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Undo();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Undo\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::ShowPopup()
   Show the popup. */
PHP_METHOD(php_wxComboCtrl, ShowPopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::ShowPopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::ShowPopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::ShowPopup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->ShowPopup();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::ShowPopup\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetValue(string value)
   Sets the text for the combo control text field. */
PHP_METHOD(php_wxComboCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetTextIndent(int indent)
   This will set the space in pixels between left edge of the control and the text, regardless whether control is read-only or not. */
PHP_METHOD(php_wxComboCtrl, SetTextIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetTextIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetTextIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetTextIndent((int) indent0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetTextIndent((int) indent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetTextIndent\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetTextCtrlStyle(int style)
   Set a custom window style for the embedded wxTextCtrl. */
PHP_METHOD(php_wxComboCtrl, SetTextCtrlStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetTextCtrlStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetTextCtrlStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetTextCtrlStyle((int) style0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetTextCtrlStyle((int) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetTextCtrlStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetText(string value)
   Sets the text for the text field without affecting the popup. */
PHP_METHOD(php_wxComboCtrl, SetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetText(wxString(value0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetText(wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetText\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetSelection(int from, int to)
   Selects the text between the two positions, in the combo control text field. */
PHP_METHOD(php_wxComboCtrl, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetSelection((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetPopupMinWidth(int width)
   Sets minimum width of the popup. */
PHP_METHOD(php_wxComboCtrl, SetPopupMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupMinWidth((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupMinWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetPopupMinWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetPopupMaxHeight(int height)
   Sets preferred maximum height of the popup. */
PHP_METHOD(php_wxComboCtrl, SetPopupMaxHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupMaxHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupMaxHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupMaxHeight((int) height0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupMaxHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetPopupMaxHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetPopupExtents(int extLeft, int extRight)
   Extends popup size horizontally, relative to the edges of the combo control. */
PHP_METHOD(php_wxComboCtrl, SetPopupExtents)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupExtents\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupExtents\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long extLeft0;
	long extRight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&extLeft0, &extRight0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extLeft0, &extRight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupExtents((int) extLeft0, (int) extRight0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupExtents((int) extLeft0, (int) extRight0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetPopupExtents\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetPopupControl(wxComboPopup &popup)
   Set popup interface class derived from wxComboPopup. */
PHP_METHOD(php_wxComboCtrl, SetPopupControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* popup0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&popup0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &popup0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(popup0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(popup0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(popup0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupControl((wxComboPopup*) object_pointer0_0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupControl((wxComboPopup*) object_pointer0_0);

				references->AddReference(popup0, "wxComboCtrl::SetPopupControl at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetPopupControl\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetPopupAnchor(int anchorSide)
   Set side of the control to which the popup will align itself. */
PHP_METHOD(php_wxComboCtrl, SetPopupAnchor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetPopupAnchor\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetPopupAnchor\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long anchorSide0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&anchorSide0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &anchorSide0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetPopupAnchor((int) anchorSide0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetPopupAnchor((int) anchorSide0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetPopupAnchor\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboCtrl::SetMargins(int left, int top)
   Attempts to set the control margins. */
PHP_METHOD(php_wxComboCtrl, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long left0;
	long top0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&left0, &top0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &top0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins((wxCoord) left0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins((wxCoord) left0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins((wxCoord) left0, (wxCoord) top0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetMargins(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));

				references->AddReference(pt1, "wxComboCtrl::SetMargins at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetInsertionPointEnd()
   Sets the insertion point at the end of the combo control text field. */
PHP_METHOD(php_wxComboCtrl, SetInsertionPointEnd)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetInsertionPointEnd\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetInsertionPointEnd\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetInsertionPointEnd()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetInsertionPointEnd();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetInsertionPointEnd\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetInsertionPoint(int pos)
   Sets the insertion point in the text field. */
PHP_METHOD(php_wxComboCtrl, SetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetInsertionPoint((long) pos0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetInsertionPoint((long) pos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetInsertionPoint\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetCustomPaintWidth(int width)
   Set width, in pixels, of custom painted area in control without wxCB_READONLY style. */
PHP_METHOD(php_wxComboCtrl, SetCustomPaintWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetCustomPaintWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetCustomPaintWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetCustomPaintWidth((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetCustomPaintWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetCustomPaintWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetButtonPosition(int width, int height, int side, int spacingX)
   Sets size and position of dropdown button. */
PHP_METHOD(php_wxComboCtrl, SetButtonPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetButtonPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetButtonPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	long side0;
	long spacingX0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llll' (&width0, &height0, &side0, &spacingX0)\n");
		#endif
		char parse_parameters_string[] = "|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &side0, &spacingX0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0, (int) side0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0, (int) side0);


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonPosition((int) width0, (int) height0, (int) side0, (int) spacingX0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonPosition((int) width0, (int) height0, (int) side0, (int) spacingX0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetButtonPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::SetButtonBitmaps(wxBitmap bmpNormal, bool pushButtonBg, wxBitmap bmpPressed, wxBitmap bmpHover, wxBitmap bmpDisabled)
   Sets custom dropdown button graphics. */
PHP_METHOD(php_wxComboCtrl, SetButtonBitmaps)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetButtonBitmaps\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetButtonBitmaps\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmpNormal0 = 0;
	void* object_pointer0_0 = 0;
	bool pushButtonBg0;
	zval* bmpPressed0 = 0;
	void* object_pointer0_2 = 0;
	zval* bmpHover0 = 0;
	void* object_pointer0_3 = 0;
	zval* bmpDisabled0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|bOOO' (&bmpNormal0, php_wxBitmap_entry, &pushButtonBg0, &bmpPressed0, php_wxBitmap_entry, &bmpHover0, php_wxBitmap_entry, &bmpDisabled0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O|bOOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmpNormal0, php_wxBitmap_entry, &pushButtonBg0, &bmpPressed0, php_wxBitmap_entry, &bmpHover0, php_wxBitmap_entry, &bmpDisabled0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmpNormal0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpNormal0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpNormal0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(bmpPressed0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpPressed0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpPressed0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(bmpHover0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpHover0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpHover0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(bmpDisabled0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmpDisabled0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmpDisabled0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmpNormal0, "wxComboCtrl::SetButtonBitmaps at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0);

				references->AddReference(bmpNormal0, "wxComboCtrl::SetButtonBitmaps at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2);

				references->AddReference(bmpNormal0, "wxComboCtrl::SetButtonBitmaps at call with 3 argument(s)");
				references->AddReference(bmpPressed0, "wxComboCtrl::SetButtonBitmaps at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3);

				references->AddReference(bmpNormal0, "wxComboCtrl::SetButtonBitmaps at call with 4 argument(s)");
				references->AddReference(bmpPressed0, "wxComboCtrl::SetButtonBitmaps at call with 4 argument(s)");
				references->AddReference(bmpHover0, "wxComboCtrl::SetButtonBitmaps at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3, *(wxBitmap*) object_pointer0_4)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->SetButtonBitmaps(*(wxBitmap*) object_pointer0_0, pushButtonBg0, *(wxBitmap*) object_pointer0_2, *(wxBitmap*) object_pointer0_3, *(wxBitmap*) object_pointer0_4);

				references->AddReference(bmpNormal0, "wxComboCtrl::SetButtonBitmaps at call with 5 argument(s)");
				references->AddReference(bmpPressed0, "wxComboCtrl::SetButtonBitmaps at call with 5 argument(s)");
				references->AddReference(bmpHover0, "wxComboCtrl::SetButtonBitmaps at call with 5 argument(s)");
				references->AddReference(bmpDisabled0, "wxComboCtrl::SetButtonBitmaps at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetButtonBitmaps\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Replace(int from, int to, string text)
   Replaces the text between two positions with the given text, in the combo control text field. */
PHP_METHOD(php_wxComboCtrl, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Replace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&from0, &to0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Replace((long) from0, (long) to0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Replace\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Remove(int from, int to)
   Removes the text between the two positions in the combo control text field. */
PHP_METHOD(php_wxComboCtrl, Remove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Remove\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Remove\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Remove((long) from0, (long) to0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Remove((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Remove\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Popup()
   Shows the popup portion of the combo control. */
PHP_METHOD(php_wxComboCtrl, Popup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Popup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Popup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Popup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Popup();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Popup\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Paste()
   Pastes text from the clipboard to the text field. */
PHP_METHOD(php_wxComboCtrl, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Paste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Paste()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Paste();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Paste\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::OnButtonClick()
   Implement in a derived class to define what happens on dropdown button click. */
void wxComboCtrl_php::OnButtonClick()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::OnButtonClick\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnButtonClick", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnButtonClick", 13, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::OnButtonClick();
}
/* }}} */

/* {{{ proto bool wxComboCtrl::IsPopupWindowState(int state)
   Returns true if the popup window is in the given state. */
PHP_METHOD(php_wxComboCtrl, IsPopupWindowState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::IsPopupWindowState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::IsPopupWindowState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&state0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::IsPopupWindowState((int) state0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsPopupWindowState((int) state0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::IsPopupWindowState\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboCtrl::IsPopupShown()
   Returns true if the popup is currently shown. */
PHP_METHOD(php_wxComboCtrl, IsPopupShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::IsPopupShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::IsPopupShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::IsPopupShown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsPopupShown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::IsPopupShown\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::HidePopup(bool generateEvent)
   Dismisses the popup window. */
PHP_METHOD(php_wxComboCtrl, HidePopup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::HidePopup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::HidePopup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool generateEvent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&generateEvent0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &generateEvent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::HidePopup()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->HidePopup();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::HidePopup(generateEvent0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->HidePopup(generateEvent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::HidePopup\n");
	}
}
/* }}} */

/* {{{ proto string wxComboCtrl::GetValue()
   Returns text representation of the current value. */
PHP_METHOD(php_wxComboCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboCtrl::GetValue().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetValue();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetValue\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxComboCtrl::GetTextRect()
   Returns area covered by the text field (includes everything except borders and the dropdown button). */
PHP_METHOD(php_wxComboCtrl, GetTextRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetTextRect() to return object reference\n\n");
				#endif
				wxRect_php* value_to_return0;
				value_to_return0 = (wxRect_php*) &((wxComboCtrl_php*)_this)->GetTextRect();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxRect));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxComboCtrl::GetTextRect at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetTextRect\n");
	}
}
/* }}} */

/* {{{ proto int wxComboCtrl::GetTextIndent()
   Returns actual indentation in pixels. */
PHP_METHOD(php_wxComboCtrl, GetTextIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetTextIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetTextIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetTextIndent\n");
	}
}
/* }}} */

/* {{{ proto wxTextCtrl wxComboCtrl::GetTextCtrl()
   Get the text control which is part of the combo control. */
PHP_METHOD(php_wxComboCtrl, GetTextCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetTextCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetTextCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetTextCtrl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxComboCtrl_php*)_this)->GetTextCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxComboCtrl::GetTextCtrl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetTextCtrl\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxComboCtrl::GetPopupWindow()
   Returns popup window containing the popup control. */
PHP_METHOD(php_wxComboCtrl, GetPopupWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetPopupWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetPopupWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetPopupWindow() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxComboCtrl_php*)_this)->GetPopupWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxComboCtrl::GetPopupWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetPopupWindow\n");
	}
}
/* }}} */

/* {{{ proto wxComboPopup wxComboCtrl::GetPopupControl()
   Returns current popup interface that has been set with SetPopupControl(). */
PHP_METHOD(php_wxComboCtrl, GetPopupControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetPopupControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetPopupControl() to return object pointer\n\n");
				#endif
				wxComboPopup_php* value_to_return0;
				value_to_return0 = (wxComboPopup_php*) ((wxComboCtrl_php*)_this)->GetPopupControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxComboPopup_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxComboPopup));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxComboCtrl::GetPopupControl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetPopupControl\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxComboCtrl::GetMargins()
   Returns the margins used by the control. */
PHP_METHOD(php_wxComboCtrl, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetMargins();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetMargins\n");
	}
}
/* }}} */

/* {{{ proto int wxComboCtrl::GetLastPosition()
   Returns the last position in the combo control text field. */
PHP_METHOD(php_wxComboCtrl, GetLastPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetLastPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetLastPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetLastPosition())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetLastPosition());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetLastPosition\n");
	}
}
/* }}} */

/* {{{ proto int wxComboCtrl::GetInsertionPoint()
   Returns the insertion point for the combo control's text field. */
PHP_METHOD(php_wxComboCtrl, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetInsertionPoint())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetInsertionPoint());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetInsertionPoint\n");
	}
}
/* }}} */

/* {{{ proto string wxComboCtrl::GetHint()
   Returns the current hint string. */
PHP_METHOD(php_wxComboCtrl, GetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboCtrl::GetHint().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetHint();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetHint\n");
	}
}
/* }}} */

/* {{{ proto int wxComboCtrl::GetFeatures()
   Returns features supported by wxComboCtrl. */
PHP_METHOD(php_wxComboCtrl, GetFeatures)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetFeatures\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetFeatures\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetFeatures())\n\n");
				#endif
				ZVAL_LONG(return_value, wxComboCtrl::GetFeatures());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetFeatures\n");
	}
}
/* }}} */

/* {{{ proto int wxComboCtrl::GetCustomPaintWidth()
   Returns custom painted area in control. */
PHP_METHOD(php_wxComboCtrl, GetCustomPaintWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetCustomPaintWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetCustomPaintWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboCtrl::GetCustomPaintWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboCtrl_php*)_this)->GetCustomPaintWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetCustomPaintWidth\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxComboCtrl::GetButtonSize()
   Returns current size of the dropdown button. */
PHP_METHOD(php_wxComboCtrl, GetButtonSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetButtonSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetButtonSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetButtonSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxComboCtrl_php*)_this)->GetButtonSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetButtonSize\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxComboCtrl::GetBitmapPressed()
   Returns depressed button bitmap that has been set with SetButtonBitmaps(). */
PHP_METHOD(php_wxComboCtrl, GetBitmapPressed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapPressed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapPressed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapPressed() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapPressed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxComboCtrl::GetBitmapPressed at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetBitmapPressed\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxComboCtrl::GetBitmapNormal()
   Returns default button bitmap that has been set with SetButtonBitmaps(). */
PHP_METHOD(php_wxComboCtrl, GetBitmapNormal)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapNormal\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapNormal\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapNormal() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapNormal();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxComboCtrl::GetBitmapNormal at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetBitmapNormal\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxComboCtrl::GetBitmapHover()
   Returns button mouse hover bitmap that has been set with SetButtonBitmaps(). */
PHP_METHOD(php_wxComboCtrl, GetBitmapHover)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapHover\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapHover\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapHover() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapHover();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxComboCtrl::GetBitmapHover at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetBitmapHover\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxComboCtrl::GetBitmapDisabled()
   Returns disabled button bitmap that has been set with SetButtonBitmaps(). */
PHP_METHOD(php_wxComboCtrl, GetBitmapDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::GetBitmapDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::GetBitmapDisabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::GetBitmapDisabled() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxComboCtrl_php*)_this)->GetBitmapDisabled();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxComboCtrl::GetBitmapDisabled at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::GetBitmapDisabled\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::EnablePopupAnimation(bool enable)
   Enables or disables popup animation, if any, depending on the value of the argument. */
PHP_METHOD(php_wxComboCtrl, EnablePopupAnimation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::EnablePopupAnimation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::EnablePopupAnimation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::EnablePopupAnimation()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->EnablePopupAnimation();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::EnablePopupAnimation(enable0)\n\n");
				#endif
				((wxComboCtrl_php*)_this)->EnablePopupAnimation(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::EnablePopupAnimation\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::DoShowPopup(wxRect rect, int flags)
   This member function is not normally called in application code. */
void wxComboCtrl_php::DoShowPopup(const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::DoShowPopup\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoShowPopup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxRect_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[1], flags);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DoShowPopup", 11, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::DoShowPopup(rect, flags);
}
/* }}} */

/* {{{ proto  wxComboCtrl::DoSetPopupControl(wxComboPopup &popup)
   This member function is not normally called in application code. */
void wxComboCtrl_php::DoSetPopupControl(wxComboPopup* popup)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::DoSetPopupControl\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DoSetPopupControl", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxComboPopup_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)popup, le_wxComboPopup));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DoSetPopupControl", 17, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxComboCtrl::DoSetPopupControl(popup);
}
/* }}} */

/* {{{ proto  wxComboCtrl::Dismiss()
   Dismisses the popup window. */
PHP_METHOD(php_wxComboCtrl, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Dismiss()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Dismiss\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Cut()
   Copies the selected text to the clipboard and removes the selection. */
PHP_METHOD(php_wxComboCtrl, Cut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Cut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Cut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Cut()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Cut();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Cut\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboCtrl::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the combo control for two-step construction. */
PHP_METHOD(php_wxComboCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxComboCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxComboCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxComboCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxComboCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxComboCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxComboCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxComboCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxComboCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxComboCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxComboCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxComboCtrl::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxComboCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxComboCtrl::Copy()
   Copies the selected text to the clipboard. */
PHP_METHOD(php_wxComboCtrl, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::Copy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboCtrl::Copy()\n\n");
				#endif
				((wxComboCtrl_php*)_this)->Copy();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::Copy\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboCtrl::AnimateShow(wxRect rect, int flags)
   This member function is not normally called in application code. */
bool wxComboCtrl_php::AnimateShow(const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxComboCtrl::AnimateShow\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "AnimateShow", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxRect_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[1], flags);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "AnimateShow", 11, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxComboCtrl::AnimateShow(rect, flags);
}
/* }}} */

/* {{{ proto bool wxComboCtrl::SetHint(string hint)
   Sets a hint shown in an empty unfocused combo control. */
PHP_METHOD(php_wxComboCtrl, SetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboCtrl::SetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboCtrl::SetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboCtrl){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* hint0;
	long hint_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&hint0, &hint_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hint0, &hint_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboCtrl::SetHint(wxString(hint0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboCtrl::SetHint\n");
	}
}
/* }}} */

void php_wxComboBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxComboBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxComboBox::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int n, string choices, int style, wxValidator validator, string name)
   Creates the combobox for two-step construction. */
PHP_METHOD(php_wxComboBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_8 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlalOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_8 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_6 = 1;
		HashTable* arr_hash0_6;
		if(arguments_received > 6)
		{
			arr_hash0_6 = Z_ARRVAL_P(choices0);
			array_count0_6 = zend_hash_num_elements(arr_hash0_6);
		}
		wxString* strings_array0_6 = new wxString[array_count0_6];
		bool strings_continue0_6 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxComboBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxComboBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxComboBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxComboBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0));

				references->AddReference(parent0, "wxComboBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6));

				references->AddReference(parent0, "wxComboBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 7 argument(s)");
				delete[] strings_array0_6;

				return;
				break;
			}
			case 8:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0));

				references->AddReference(parent0, "wxComboBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 8 argument(s)");
				delete[] strings_array0_6;

				return;
				break;
			}
			case 9:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8));

				references->AddReference(parent0, "wxComboBox::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 9 argument(s)");
				delete[] strings_array0_6;
				references->AddReference(validator0, "wxComboBox::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxComboBox::Create at call with 10 argument(s)");
				references->AddReference(pos0, "wxComboBox::Create at call with 10 argument(s)");
				references->AddReference(size0, "wxComboBox::Create at call with 10 argument(s)");
				delete[] strings_array0_6;
				references->AddReference(validator0, "wxComboBox::Create at call with 10 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5));

				references->AddReference(parent1, "wxComboBox::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxComboBox::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxComboBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1));

				references->AddReference(parent1, "wxComboBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxComboBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxComboBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1, "wxComboBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxComboBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxComboBox::Create at call with 8 argument(s)");
				references->AddReference(validator1, "wxComboBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxComboBox::Create at call with 9 argument(s)");
				references->AddReference(pos1, "wxComboBox::Create at call with 9 argument(s)");
				references->AddReference(size1, "wxComboBox::Create at call with 9 argument(s)");
				references->AddReference(validator1, "wxComboBox::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxComboBox::Dismiss()
   Hides the list box portion of the combo box. */
PHP_METHOD(php_wxComboBox, Dismiss)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Dismiss\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Dismiss\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::Dismiss()\n\n");
				#endif
				((wxComboBox_php*)_this)->Dismiss();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::Dismiss\n");
	}
}
/* }}} */

/* {{{ proto int wxComboBox::FindString(string string, bool caseSensitive)
   Finds an item whose label matches the given string. */
PHP_METHOD(php_wxComboBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::FindString\n");
	}
}
/* }}} */

/* {{{ proto int wxComboBox::GetCount()
   Returns the number of items in the control. */
PHP_METHOD(php_wxComboBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetCount\n");
	}
}
/* }}} */

/* {{{ proto int wxComboBox::GetCurrentSelection()
   Returns the item being selected right now. */
PHP_METHOD(php_wxComboBox, GetCurrentSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetCurrentSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetCurrentSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetCurrentSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetCurrentSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetCurrentSelection\n");
	}
}
/* }}} */

/* {{{ proto int wxComboBox::GetInsertionPoint()
   Same as wxTextEntry::GetInsertionPoint(). */
PHP_METHOD(php_wxComboBox, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetInsertionPoint())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetInsertionPoint());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetInsertionPoint\n");
	}
}
/* }}} */

/* {{{ proto int wxComboBox::GetSelection()
   Returns the index of the selected item or wxNOT_FOUND if no item is selected. */
PHP_METHOD(php_wxComboBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long* from1;
	zval* from1_ref;
	long* to1;
	zval* to1_ref;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (from1, to1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, from1, to1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &from1_ref, &to1_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxComboBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::GetSelection((long*) from1, (long*) to1)\n\n");
				#endif
				((wxComboBox_php*)_this)->GetSelection((long*) from1, (long*) to1);

				size_t elements_returned1_0 = sizeof(from1)/sizeof(*from1);
				array_init(from1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(from1_ref, from1[i]);
				}
				size_t elements_returned1_1 = sizeof(to1)/sizeof(*to1);
				array_init(to1_ref);
				for(size_t i=0; i<elements_returned1_1; i++)
				{
					add_next_index_long(to1_ref, to1[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto string wxComboBox::GetString(int n)
   Returns the label of the item with the given index. */
PHP_METHOD(php_wxComboBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxComboBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetString\n");
	}
}
/* }}} */

/* {{{ proto string wxComboBox::GetStringSelection()
   Gets the text currently selected in the control. */
PHP_METHOD(php_wxComboBox, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxComboBox::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxComboBox_php*)_this)->GetStringSelection();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::GetStringSelection\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboBox::IsListEmpty()
   Returns true if the list of combobox choices is empty. */
PHP_METHOD(php_wxComboBox, IsListEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::IsListEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::IsListEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::IsListEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsListEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::IsListEmpty\n");
	}
}
/* }}} */

/* {{{ proto bool wxComboBox::IsTextEmpty()
   Returns true if the text of the combobox is empty. */
PHP_METHOD(php_wxComboBox, IsTextEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::IsTextEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::IsTextEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxComboBox::IsTextEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsTextEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::IsTextEmpty\n");
	}
}
/* }}} */

/* {{{ proto  wxComboBox::Popup()
   Shows the list box portion of the combo box. */
PHP_METHOD(php_wxComboBox, Popup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::Popup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::Popup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::Popup()\n\n");
				#endif
				((wxComboBox_php*)_this)->Popup();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::Popup\n");
	}
}
/* }}} */

/* {{{ proto  wxComboBox::SetSelection(int n)
   Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. */
PHP_METHOD(php_wxComboBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
	//Parameters for overload 1
	long from1;
	long to1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from1, &to1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from1, &to1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetSelection((int) n0)\n\n");
				#endif
				((wxComboBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetSelection((long) from1, (long) to1)\n\n");
				#endif
				((wxComboBox_php*)_this)->SetSelection((long) from1, (long) to1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxComboBox::SetValue(string text)
   Sets the text for the combobox text field. */
PHP_METHOD(php_wxComboBox, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetValue(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboBox_php*)_this)->SetValue(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxComboBox::wxComboBox(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Constructor, creating and showing a combobox. */
PHP_METHOD(php_wxComboBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 6  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|lOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_5;
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0, "wxComboBox::wxComboBox at call with 6 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(pos0, "wxComboBox::wxComboBox at call with 6 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(size0, "wxComboBox::wxComboBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0, "wxComboBox::wxComboBox at call with 7 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(pos0, "wxComboBox::wxComboBox at call with 7 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(size0, "wxComboBox::wxComboBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7)\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7);

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0, "wxComboBox::wxComboBox at call with 8 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(pos0, "wxComboBox::wxComboBox at call with 8 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(size0, "wxComboBox::wxComboBox at call with 8 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(validator0, "wxComboBox::wxComboBox at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5.Add(wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8));
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxComboBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8));

				((wxComboBox_php*) _this)->references.Initialize();
				((wxComboBox_php*) _this)->references.AddReference(parent0, "wxComboBox::wxComboBox at call with 9 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(pos0, "wxComboBox::wxComboBox at call with 9 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(size0, "wxComboBox::wxComboBox at call with 9 argument(s)");
				((wxComboBox_php*) _this)->references.AddReference(validator0, "wxComboBox::wxComboBox at call with 9 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxComboBox_php();

				((wxComboBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxComboBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxComboBox_php*) _this)->phpObj = getThis();
		
		((wxComboBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxComboBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxComboBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxComboBox::SetString(int n, string text)
   Changes the text of the specified combobox item. */
PHP_METHOD(php_wxComboBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxComboBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxComboBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxComboBox){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxComboBox::SetString((unsigned int) n0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxComboBox_php*)_this)->SetString((unsigned int) n0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxComboBox::SetString\n");
	}
}
/* }}} */

void php_wxControl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxControl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxControl_php* object = static_cast<wxControl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting object by calling destroy\n");
			#endif
			
			object->Destroy();
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxControl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxControl::wxControl()
   Default constructor to allow 2-phase creation. */
PHP_METHOD(php_wxControl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxControl_php();

				((wxControl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 3 argument(s)");
				((wxControl_php*) _this)->references.AddReference(pos1, "wxControl::wxControl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 4 argument(s)");
				((wxControl_php*) _this)->references.AddReference(pos1, "wxControl::wxControl at call with 4 argument(s)");
				((wxControl_php*) _this)->references.AddReference(size1, "wxControl::wxControl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 5 argument(s)");
				((wxControl_php*) _this)->references.AddReference(pos1, "wxControl::wxControl at call with 5 argument(s)");
				((wxControl_php*) _this)->references.AddReference(size1, "wxControl::wxControl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 6 argument(s)");
				((wxControl_php*) _this)->references.AddReference(pos1, "wxControl::wxControl at call with 6 argument(s)");
				((wxControl_php*) _this)->references.AddReference(size1, "wxControl::wxControl at call with 6 argument(s)");
				((wxControl_php*) _this)->references.AddReference(validator1, "wxControl::wxControl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxControl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxControl_php*) _this)->references.Initialize();
				((wxControl_php*) _this)->references.AddReference(parent1, "wxControl::wxControl at call with 7 argument(s)");
				((wxControl_php*) _this)->references.AddReference(pos1, "wxControl::wxControl at call with 7 argument(s)");
				((wxControl_php*) _this)->references.AddReference(size1, "wxControl::wxControl at call with 7 argument(s)");
				((wxControl_php*) _this)->references.AddReference(validator1, "wxControl::wxControl at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxControl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxControl_php*) _this)->phpObj = getThis();
		
		((wxControl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxControl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxControl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto string wxControl::GetLabelText()
   Returns the control's label without mnemonics. */
PHP_METHOD(php_wxControl, GetLabelText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::GetLabelText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::GetLabelText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	char* label1;
	long label_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label1, &label_len1)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, &label_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxControl::GetLabelText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxControl_php*)_this)->GetLabelText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::GetLabelText(wxString(label1, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::GetLabelText(wxString(label1, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::GetLabelText\n");
	}
}
/* }}} */

/* {{{ proto bool wxControl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name) */
PHP_METHOD(php_wxControl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxControl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxControl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxControl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxControl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxControl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxControl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxControl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxControl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxControl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxControl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxControl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxControl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxControl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxControl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxControl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxControl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxControl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxControl::SetLabelMarkup(string markup)
   Sets the controls label to a string using markup. */
PHP_METHOD(php_wxControl, SetLabelMarkup)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabelMarkup\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabelMarkup\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* markup0;
	long markup_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&markup0, &markup_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &markup0, &markup_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxControl::SetLabelMarkup(wxString(markup0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxControl_php*)_this)->SetLabelMarkup(wxString(markup0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::SetLabelMarkup\n");
	}
}
/* }}} */

/* {{{ proto  wxControl::SetLabelText(string text)
   Sets the control's label to exactly the given string. */
PHP_METHOD(php_wxControl, SetLabelText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabelText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabelText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::SetLabelText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxControl_php*)_this)->SetLabelText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::SetLabelText\n");
	}
}
/* }}} */

/* {{{ proto string wxControl::RemoveMnemonics(string str)
   Returns the given str string without mnemonics ("&" characters). */
PHP_METHOD(php_wxControl, RemoveMnemonics)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::RemoveMnemonics\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::RemoveMnemonics\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* str0;
	long str_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&str0, &str_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &str0, &str_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::RemoveMnemonics(wxString(str0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::RemoveMnemonics(wxString(str0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::RemoveMnemonics\n");
	}
}
/* }}} */

/* {{{ proto  wxControl::SetLabel(string label)
   Sets the control's label. */
PHP_METHOD(php_wxControl, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::SetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::SetLabel(wxString(label0, wxConvUTF8))\n\n");
				#endif
				((wxControl_php*)_this)->SetLabel(wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::SetLabel\n");
	}
}
/* }}} */

/* {{{ proto string wxControl::GetLabel()
   Returns the control's label, as it was passed to SetLabel(). */
PHP_METHOD(php_wxControl, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::GetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxControl::GetLabel().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxControl_php*)_this)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::GetLabel\n");
	}
}
/* }}} */

/* {{{ proto string wxControl::EscapeMnemonics(string text)
   Escapes the special mnemonics characters ("&") in the given string. */
PHP_METHOD(php_wxControl, EscapeMnemonics)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::EscapeMnemonics\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::EscapeMnemonics\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxControl::EscapeMnemonics(wxString(text0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = wxControl::EscapeMnemonics(wxString(text0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::EscapeMnemonics\n");
	}
}
/* }}} */

/* {{{ proto  wxControl::Command(wxCommandEvent &event)
   Simulates the effect of the user issuing a command to the item. */
PHP_METHOD(php_wxControl, Command)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxControl::Command\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxControl::Command\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxControl){
				references = &((wxControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStatusBar) && (!reference_type_found)){
				references = &((wxStatusBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnyButton) && (!reference_type_found)){
				references = &((wxAnyButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxButton) && (!reference_type_found)){
				references = &((wxButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapButton) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToggleButton) && (!reference_type_found)){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreeCtrl) && (!reference_type_found)){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBookCtrlBase) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiNotebook) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListbook) && (!reference_type_found)){
				references = &((wxListbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoicebook) && (!reference_type_found)){
				references = &((wxChoicebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxNotebook) && (!reference_type_found)){
				references = &((wxNotebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTreebook) && (!reference_type_found)){
				references = &((wxTreebook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolbook) && (!reference_type_found)){
				references = &((wxToolbook_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAnimationCtrl) && (!reference_type_found)){
				references = &((wxAnimationCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStyledTextCtrl) && (!reference_type_found)){
				references = &((wxStyledTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxScrollBar) && (!reference_type_found)){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticText) && (!reference_type_found)){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticLine) && (!reference_type_found)){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBox) && (!reference_type_found)){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxStaticBitmap) && (!reference_type_found)){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckBox) && (!reference_type_found)){
				references = &((wxCheckBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxAuiToolBar) && (!reference_type_found)){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListCtrl) && (!reference_type_found)){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioButton) && (!reference_type_found)){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSlider) && (!reference_type_found)){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrl) && (!reference_type_found)){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinButton) && (!reference_type_found)){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGauge) && (!reference_type_found)){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHyperlinkCtrl) && (!reference_type_found)){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSpinCtrlDouble) && (!reference_type_found)){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxGenericDirCtrl) && (!reference_type_found)){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCalendarCtrl) && (!reference_type_found)){
				references = &((wxCalendarCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxPickerBase) && (!reference_type_found)){
				references = &((wxPickerBase_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxColourPickerCtrl) && (!reference_type_found)){
				references = &((wxColourPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFontPickerCtrl) && (!reference_type_found)){
				references = &((wxFontPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFilePickerCtrl) && (!reference_type_found)){
				references = &((wxFilePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDirPickerCtrl) && (!reference_type_found)){
				references = &((wxDirPickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTimePickerCtrl) && (!reference_type_found)){
				references = &((wxTimePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxToolBar) && (!reference_type_found)){
				references = &((wxToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDatePickerCtrl) && (!reference_type_found)){
				references = &((wxDatePickerCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCollapsiblePane) && (!reference_type_found)){
				references = &((wxCollapsiblePane_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewCtrl) && (!reference_type_found)){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrl) && (!reference_type_found)){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxFileCtrl) && (!reference_type_found)){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxInfoBar) && (!reference_type_found)){
				references = &((wxInfoBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonControl) && (!reference_type_found)){
				references = &((wxRibbonControl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonBar) && (!reference_type_found)){
				references = &((wxRibbonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonButtonBar) && (!reference_type_found)){
				references = &((wxRibbonButtonBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonGallery) && (!reference_type_found)){
				references = &((wxRibbonGallery_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPage) && (!reference_type_found)){
				references = &((wxRibbonPage_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonPanel) && (!reference_type_found)){
				references = &((wxRibbonPanel_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRibbonToolBar) && (!reference_type_found)){
				references = &((wxRibbonToolBar_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxWebView) && (!reference_type_found)){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* event0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxCommandEvent_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxCommandEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(event0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxControl::Command(*(wxCommandEvent*) object_pointer0_0)\n\n");
				#endif
				((wxControl_php*)_this)->Command(*(wxCommandEvent*) object_pointer0_0);

				references->AddReference(event0, "wxControl::Command at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxControl::Command\n");
	}
}
/* }}} */

void php_wxItemContainerImmutable_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxItemContainerImmutable_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxItemContainerImmutable_php* object = static_cast<wxItemContainerImmutable_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxItemContainerImmutable done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto int wxItemContainerImmutable::FindString(string string, bool caseSensitive)
   Finds an item whose label matches the given string. */
PHP_METHOD(php_wxItemContainerImmutable, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainerImmutable::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_LONG(return_value, ((wxItemContainerImmutable_php*)_this)->FindString(wxString(string0, wxConvUTF8)));
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainerImmutable::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_LONG(return_value, ((wxItemContainerImmutable_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainerImmutable::FindString\n");
	}
}
/* }}} */

/* {{{ proto string wxItemContainerImmutable::GetString(int n)
   Returns the label of the item with the given index. */
wxString wxItemContainerImmutable_php::GetString(unsigned int n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetString", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetString", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxItemContainerImmutable::GetString'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto int wxItemContainerImmutable::GetCount()
   Returns the number of items in the control. */
unsigned int wxItemContainerImmutable_php::GetCount()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetCount", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetCount", 8, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxItemContainerImmutable::GetCount'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (unsigned int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxItemContainerImmutable::GetSelection()
   Returns the index of the selected item or wxNOT_FOUND if no item is selected. */
int wxItemContainerImmutable_php::GetSelection()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelection", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetSelection", 12, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxItemContainerImmutable::GetSelection'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto string wxItemContainerImmutable::GetStringSelection()
   Returns the label of the selected item or an empty string if no item is selected. */
PHP_METHOD(php_wxItemContainerImmutable, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxItemContainerImmutable::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxItemContainer)
				{
					value_to_return0 = ((wxItemContainer_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					value_to_return0 = ((wxControlWithItems_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					value_to_return0 = ((wxListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					value_to_return0 = ((wxCheckListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					value_to_return0 = ((wxRearrangeList_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					value_to_return0 = ((wxChoice_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					value_to_return0 = ((wxSimpleHtmlListBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					value_to_return0 = ((wxRadioBox_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					value_to_return0 = ((wxItemContainerImmutable_php*)_this)->GetStringSelection();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainerImmutable::GetStringSelection\n");
	}
}
/* }}} */

/* {{{ proto array wxItemContainerImmutable::GetStrings()
   Returns the array of the labels of all items in the control. */
PHP_METHOD(php_wxItemContainerImmutable, GetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::GetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::GetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainerImmutable::GetStrings() to return strings array\n\n");
				#endif
				wxArrayString value_to_return0;
				if(parent_rsrc_type == le_wxItemContainer)
				{
					value_to_return0 = ((wxItemContainer_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					value_to_return0 = ((wxControlWithItems_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					value_to_return0 = ((wxListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					value_to_return0 = ((wxCheckListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					value_to_return0 = ((wxRearrangeList_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					value_to_return0 = ((wxChoice_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					value_to_return0 = ((wxSimpleHtmlListBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					value_to_return0 = ((wxRadioBox_php*)_this)->GetStrings();
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					value_to_return0 = ((wxItemContainerImmutable_php*)_this)->GetStrings();
				}
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainerImmutable::GetStrings\n");
	}
}
/* }}} */

/* {{{ proto  wxItemContainerImmutable::SetSelection(int n)
   Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. */
void wxItemContainerImmutable_php::SetSelection(int n)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSelection", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetSelection", 12, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxItemContainerImmutable::SetSelection'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxItemContainerImmutable::SetString(int n, string string)
   Sets the label for the given item. */
void wxItemContainerImmutable_php::SetString(unsigned int n, const wxString& string)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxItemContainerImmutable::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetString", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
	temp_string = (char*)malloc(sizeof(wxChar)*(string.size()+1));
	strcpy(temp_string, (const char *) string.char_str());
	ZVAL_STRING(arguments[1], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetString", 9, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxItemContainerImmutable::SetString'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto bool wxItemContainerImmutable::SetStringSelection(string string)
   Selects the item with the specified string in the control. */
PHP_METHOD(php_wxItemContainerImmutable, SetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainerImmutable::SetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainerImmutable::SetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainerImmutable){
				references = &((wxItemContainerImmutable_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxItemContainer) && (!reference_type_found)){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRadioBox) && (!reference_type_found)){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxItemContainerImmutable::SetStringSelection(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_BOOL(return_value, ((wxItemContainer_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_BOOL(return_value, ((wxControlWithItems_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_BOOL(return_value, ((wxChoice_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxRadioBox)
				{
					ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainerImmutable)
				{
					ZVAL_BOOL(return_value, ((wxItemContainerImmutable_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainerImmutable::SetStringSelection\n");
	}
}
/* }}} */

void php_wxItemContainer_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxItemContainer_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxItemContainer_php* object = static_cast<wxItemContainer_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxItemContainer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto int wxItemContainer::Append(string item)
   Appends item into the control. */
PHP_METHOD(php_wxItemContainer, Append)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Append\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Append\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* items1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&item0, &item_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&items1)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Append(wxString(item0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Append(wxString(item0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(items1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Append(strings_array1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Append(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Append(strings_array1_0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainer::Append\n");
	}
}
/* }}} */

/* {{{ proto  wxItemContainer::Delete(int n)
   Deletes an item from the control. */
PHP_METHOD(php_wxItemContainer, Delete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Delete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Delete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Delete((unsigned int) n0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Delete((unsigned int) n0);
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Delete((unsigned int) n0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainer::Delete\n");
	}
}
/* }}} */

/* {{{ proto int wxItemContainer::Insert(string item, int pos)
   Inserts item into the control. */
PHP_METHOD(php_wxItemContainer, Insert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Insert\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Insert\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* item0;
	long item_len0;
	long pos0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* items1 = 0;
	long pos1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&item0, &item_len0, &pos0)\n");
		#endif
		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &item_len0, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'al' (&items1, &pos1)\n");
		#endif
		char parse_parameters_string[] = "al";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items1, &pos1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Insert(wxString(item0, wxConvUTF8), (unsigned int) pos0));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(items1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxItemContainer::Insert(strings_array1_0, (unsigned int) pos1))\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					ZVAL_LONG(return_value, ((wxControlWithItems_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					ZVAL_LONG(return_value, ((wxListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					ZVAL_LONG(return_value, ((wxCheckListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					ZVAL_LONG(return_value, ((wxRearrangeList_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					ZVAL_LONG(return_value, ((wxChoice_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					ZVAL_LONG(return_value, ((wxSimpleHtmlListBox_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					ZVAL_LONG(return_value, ((wxItemContainer_php*)_this)->Insert(strings_array1_0, (unsigned int) pos1));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainer::Insert\n");
	}
}
/* }}} */

/* {{{ proto  wxItemContainer::Clear()
   Removes all items from the control. */
PHP_METHOD(php_wxItemContainer, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Clear()\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Clear();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainer::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxItemContainer::Set(array items, void clientData)
   Replaces the current control contents with the given items. */
PHP_METHOD(php_wxItemContainer, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxItemContainer::Set\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxItemContainer::Set\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxItemContainer){
				references = &((wxItemContainer_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxControlWithItems) && (!reference_type_found)){
				references = &((wxControlWithItems_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListBox) && (!reference_type_found)){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxChoice) && (!reference_type_found)){
				references = &((wxChoice_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* items0 = 0;
	char* clientData0;
	long clientData_len0;
	zval* clientData0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'as' (&items0, &clientData0, &clientData_len0)\n");
		#endif
		char parse_parameters_string[] = "as";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items0, &clientData0, &clientData_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &clientData0_ref );
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(items0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxItemContainer::Set(strings_array0_0, (void**) 0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxControlWithItems)
				{
					((wxControlWithItems_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxListBox)
				{
					((wxListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxCheckListBox)
				{
					((wxCheckListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxRearrangeList)
				{
					((wxRearrangeList_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxChoice)
				{
					((wxChoice_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxSimpleHtmlListBox)
				{
					((wxSimpleHtmlListBox_php*)_this)->Set(strings_array0_0, (void**) 0);
				}
				else if(parent_rsrc_type == le_wxItemContainer)
				{
					((wxItemContainer_php*)_this)->Set(strings_array0_0, (void**) 0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxItemContainer::Set\n");
	}
}
/* }}} */

void php_wxControlWithItems_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxControlWithItems_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
void php_wxDataViewCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxDataViewCtrl::wxDataViewCtrl(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Constructor. */
PHP_METHOD(php_wxDataViewCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 3 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0, "wxDataViewCtrl::wxDataViewCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 4 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0, "wxDataViewCtrl::wxDataViewCtrl at call with 4 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0, "wxDataViewCtrl::wxDataViewCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 5 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0, "wxDataViewCtrl::wxDataViewCtrl at call with 5 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0, "wxDataViewCtrl::wxDataViewCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5)\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5);

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 6 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0, "wxDataViewCtrl::wxDataViewCtrl at call with 6 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0, "wxDataViewCtrl::wxDataViewCtrl at call with 6 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(validator0, "wxDataViewCtrl::wxDataViewCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxDataViewCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8));

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				((wxDataViewCtrl_php*) _this)->references.AddReference(parent0, "wxDataViewCtrl::wxDataViewCtrl at call with 7 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(pos0, "wxDataViewCtrl::wxDataViewCtrl at call with 7 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(size0, "wxDataViewCtrl::wxDataViewCtrl at call with 7 argument(s)");
				((wxDataViewCtrl_php*) _this)->references.AddReference(validator0, "wxDataViewCtrl::wxDataViewCtrl at call with 7 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewCtrl_php();

				((wxDataViewCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxDataViewCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataViewCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::UnselectAll()
   Unselect all item. */
PHP_METHOD(php_wxDataViewCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::UnselectAll()\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::UnselectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::Unselect(wxDataViewItem item)
   Unselect the given item. */
PHP_METHOD(php_wxDataViewCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Unselect(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Unselect(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::Unselect at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::Unselect\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::SetRowHeight(int rowHeight)
   Sets the row height. */
PHP_METHOD(php_wxDataViewCtrl, SetRowHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetRowHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetRowHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long rowHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&rowHeight0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rowHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::SetRowHeight((int) rowHeight0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->SetRowHeight((int) rowHeight0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::SetRowHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::SetIndent(int indent)
   Sets the indentation. */
PHP_METHOD(php_wxDataViewCtrl, SetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetIndent((int) indent0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetIndent((int) indent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::SetIndent\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::SetExpanderColumn(wxDataViewColumn &col)
   Set which column shall contain the tree-like expanders. */
PHP_METHOD(php_wxDataViewCtrl, SetExpanderColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetExpanderColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetExpanderColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetExpanderColumn((wxDataViewColumn*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetExpanderColumn((wxDataViewColumn*) object_pointer0_0);

				references->AddReference(col0, "wxDataViewCtrl::SetExpanderColumn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::SetExpanderColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::SetCurrentItem(wxDataViewItem item)
   Changes the currently focused item. */
PHP_METHOD(php_wxDataViewCtrl, SetCurrentItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SetCurrentItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SetCurrentItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SetCurrentItem(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SetCurrentItem(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::SetCurrentItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::SetCurrentItem\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::SelectAll()
   Select all items. */
PHP_METHOD(php_wxDataViewCtrl, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::SelectAll()\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->SelectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::Select(wxDataViewItem item)
   Select the given item. */
PHP_METHOD(php_wxDataViewCtrl, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Select(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Select(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::Select at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::Select\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::PrependColumn(wxDataViewColumn &col)
   Prepends a wxDataViewColumn to the control. */
PHP_METHOD(php_wxDataViewCtrl, PrependColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::PrependColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::PrependColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::PrependColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->PrependColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(col0, "wxDataViewCtrl::PrependColumn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::PrependColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::IsSelected(wxDataViewItem item)
   Return true if the item is selected. */
PHP_METHOD(php_wxDataViewCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::IsSelected(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->IsSelected(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0, "wxDataViewCtrl::IsSelected at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::IsExpanded(wxDataViewItem item)
   Return true if the item is expanded. */
PHP_METHOD(php_wxDataViewCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::IsExpanded(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->IsExpanded(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0, "wxDataViewCtrl::IsExpanded at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::IsExpanded\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::InsertColumn(int pos, wxDataViewColumn &col)
   Inserts a wxDataViewColumn to the control. */
PHP_METHOD(php_wxDataViewCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&pos0, &col0)\n");
		#endif
		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1));

				references->AddReference(col0, "wxDataViewCtrl::InsertColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::InsertColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::HitTest(wxPoint point, wxDataViewItem &item, wxDataViewColumn &col)
   Hittest. */
PHP_METHOD(php_wxDataViewCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* point0 = 0;
	void* object_pointer0_0 = 0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	zval* col0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOz' (&point0, php_wxPoint_entry, &item0, php_wxDataViewItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "OOz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point0, php_wxPoint_entry, &item0, php_wxDataViewItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::HitTest(*(wxPoint*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, (wxDataViewColumn*&) object_pointer0_2)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, (wxDataViewColumn*&) object_pointer0_2);

				references->AddReference(point0, "wxDataViewCtrl::HitTest at call with 3 argument(s)");
				references->AddReference(item0, "wxDataViewCtrl::HitTest at call with 3 argument(s)");
				references->AddReference(col0, "wxDataViewCtrl::HitTest at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::HitTest\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::HasSelection()
   Returns true if any items are currently selected. */
PHP_METHOD(php_wxDataViewCtrl, HasSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::HasSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::HasSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::HasSelection())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->HasSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::HasSelection\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::GetSortingColumn()
   Returns the wxDataViewColumn currently responsible for sorting or NULL if none has been selected. */
PHP_METHOD(php_wxDataViewCtrl, GetSortingColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSortingColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSortingColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetSortingColumn() to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return0;
				value_to_return0 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetSortingColumn();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::GetSortingColumn at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetSortingColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendBitmapColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering a bitmap. */
PHP_METHOD(php_wxDataViewCtrl, AppendBitmapColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendBitmapColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendBitmapColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendBitmapColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendBitmapColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendBitmapColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendBitmapColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendBitmapColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendBitmapColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendBitmapColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendBitmapColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::AppendColumn(wxDataViewColumn &col)
   Appends a wxDataViewColumn to the control. */
PHP_METHOD(php_wxDataViewCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&col0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::AppendColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->AppendColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(col0, "wxDataViewCtrl::AppendColumn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendDateColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering a date. */
PHP_METHOD(php_wxDataViewCtrl, AppendDateColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendDateColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendDateColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendDateColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendDateColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendDateColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendDateColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendDateColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendDateColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendDateColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendDateColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendIconTextColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering text with an icon. */
PHP_METHOD(php_wxDataViewCtrl, AppendIconTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendIconTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendIconTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendIconTextColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendIconTextColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendIconTextColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendIconTextColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendIconTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendIconTextColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendIconTextColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendIconTextColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendProgressColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering a progress indicator. */
PHP_METHOD(php_wxDataViewCtrl, AppendProgressColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendProgressColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendProgressColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendProgressColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendProgressColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendProgressColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendProgressColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendProgressColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendProgressColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendProgressColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendProgressColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendTextColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering text. */
PHP_METHOD(php_wxDataViewCtrl, AppendTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendTextColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendTextColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendTextColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendTextColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendTextColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendTextColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendTextColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendTextColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::AppendToggleColumn(string label, int model_column, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a column for rendering a toggle. */
PHP_METHOD(php_wxDataViewCtrl, AppendToggleColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AppendToggleColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AppendToggleColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long model_column0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* label1 = 0;
	void* object_pointer1_0 = 0;
	long model_column1;
	long mode1;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|llll' (&label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "sl|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &model_column0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|llll' (&label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "Ol|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label1, php_wxBitmap_entry, &model_column1, &mode1, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (unsigned int) model_column0, (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 6 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 2 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendToggleColumn at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 3 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendToggleColumn at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 4 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendToggleColumn at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 5 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendToggleColumn at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return6;
				value_to_return6 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->AppendToggleColumn(*(wxBitmap*) object_pointer1_0, (unsigned int) model_column1, (wxDataViewCellMode) mode1, (int) width1, (wxAlignment) align1, (int) flags1);

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::AppendToggleColumn at call with 6 argument(s)");
				}

				references->AddReference(label1, "wxDataViewCtrl::AppendToggleColumn at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AppendToggleColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::AssociateModel(wxDataViewModel &model)
   Associates a wxDataViewModel with the control. */
PHP_METHOD(php_wxDataViewCtrl, AssociateModel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::AssociateModel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::AssociateModel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* model0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&model0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &model0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(model0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(model0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxDataViewListModel && rsrc_type != le_wxDataViewIndexListModel && rsrc_type != le_wxDataViewListStore && rsrc_type != le_wxDataViewVirtualListModel && rsrc_type != le_wxDataViewTreeStore))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(model0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::AssociateModel((wxDataViewModel*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->AssociateModel((wxDataViewModel*) object_pointer0_0));

				references->AddReference(model0, "wxDataViewCtrl::AssociateModel at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::AssociateModel\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::ClearColumns()
   Removes all columns. */
PHP_METHOD(php_wxDataViewCtrl, ClearColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::ClearColumns\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::ClearColumns\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::ClearColumns())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->ClearColumns());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::ClearColumns\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::Collapse(wxDataViewItem item)
   Collapses the item. */
PHP_METHOD(php_wxDataViewCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Collapse(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Collapse(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::Collapse at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::Collapse\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Create the control. */
PHP_METHOD(php_wxDataViewCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxDataViewCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxDataViewCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxDataViewCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxDataViewCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxDataViewCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxDataViewCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxDataViewCtrl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxDataViewCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxDataViewCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxDataViewCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxDataViewCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxDataViewCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::DeleteColumn(wxDataViewColumn &column)
   Deletes given column. */
PHP_METHOD(php_wxDataViewCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&column0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::DeleteColumn((wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->DeleteColumn((wxDataViewColumn*) object_pointer0_0));

				references->AddReference(column0, "wxDataViewCtrl::DeleteColumn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::DeleteColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::EnableDragSource(wxDataFormat format)
   Enable drag operations using the given format. */
PHP_METHOD(php_wxDataViewCtrl, EnableDragSource)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnableDragSource\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnableDragSource\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(format0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::EnableDragSource(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->EnableDragSource(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0, "wxDataViewCtrl::EnableDragSource at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::EnableDragSource\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewCtrl::EnableDropTarget(wxDataFormat format)
   Enable drop operations using the given format. */
PHP_METHOD(php_wxDataViewCtrl, EnableDropTarget)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnableDropTarget\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnableDropTarget\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(format0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewCtrl::EnableDropTarget(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewCtrl_php*)_this)->EnableDropTarget(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0, "wxDataViewCtrl::EnableDropTarget at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::EnableDropTarget\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::EnsureVisible(wxDataViewItem item, wxDataViewColumn column)
   Call this to ensure that the given item is visible. */
PHP_METHOD(php_wxDataViewCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* column0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|z' (&item0, php_wxDataViewItem_entry, &column0)\n");
		#endif
		char parse_parameters_string[] = "O|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::EnsureVisible(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->EnsureVisible(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::EnsureVisible at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::EnsureVisible(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->EnsureVisible(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1);

				references->AddReference(item0, "wxDataViewCtrl::EnsureVisible at call with 2 argument(s)");
				references->AddReference(column0, "wxDataViewCtrl::EnsureVisible at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::EnsureVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::Expand(wxDataViewItem item)
   Expands the item. */
PHP_METHOD(php_wxDataViewCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::Expand(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->Expand(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::Expand at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::Expand\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewCtrl::ExpandAncestors(wxDataViewItem item)
   Expands all ancestors of the item. */
PHP_METHOD(php_wxDataViewCtrl, ExpandAncestors)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::ExpandAncestors\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::ExpandAncestors\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::ExpandAncestors(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewCtrl_php*)_this)->ExpandAncestors(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewCtrl::ExpandAncestors at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::ExpandAncestors\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::GetColumn(int pos)
   Returns pointer to the column. */
PHP_METHOD(php_wxDataViewCtrl, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetColumn((unsigned int) pos0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetColumn((unsigned int) pos0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::GetColumn at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetColumn\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewCtrl::GetColumnCount()
   Returns the number of columns. */
PHP_METHOD(php_wxDataViewCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewCtrl::GetColumnPosition(wxDataViewColumn column)
   Returns the position of the column or -1 if not found in the control. */
PHP_METHOD(php_wxDataViewCtrl, GetColumnPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetColumnPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetColumnPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&column0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetColumnPosition((const wxDataViewColumn*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetColumnPosition((const wxDataViewColumn*) object_pointer0_0));

				references->AddReference(column0, "wxDataViewCtrl::GetColumnPosition at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetColumnPosition\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewCtrl::GetCurrentItem()
   Returns the currently focused item. */
PHP_METHOD(php_wxDataViewCtrl, GetCurrentItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetCurrentItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetCurrentItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetCurrentItem() to return new object\n\n");
				#endif
				wxDataViewItem value_to_return0;
				value_to_return0 = ((wxDataViewCtrl_php*)_this)->GetCurrentItem();
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetCurrentItem\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewCtrl::GetExpanderColumn()
   Returns column containing the expanders. */
PHP_METHOD(php_wxDataViewCtrl, GetExpanderColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetExpanderColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetExpanderColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetExpanderColumn() to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return0;
				value_to_return0 = (wxDataViewColumn_php*) ((wxDataViewCtrl_php*)_this)->GetExpanderColumn();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::GetExpanderColumn at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetExpanderColumn\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewCtrl::GetIndent()
   Returns indentation. */
PHP_METHOD(php_wxDataViewCtrl, GetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetIndent\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxDataViewCtrl::GetItemRect(wxDataViewItem item, wxDataViewColumn col)
   Returns item rectangle. */
PHP_METHOD(php_wxDataViewCtrl, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|z' (&item0, php_wxDataViewItem_entry, &col0)\n");
		#endif
		char parse_parameters_string[] = "O|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetItemRect(*(wxDataViewItem*) object_pointer0_0) to return new object\n\n");
				#endif
				wxRect value_to_return1;
				value_to_return1 = ((wxDataViewCtrl_php*)_this)->GetItemRect(*(wxDataViewItem*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));

				references->AddReference(item0, "wxDataViewCtrl::GetItemRect at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetItemRect(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1) to return new object\n\n");
				#endif
				wxRect value_to_return2;
				value_to_return2 = ((wxDataViewCtrl_php*)_this)->GetItemRect(*(wxDataViewItem*) object_pointer0_0, (const wxDataViewColumn*) object_pointer0_1);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));

				references->AddReference(item0, "wxDataViewCtrl::GetItemRect at call with 2 argument(s)");
				references->AddReference(col0, "wxDataViewCtrl::GetItemRect at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetItemRect\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewModel wxDataViewCtrl::GetModel()
   Returns pointer to the data model associated with the control (if any). */
PHP_METHOD(php_wxDataViewCtrl, GetModel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetModel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetModel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetModel() to return object pointer\n\n");
				#endif
				wxDataViewModel_php* value_to_return0;
				value_to_return0 = (wxDataViewModel_php*) ((wxDataViewCtrl_php*)_this)->GetModel();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewModel_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewModel));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewCtrl::GetModel at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetModel\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewCtrl::GetSelectedItemsCount()
   Returns the number of currently selected items. */
PHP_METHOD(php_wxDataViewCtrl, GetSelectedItemsCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSelectedItemsCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSelectedItemsCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewCtrl::GetSelectedItemsCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewCtrl_php*)_this)->GetSelectedItemsCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetSelectedItemsCount\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewCtrl::GetSelection()
   Returns first selected item or an invalid item if none is selected. */
PHP_METHOD(php_wxDataViewCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewCtrl){
				references = &((wxDataViewCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewListCtrl) && (!reference_type_found)){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewTreeCtrl) && (!reference_type_found)){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewCtrl::GetSelection() to return new object\n\n");
				#endif
				wxDataViewItem value_to_return0;
				value_to_return0 = ((wxDataViewCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewCtrl::GetSelection\n");
	}
}
/* }}} */

void php_wxDataViewListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewListCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxDataViewListCtrl::AppendColumn(wxDataViewColumn &column, string varianttype)
   Appends a column to the control and additionally appends a column to the list store with the type varianttype. */
PHP_METHOD(php_wxDataViewListCtrl, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs' (&column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "zs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->AppendColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0, "wxDataViewListCtrl::AppendColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::AppendColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewListCtrl::AppendIconTextColumn(string label, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends an icon-and-text column to the control and the store. */
PHP_METHOD(php_wxDataViewListCtrl, AppendIconTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendIconTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendIconTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendIconTextColumn at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendIconTextColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendIconTextColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendIconTextColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendIconTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendIconTextColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::AppendIconTextColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewListCtrl::AppendProgressColumn(string label, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a progress column to the control and the store. */
PHP_METHOD(php_wxDataViewListCtrl, AppendProgressColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendProgressColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendProgressColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendProgressColumn at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendProgressColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendProgressColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendProgressColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendProgressColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendProgressColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::AppendProgressColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewListCtrl::AppendTextColumn(string label, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a text column to the control and the store. */
PHP_METHOD(php_wxDataViewListCtrl, AppendTextColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendTextColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendTextColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendTextColumn at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendTextColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendTextColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendTextColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendTextColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendTextColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::AppendTextColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewColumn wxDataViewListCtrl::AppendToggleColumn(string label, wxDataViewCellMode mode, int width, wxAlignment align, int flags)
   Appends a toggle column to the control and the store. */
PHP_METHOD(php_wxDataViewListCtrl, AppendToggleColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::AppendToggleColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::AppendToggleColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	long mode0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llll' (&label0, &label_len0, &mode0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0, &mode0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return1;
				value_to_return1 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendToggleColumn at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return2;
				value_to_return2 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendToggleColumn at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return3;
				value_to_return3 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendToggleColumn at call with 3 argument(s)");
				}


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return4;
				value_to_return4 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendToggleColumn at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0) to return object pointer\n\n");
				#endif
				wxDataViewColumn_php* value_to_return5;
				value_to_return5 = (wxDataViewColumn_php*) ((wxDataViewListCtrl_php*)_this)->AppendToggleColumn(wxString(label0, wxConvUTF8), (wxDataViewCellMode) mode0, (int) width0, (wxAlignment) align0, (int) flags0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewColumn_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxDataViewColumn));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::AppendToggleColumn at call with 5 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::AppendToggleColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewListCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator)
   Creates the control and a wxDataViewListStore as its internal model. */
PHP_METHOD(php_wxDataViewListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxDataViewListCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxDataViewListCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxDataViewListCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxDataViewListCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxDataViewListCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxDataViewListCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxDataViewListCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxDataViewListCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxDataViewListCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxDataViewListCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxDataViewListCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxDataViewListCtrl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxDataViewListCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::DeleteAllItems()
   Delete all items (= all rows). */
PHP_METHOD(php_wxDataViewListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::DeleteAllItems()\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::DeleteAllItems\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::DeleteItem(int row)
   Delete the row at position row. */
PHP_METHOD(php_wxDataViewListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::DeleteItem((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->DeleteItem((unsigned) row0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::DeleteItem\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewListCtrl::GetSelectedRow()
   Returns index of the selected row or wxNOT_FOUND. */
PHP_METHOD(php_wxDataViewListCtrl, GetSelectedRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetSelectedRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetSelectedRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewListCtrl::GetSelectedRow())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewListCtrl_php*)_this)->GetSelectedRow());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::GetSelectedRow\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewListStore wxDataViewListCtrl::GetStore()
   Returns the store. */
PHP_METHOD(php_wxDataViewListCtrl, GetStore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetStore\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetStore\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewListStore_php* value_to_return0;
				value_to_return0 = (wxDataViewListStore_php*) ((wxDataViewListCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewListStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewListStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::GetStore at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewListStore_php* value_to_return0;
				value_to_return0 = (wxDataViewListStore_php*) ((wxDataViewListCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewListStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewListStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewListCtrl::GetStore at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::GetStore\n");
	}
}
/* }}} */

/* {{{ proto string wxDataViewListCtrl::GetTextValue(int row, int col)
   Returns the value from the store. */
PHP_METHOD(php_wxDataViewListCtrl, GetTextValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetTextValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetTextValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataViewListCtrl::GetTextValue((unsigned int) row0, (unsigned int) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxDataViewListCtrl_php*)_this)->GetTextValue((unsigned int) row0, (unsigned int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::GetTextValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewListCtrl::GetToggleValue(int row, int col)
   Returns the value from the store. */
PHP_METHOD(php_wxDataViewListCtrl, GetToggleValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetToggleValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetToggleValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::GetToggleValue((unsigned int) row0, (unsigned int) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->GetToggleValue((unsigned int) row0, (unsigned int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::GetToggleValue\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::GetValue(wxVariant &value, int row, int col)
   Returns the value from the store. */
PHP_METHOD(php_wxDataViewListCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* value0 = 0;
	void* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&value0, php_wxVariant_entry, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(value0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::GetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->GetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0);

				references->AddReference(value0, "wxDataViewListCtrl::GetValue at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::InsertColumn(int pos, wxDataViewColumn &column, string varianttype)
   Inserts a column to the control and additionally inserts a column to the list store with the type varianttype. */
PHP_METHOD(php_wxDataViewListCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	zval* column0 = 0;
	void* object_pointer0_1 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lzs' (&pos0, &column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "lzs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->InsertColumn((unsigned int) pos0, (wxDataViewColumn*) object_pointer0_1, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0, "wxDataViewListCtrl::InsertColumn at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::InsertColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewListCtrl::IsRowSelected(int row)
   Returns true if row is selected. */
PHP_METHOD(php_wxDataViewListCtrl, IsRowSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::IsRowSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::IsRowSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewListCtrl::IsRowSelected((unsigned) row0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewListCtrl_php*)_this)->IsRowSelected((unsigned) row0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::IsRowSelected\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewListCtrl::ItemToRow(wxDataViewItem item)
   Returns the position of given item or wxNOT_FOUND if it's not a valid item. */
PHP_METHOD(php_wxDataViewListCtrl, ItemToRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::ItemToRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::ItemToRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewListCtrl::ItemToRow(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewListCtrl_php*)_this)->ItemToRow(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0, "wxDataViewListCtrl::ItemToRow at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::ItemToRow\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::PrependColumn(wxDataViewColumn &column, string varianttype)
   Prepends a column to the control and additionally prepends a column to the list store with the type varianttype. */
PHP_METHOD(php_wxDataViewListCtrl, PrependColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::PrependColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::PrependColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* column0 = 0;
	void* object_pointer0_0 = 0;
	char* varianttype0;
	long varianttype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs' (&column0, &varianttype0, &varianttype_len0)\n");
		#endif
		char parse_parameters_string[] = "zs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0, &varianttype0, &varianttype_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(column0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(column0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(column0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::PrependColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->PrependColumn((wxDataViewColumn*) object_pointer0_0, wxString(varianttype0, wxConvUTF8));

				references->AddReference(column0, "wxDataViewListCtrl::PrependColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::PrependColumn\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewListCtrl::RowToItem(int row)
   Returns the wxDataViewItem at the given row. */
PHP_METHOD(php_wxDataViewListCtrl, RowToItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::RowToItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::RowToItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::RowToItem((int) row0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return1;
				value_to_return1 = ((wxDataViewListCtrl_php*)_this)->RowToItem((int) row0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::RowToItem\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::SelectRow(int row)
   Selects given row. */
PHP_METHOD(php_wxDataViewListCtrl, SelectRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SelectRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SelectRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SelectRow((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SelectRow((unsigned) row0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::SelectRow\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::SetTextValue(string value, int row, int col)
   Sets the value in the store and update the control. */
PHP_METHOD(php_wxDataViewListCtrl, SetTextValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetTextValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetTextValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sll' (&value0, &value_len0, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "sll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetTextValue(wxString(value0, wxConvUTF8), (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetTextValue(wxString(value0, wxConvUTF8), (unsigned int) row0, (unsigned int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::SetTextValue\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::SetToggleValue(bool value, int row, int col)
   Sets the value in the store and update the control. */
PHP_METHOD(php_wxDataViewListCtrl, SetToggleValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetToggleValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetToggleValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool value0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'bll' (&value0, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "bll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetToggleValue(value0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetToggleValue(value0, (unsigned int) row0, (unsigned int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::SetToggleValue\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::SetValue(wxVariant value, int row, int col)
   Sets the value in the store and update the control. */
PHP_METHOD(php_wxDataViewListCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* value0 = 0;
	void* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&value0, php_wxVariant_entry, &row0, &col0)\n");
		#endif
		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(value0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::SetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->SetValue(*(wxVariant*) object_pointer0_0, (unsigned int) row0, (unsigned int) col0);

				references->AddReference(value0, "wxDataViewListCtrl::SetValue at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::UnselectRow(int row)
   Unselects given row. */
PHP_METHOD(php_wxDataViewListCtrl, UnselectRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::UnselectRow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewListCtrl::UnselectRow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewListCtrl){
				references = &((wxDataViewListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewListCtrl::UnselectRow((unsigned) row0)\n\n");
				#endif
				((wxDataViewListCtrl_php*)_this)->UnselectRow((unsigned) row0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewListCtrl::UnselectRow\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewListCtrl::wxDataViewListCtrl()
   Default ctor. */
PHP_METHOD(php_wxDataViewListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewListCtrl_php();

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 3 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 4 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 4 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 5 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 5 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxDataViewListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxDataViewListCtrl_php*) _this)->references.Initialize();
				((wxDataViewListCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 6 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 6 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(size1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 6 argument(s)");
				((wxDataViewListCtrl_php*) _this)->references.AddReference(validator1, "wxDataViewListCtrl::wxDataViewListCtrl at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxDataViewListCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataViewListCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxDataViewTreeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxDataViewTreeCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::AppendContainer(wxDataViewItem parent, string text, int icon, int expanded, wxClientData &data)
   Appends a container to the given parent. */
PHP_METHOD(php_wxDataViewTreeCtrl, AppendContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::AppendContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::AppendContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendContainer at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendContainer at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendContainer at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->AppendContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendContainer at call with 5 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::AppendContainer at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::AppendContainer\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::AppendItem(wxDataViewItem parent, string text, int icon, wxClientData &data)
   Appends an item to the given parent. */
PHP_METHOD(php_wxDataViewTreeCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|lz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendItem at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->AppendItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::AppendItem at call with 4 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::AppendItem at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::AppendItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewTreeCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator)
   Creates the control and a wxDataViewTreeStore as its internal model. */
PHP_METHOD(php_wxDataViewTreeCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxDataViewTreeCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxDataViewTreeCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxDataViewTreeCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxDataViewTreeCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxDataViewTreeCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxDataViewTreeCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxDataViewTreeCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxDataViewTreeCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxDataViewTreeCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxDataViewTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxDataViewTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxDataViewTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxDataViewTreeCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::DeleteAllItems()
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteAllItems()\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::DeleteAllItems\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::DeleteChildren(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteChildren(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteChildren(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewTreeCtrl::DeleteChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::DeleteChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::DeleteItem(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::DeleteItem(*(wxDataViewItem*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->DeleteItem(*(wxDataViewItem*) object_pointer0_0);

				references->AddReference(item0, "wxDataViewTreeCtrl::DeleteItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::DeleteItem\n");
	}
}
/* }}} */

/* {{{ proto int wxDataViewTreeCtrl::GetChildCount(wxDataViewItem parent)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetChildCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetChildCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetChildCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&parent0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataViewTreeCtrl::GetChildCount(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxDataViewTreeCtrl_php*)_this)->GetChildCount(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(parent0, "wxDataViewTreeCtrl::GetChildCount at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetChildCount\n");
	}
}
/* }}} */

/* {{{ proto wxImageList wxDataViewTreeCtrl::GetImageList()
   Returns the image list. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxDataViewTreeCtrl_php*)_this)->GetImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetImageList at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetImageList\n");
	}
}
/* }}} */

/* {{{ proto wxClientData wxDataViewTreeCtrl::GetItemData(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemData(*(wxDataViewItem*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxClientData_php* value_to_return1;
				value_to_return1 = (wxClientData_php*) ((wxDataViewTreeCtrl_php*)_this)->GetItemData(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxClientData_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxClientData));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetItemData at call with 1 argument(s)");
				}

				references->AddReference(item0, "wxDataViewTreeCtrl::GetItemData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetItemData\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxDataViewTreeCtrl::GetItemExpandedIcon(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemExpandedIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemExpandedIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemExpandedIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxIcon_php* value_to_return1;
				value_to_return1 = (wxIcon_php*) &((wxDataViewTreeCtrl_php*)_this)->GetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxIcon_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxIcon));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetItemExpandedIcon at call with 1 argument(s)");
				}

				references->AddReference(item0, "wxDataViewTreeCtrl::GetItemExpandedIcon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetItemExpandedIcon\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxDataViewTreeCtrl::GetItemIcon(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetItemIcon(*(wxDataViewItem*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxIcon_php* value_to_return1;
				value_to_return1 = (wxIcon_php*) &((wxDataViewTreeCtrl_php*)_this)->GetItemIcon(*(wxDataViewItem*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxIcon_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxIcon));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetItemIcon at call with 1 argument(s)");
				}

				references->AddReference(item0, "wxDataViewTreeCtrl::GetItemIcon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetItemIcon\n");
	}
}
/* }}} */

/* {{{ proto string wxDataViewTreeCtrl::GetItemText(wxDataViewItem item)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataViewTreeCtrl::GetItemText(*(wxDataViewItem*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxDataViewTreeCtrl_php*)_this)->GetItemText(*(wxDataViewItem*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(item0, "wxDataViewTreeCtrl::GetItemText at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetItemText\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::GetNthChild(wxDataViewItem parent, int pos)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetNthChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetNthChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetNthChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&parent0, php_wxDataViewItem_entry, &pos0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &pos0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetNthChild(*(wxDataViewItem*) object_pointer0_0, (unsigned int) pos0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->GetNthChild(*(wxDataViewItem*) object_pointer0_0, (unsigned int) pos0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::GetNthChild at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetNthChild\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewTreeStore wxDataViewTreeCtrl::GetStore()
   Returns the store. */
PHP_METHOD(php_wxDataViewTreeCtrl, GetStore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::GetStore\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::GetStore\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewTreeStore_php* value_to_return0;
				value_to_return0 = (wxDataViewTreeStore_php*) ((wxDataViewTreeCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewTreeStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewTreeStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetStore at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::GetStore() to return object pointer\n\n");
				#endif
				wxDataViewTreeStore_php* value_to_return0;
				value_to_return0 = (wxDataViewTreeStore_php*) ((wxDataViewTreeCtrl_php*)_this)->GetStore();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataViewTreeStore_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxDataViewTreeStore));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxDataViewTreeCtrl::GetStore at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::GetStore\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::InsertContainer(wxDataViewItem parent, wxDataViewItem previous, string text, int icon, int expanded, wxClientData &data)
   Calls the same method from wxDataViewTreeStore but uses an index position in the image list instead of a wxIcon. */
PHP_METHOD(php_wxDataViewTreeCtrl, InsertContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::InsertContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::InsertContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertContainer at call with 3 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertContainer at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertContainer at call with 4 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertContainer at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertContainer at call with 5 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertContainer at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return6;
				value_to_return6 = ((wxDataViewTreeCtrl_php*)_this)->InsertContainer(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertContainer at call with 6 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertContainer at call with 6 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::InsertContainer at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::InsertContainer\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::InsertItem(wxDataViewItem parent, wxDataViewItem previous, string text, int icon, wxClientData &data)
   Calls the same method from wxDataViewTreeStore but uses an index position in the image list instead of a wxIcon. */
PHP_METHOD(php_wxDataViewTreeCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|lz' (&parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &previous0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertItem at call with 3 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertItem at call with 4 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertItem at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->InsertItem(*(wxDataViewItem*) object_pointer0_0, *(wxDataViewItem*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::InsertItem at call with 5 argument(s)");
				references->AddReference(previous0, "wxDataViewTreeCtrl::InsertItem at call with 5 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::InsertItem at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::InsertItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataViewTreeCtrl::IsContainer(wxDataViewItem item)
   Returns true if item is a container. */
PHP_METHOD(php_wxDataViewTreeCtrl, IsContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::IsContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::IsContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxDataViewItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataViewTreeCtrl::IsContainer(*(wxDataViewItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxDataViewTreeCtrl_php*)_this)->IsContainer(*(wxDataViewItem*) object_pointer0_0));

				references->AddReference(item0, "wxDataViewTreeCtrl::IsContainer at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::IsContainer\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::PrependContainer(wxDataViewItem parent, string text, int icon, int expanded, wxClientData &data)
   Calls the same method from wxDataViewTreeStore but uses an index position in the image list instead of a wxIcon. */
PHP_METHOD(php_wxDataViewTreeCtrl, PrependContainer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::PrependContainer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::PrependContainer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	long expanded0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &expanded0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependContainer at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependContainer at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependContainer at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return5;
				value_to_return5 = ((wxDataViewTreeCtrl_php*)_this)->PrependContainer(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (int) expanded0, (wxClientData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependContainer at call with 5 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::PrependContainer at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::PrependContainer\n");
	}
}
/* }}} */

/* {{{ proto wxDataViewItem wxDataViewTreeCtrl::PrependItem(wxDataViewItem parent, string text, int icon, wxClientData &data)
   Calls the same method from wxDataViewTreeStore but uses an index position in the image list instead of a wxIcon. */
PHP_METHOD(php_wxDataViewTreeCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long icon0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|lz' (&parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxDataViewItem_entry, &text0, &text_len0, &icon0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return2;
				value_to_return2 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependItem at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return3;
				value_to_return3 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxDataViewItem value_to_return4;
				value_to_return4 = ((wxDataViewTreeCtrl_php*)_this)->PrependItem(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) icon0, (wxClientData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxDataViewItem_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxDataViewItem));
				object_init_ex(return_value, php_wxDataViewItem_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxDataViewItem));

				references->AddReference(parent0, "wxDataViewTreeCtrl::PrependItem at call with 4 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::PrependItem at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::PrependItem\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::SetImageList(wxImageList &imagelist)
   Sets the image list. */
PHP_METHOD(php_wxDataViewTreeCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imagelist0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imagelist0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imagelist0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imagelist0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imagelist0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imagelist0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imagelist0, "wxDataViewTreeCtrl::SetImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::SetImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::SetItemData(wxDataViewItem item, wxClientData &data)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxDataViewItem_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxTreeItemData))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemData(*(wxDataViewItem*) object_pointer0_0, (wxClientData*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemData(*(wxDataViewItem*) object_pointer0_0, (wxClientData*) object_pointer0_1);

				references->AddReference(item0, "wxDataViewTreeCtrl::SetItemData at call with 2 argument(s)");
				references->AddReference(data0, "wxDataViewTreeCtrl::SetItemData at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::SetItemData\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::SetItemExpandedIcon(wxDataViewItem item, wxIcon icon)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemExpandedIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemExpandedIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemExpandedIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* icon0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(icon0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(icon0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemExpandedIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1);

				references->AddReference(item0, "wxDataViewTreeCtrl::SetItemExpandedIcon at call with 2 argument(s)");
				references->AddReference(icon0, "wxDataViewTreeCtrl::SetItemExpandedIcon at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::SetItemExpandedIcon\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::SetItemIcon(wxDataViewItem item, wxIcon icon)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* icon0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(icon0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(icon0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1)\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemIcon(*(wxDataViewItem*) object_pointer0_0, *(wxIcon*) object_pointer0_1);

				references->AddReference(item0, "wxDataViewTreeCtrl::SetItemIcon at call with 2 argument(s)");
				references->AddReference(icon0, "wxDataViewTreeCtrl::SetItemIcon at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::SetItemIcon\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::SetItemText(wxDataViewItem item, string text)
   Calls the identical method from wxDataViewTreeStore. */
PHP_METHOD(php_wxDataViewTreeCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxDataViewTreeCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxDataViewTreeCtrl){
				references = &((wxDataViewTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxDataViewItem_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxDataViewItem_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataViewTreeCtrl::SetItemText(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxDataViewTreeCtrl_php*)_this)->SetItemText(*(wxDataViewItem*) object_pointer0_0, wxString(text0, wxConvUTF8));

				references->AddReference(item0, "wxDataViewTreeCtrl::SetItemText at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataViewTreeCtrl::SetItemText\n");
	}
}
/* }}} */

/* {{{ proto  wxDataViewTreeCtrl::wxDataViewTreeCtrl()
   Default ctor. */
PHP_METHOD(php_wxDataViewTreeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataViewTreeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlO' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxDataViewTreeCtrl_php();

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 3 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 4 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 4 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 5 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 5 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxDataViewTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxDataViewTreeCtrl_php*) _this)->references.Initialize();
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(parent1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 6 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(pos1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 6 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(size1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 6 argument(s)");
				((wxDataViewTreeCtrl_php*) _this)->references.AddReference(validator1, "wxDataViewTreeCtrl::wxDataViewTreeCtrl at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxDataViewTreeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxDataViewTreeCtrl_php*) _this)->phpObj = getThis();
		
		((wxDataViewTreeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxDataViewTreeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataViewTreeCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxGenericDirCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxGenericDirCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxGenericDirCtrl::CollapsePath(string path)
   Collapse the given path. */
PHP_METHOD(php_wxGenericDirCtrl, CollapsePath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::CollapsePath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::CollapsePath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::CollapsePath(wxString(path0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->CollapsePath(wxString(path0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::CollapsePath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::CollapseTree()
   Collapses the entire tree. */
PHP_METHOD(php_wxGenericDirCtrl, CollapseTree)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::CollapseTree\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::CollapseTree\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::CollapseTree()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->CollapseTree();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::CollapseTree\n");
	}
}
/* }}} */

/* {{{ proto bool wxGenericDirCtrl::Create(wxWindow &parent, int id, string dir, wxPoint pos, wxSize size, int style, string filter, int defaultFilter, string name)
   Create function for two-step construction. */
PHP_METHOD(php_wxGenericDirCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* dir0;
	long dir_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* filter0;
	long filter_len0;
	long defaultFilter0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlsls' (&parent0, &id0, &dir0, &dir_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &filter0, &filter_len0, &defaultFilter0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlsls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &dir0, &dir_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &filter0, &filter_len0, &defaultFilter0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8)));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxGenericDirCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxGenericDirCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8)));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxGenericDirCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxGenericDirCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (const wxWindowID) id0, wxString(dir0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(filter0, wxConvUTF8), (int) defaultFilter0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxGenericDirCtrl::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxGenericDirCtrl::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxGenericDirCtrl::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxGenericDirCtrl::ExpandPath(string path)
   Tries to expand as much of the given path as possible, so that the filename or directory is visible in the tree control. */
PHP_METHOD(php_wxGenericDirCtrl, ExpandPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ExpandPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ExpandPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGenericDirCtrl::ExpandPath(wxString(path0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGenericDirCtrl_php*)_this)->ExpandPath(wxString(path0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::ExpandPath\n");
	}
}
/* }}} */

/* {{{ proto string wxGenericDirCtrl::GetDefaultPath()
   Gets the default path. */
PHP_METHOD(php_wxGenericDirCtrl, GetDefaultPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetDefaultPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetDefaultPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetDefaultPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetDefaultPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetDefaultPath\n");
	}
}
/* }}} */

/* {{{ proto string wxGenericDirCtrl::GetFilePath()
   Gets selected filename path only (else empty string). */
PHP_METHOD(php_wxGenericDirCtrl, GetFilePath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilePath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilePath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetFilePath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetFilePath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetFilePath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::GetFilePaths(array &paths)
   Fills the array paths with the currently selected filepaths. */
PHP_METHOD(php_wxGenericDirCtrl, GetFilePaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilePaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilePaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetFilePaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->GetFilePaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetFilePaths\n");
	}
}
/* }}} */

/* {{{ proto string wxGenericDirCtrl::GetFilter()
   Returns the filter string. */
PHP_METHOD(php_wxGenericDirCtrl, GetFilter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilter\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilter\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetFilter().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetFilter();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetFilter\n");
	}
}
/* }}} */

/* {{{ proto int wxGenericDirCtrl::GetFilterIndex()
   Returns the current filter index (zero-based). */
PHP_METHOD(php_wxGenericDirCtrl, GetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGenericDirCtrl::GetFilterIndex())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGenericDirCtrl_php*)_this)->GetFilterIndex());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetFilterIndex\n");
	}
}
/* }}} */

/* {{{ proto string wxGenericDirCtrl::GetPath()
   Gets the currently-selected directory or filename. */
PHP_METHOD(php_wxGenericDirCtrl, GetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGenericDirCtrl::GetPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetPath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::GetPaths(array &paths)
   Fills the array paths with the selected directories and filenames. */
PHP_METHOD(php_wxGenericDirCtrl, GetPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetPaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->GetPaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetPaths\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxGenericDirCtrl::GetRootId()
   Returns the root id for the tree control. */
PHP_METHOD(php_wxGenericDirCtrl, GetRootId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetRootId\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetRootId\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetRootId() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxGenericDirCtrl_php*)_this)->GetRootId();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetRootId\n");
	}
}
/* }}} */

/* {{{ proto wxTreeCtrl wxGenericDirCtrl::GetTreeCtrl()
   Returns a pointer to the tree control. */
PHP_METHOD(php_wxGenericDirCtrl, GetTreeCtrl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::GetTreeCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::GetTreeCtrl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::GetTreeCtrl() to return object pointer\n\n");
				#endif
				wxTreeCtrl_php* value_to_return0;
				value_to_return0 = (wxTreeCtrl_php*) ((wxGenericDirCtrl_php*)_this)->GetTreeCtrl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTreeCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTreeCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxGenericDirCtrl::GetTreeCtrl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::GetTreeCtrl\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::Init()
   Initializes variables. */
PHP_METHOD(php_wxGenericDirCtrl, Init)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::Init\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::Init\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::Init()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->Init();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::Init\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::ReCreateTree()
   Collapse and expand the tree, thus re-creating it from scratch. */
PHP_METHOD(php_wxGenericDirCtrl, ReCreateTree)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ReCreateTree\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ReCreateTree\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::ReCreateTree()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->ReCreateTree();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::ReCreateTree\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SelectPath(string path, bool select)
   Selects the given item. */
PHP_METHOD(php_wxGenericDirCtrl, SelectPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SelectPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SelectPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&path0, &path_len0, &select0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0, &select0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPath(wxString(path0, wxConvUTF8), select0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPath(wxString(path0, wxConvUTF8), select0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SelectPath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SelectPaths(array paths)
   Selects only the specified paths, clearing any previous selection. */
PHP_METHOD(php_wxGenericDirCtrl, SelectPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SelectPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SelectPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* paths0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SelectPaths(strings_array0_0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SelectPaths(strings_array0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SelectPaths\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SetDefaultPath(string path)
   Sets the default path. */
PHP_METHOD(php_wxGenericDirCtrl, SetDefaultPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetDefaultPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetDefaultPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetDefaultPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetDefaultPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SetDefaultPath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SetFilter(string filter)
   Sets the filter string. */
PHP_METHOD(php_wxGenericDirCtrl, SetFilter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetFilter\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetFilter\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filter0;
	long filter_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filter0, &filter_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filter0, &filter_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetFilter(wxString(filter0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetFilter(wxString(filter0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SetFilter\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SetFilterIndex(int n)
   Sets the current filter index (zero-based). */
PHP_METHOD(php_wxGenericDirCtrl, SetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetFilterIndex((int) n0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetFilterIndex((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SetFilterIndex\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::SetPath(string path)
   Sets the current path. */
PHP_METHOD(php_wxGenericDirCtrl, SetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::SetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::SetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* path0;
	long path_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&path0, &path_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &path0, &path_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::SetPath(wxString(path0, wxConvUTF8))\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->SetPath(wxString(path0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::SetPath\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::ShowHidden(bool show) */
PHP_METHOD(php_wxGenericDirCtrl, ShowHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::ShowHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::ShowHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::ShowHidden(show0)\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->ShowHidden(show0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::ShowHidden\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::UnselectAll()
   Removes the selection from all currently selected items. */
PHP_METHOD(php_wxGenericDirCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGenericDirCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGenericDirCtrl){
				references = &((wxGenericDirCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGenericDirCtrl::UnselectAll()\n\n");
				#endif
				((wxGenericDirCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGenericDirCtrl::UnselectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxGenericDirCtrl::wxGenericDirCtrl()
   Default constructor. */
PHP_METHOD(php_wxGenericDirCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGenericDirCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* dir1;
	long dir_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* filter1;
	long filter_len1;
	long defaultFilter1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlsls' (&parent1, &id1, &dir1, &dir_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &filter1, &filter_len1, &defaultFilter1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlsls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &dir1, &dir_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &filter1, &filter_len1, &defaultFilter1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxGenericDirCtrl_php();

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 4 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 5 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 5 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 6 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 6 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 7 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 7 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1)\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1);

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 8 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 8 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxGenericDirCtrl_php((wxWindow*) object_pointer1_0, (const wxWindowID) id1, wxString(dir1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(filter1, wxConvUTF8), (int) defaultFilter1, wxString(name1, wxConvUTF8));

				((wxGenericDirCtrl_php*) _this)->references.Initialize();
				((wxGenericDirCtrl_php*) _this)->references.AddReference(parent1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 9 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(pos1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 9 argument(s)");
				((wxGenericDirCtrl_php*) _this)->references.AddReference(size1, "wxGenericDirCtrl::wxGenericDirCtrl at call with 9 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxGenericDirCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxGenericDirCtrl_php*) _this)->phpObj = getThis();
		
		((wxGenericDirCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxGenericDirCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGenericDirCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxEditableListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxEditableListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxEditableListBox::GetStrings(array &strings)
   Returns in the given array the current contents of the control (the array will be erased before control's contents are appended). */
PHP_METHOD(php_wxEditableListBox, GetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::GetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::GetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* strings0 = 0;
	zval* strings0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&strings0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &strings0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(strings0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxEditableListBox::GetStrings(strings_array0_0)\n\n");
				#endif
				((wxEditableListBox_php*)_this)->GetStrings(strings_array0_0);

				char* temp_string0_0;
				array_init(strings0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(strings0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxEditableListBox::GetStrings\n");
	}
}
/* }}} */

/* {{{ proto  wxEditableListBox::SetStrings(array strings)
   Replaces current contents with given strings. */
PHP_METHOD(php_wxEditableListBox, SetStrings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::SetStrings\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::SetStrings\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* strings0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&strings0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &strings0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(strings0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxEditableListBox::SetStrings(strings_array0_0)\n\n");
				#endif
				((wxEditableListBox_php*)_this)->SetStrings(strings_array0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxEditableListBox::SetStrings\n");
	}
}
/* }}} */

/* {{{ proto  wxEditableListBox::wxEditableListBox()
   Default ctor. */
PHP_METHOD(php_wxEditableListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxEditableListBox_php();

				((wxEditableListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1, "wxEditableListBox::wxEditableListBox at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1, "wxEditableListBox::wxEditableListBox at call with 4 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(pos1, "wxEditableListBox::wxEditableListBox at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1, "wxEditableListBox::wxEditableListBox at call with 5 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(pos1, "wxEditableListBox::wxEditableListBox at call with 5 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(size1, "wxEditableListBox::wxEditableListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1, "wxEditableListBox::wxEditableListBox at call with 6 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(pos1, "wxEditableListBox::wxEditableListBox at call with 6 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(size1, "wxEditableListBox::wxEditableListBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxEditableListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxEditableListBox_php*) _this)->references.Initialize();
				((wxEditableListBox_php*) _this)->references.AddReference(parent1, "wxEditableListBox::wxEditableListBox at call with 7 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(pos1, "wxEditableListBox::wxEditableListBox at call with 7 argument(s)");
				((wxEditableListBox_php*) _this)->references.AddReference(size1, "wxEditableListBox::wxEditableListBox at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxEditableListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxEditableListBox_php*) _this)->phpObj = getThis();
		
		((wxEditableListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxEditableListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxEditableListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxEditableListBox::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, string name)
   Creates the editable listbox for two-step construction. */
PHP_METHOD(php_wxEditableListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxEditableListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxEditableListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxEditableListBox){
				references = &((wxEditableListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxEditableListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxEditableListBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxEditableListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxEditableListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxEditableListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxEditableListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxEditableListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxEditableListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxEditableListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxEditableListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxEditableListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxEditableListBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxEditableListBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxEditableListBox::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxEditableListBox::Create\n");
	}
}
/* }}} */

void php_wxFileCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxFileCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxFileCtrl::wxFileCtrl() */
PHP_METHOD(php_wxFileCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxFileCtrl_php();

				((wxFileCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxFileCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxFileCtrl_php*) _this)->phpObj = getThis();
		
		((wxFileCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxFileCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxFileCtrl::ShowHidden(bool show)
   Sets whether hidden files and folders are shown or not. */
PHP_METHOD(php_wxFileCtrl, ShowHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::ShowHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::ShowHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::ShowHidden(show0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->ShowHidden(show0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::ShowHidden\n");
	}
}
/* }}} */

/* {{{ proto  wxFileCtrl::SetWildcard(string wildCard)
   Sets the wildcard, which can contain multiple file types, for example: "BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif". */
PHP_METHOD(php_wxFileCtrl, SetWildcard)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetWildcard\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetWildcard\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* wildCard0;
	long wildCard_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&wildCard0, &wildCard_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &wildCard0, &wildCard_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::SetWildcard(wxString(wildCard0, wxConvUTF8))\n\n");
				#endif
				((wxFileCtrl_php*)_this)->SetWildcard(wxString(wildCard0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::SetWildcard\n");
	}
}
/* }}} */

/* {{{ proto  wxFileCtrl::SetFilterIndex(int filterIndex)
   Sets the current filter index, starting from zero. */
PHP_METHOD(php_wxFileCtrl, SetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long filterIndex0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&filterIndex0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filterIndex0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::SetFilterIndex((int) filterIndex0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->SetFilterIndex((int) filterIndex0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::SetFilterIndex\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileCtrl::SetFilename(string filename)
   Selects a certain file. */
PHP_METHOD(php_wxFileCtrl, SetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetFilename\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::SetFilename(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->SetFilename(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::SetFilename\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileCtrl::SetDirectory(string directory)
   Sets(changes) the current directory displayed in the control. */
PHP_METHOD(php_wxFileCtrl, SetDirectory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::SetDirectory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::SetDirectory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* directory0;
	long directory_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&directory0, &directory_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &directory0, &directory_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::SetDirectory(wxString(directory0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->SetDirectory(wxString(directory0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::SetDirectory\n");
	}
}
/* }}} */

/* {{{ proto string wxFileCtrl::GetWildcard()
   Returns the current wildcard. */
PHP_METHOD(php_wxFileCtrl, GetWildcard)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetWildcard\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetWildcard\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetWildcard().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetWildcard();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetWildcard\n");
	}
}
/* }}} */

/* {{{ proto  wxFileCtrl::GetPaths(array &paths)
   Fills the array paths with the full paths of the files chosen. */
PHP_METHOD(php_wxFileCtrl, GetPaths)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetPaths\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetPaths\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* paths0 = 0;
	zval* paths0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&paths0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paths0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(paths0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::GetPaths(strings_array0_0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->GetPaths(strings_array0_0);

				char* temp_string0_0;
				array_init(paths0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(paths0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetPaths\n");
	}
}
/* }}} */

/* {{{ proto string wxFileCtrl::GetPath()
   Returns the full path (directory and filename) of the currently selected file. */
PHP_METHOD(php_wxFileCtrl, GetPath)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetPath\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetPath\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetPath().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetPath();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetPath\n");
	}
}
/* }}} */

/* {{{ proto int wxFileCtrl::GetFilterIndex()
   Returns the zero-based index of the currently selected filter. */
PHP_METHOD(php_wxFileCtrl, GetFilterIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilterIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilterIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFileCtrl::GetFilterIndex())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxFileCtrl_php*)_this)->GetFilterIndex());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetFilterIndex\n");
	}
}
/* }}} */

/* {{{ proto  wxFileCtrl::GetFilenames(array &filenames)
   Fills the array filenames with the filenames only of selected items. */
PHP_METHOD(php_wxFileCtrl, GetFilenames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilenames\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilenames\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* filenames0 = 0;
	zval* filenames0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&filenames0)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filenames0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(filenames0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileCtrl::GetFilenames(strings_array0_0)\n\n");
				#endif
				((wxFileCtrl_php*)_this)->GetFilenames(strings_array0_0);

				char* temp_string0_0;
				array_init(filenames0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(filenames0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetFilenames\n");
	}
}
/* }}} */

/* {{{ proto string wxFileCtrl::GetFilename()
   Returns the currently selected filename. */
PHP_METHOD(php_wxFileCtrl, GetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetFilename\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetFilename().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetFilename();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetFilename\n");
	}
}
/* }}} */

/* {{{ proto string wxFileCtrl::GetDirectory()
   Returns the current directory of the file control (i.e. */
PHP_METHOD(php_wxFileCtrl, GetDirectory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::GetDirectory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::GetDirectory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileCtrl::GetDirectory().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxFileCtrl_php*)_this)->GetDirectory();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::GetDirectory\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileCtrl::Create(wxWindow &parent, int id, string defaultDirectory, string defaultFilename, string wildCard, int style, wxPoint pos, wxSize size, string name)
   Create function for two-step construction. */
PHP_METHOD(php_wxFileCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxFileCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxFileCtrl){
				references = &((wxFileCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* defaultDirectory0;
	long defaultDirectory_len0;
	char* defaultFilename0;
	long defaultFilename_len0;
	char* wildCard0;
	long wildCard_len0;
	long style0;
	zval* pos0 = 0;
	void* object_pointer0_6 = 0;
	zval* size0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|ssslOOs' (&parent0, &id0, &defaultDirectory0, &defaultDirectory_len0, &defaultFilename0, &defaultFilename_len0, &wildCard0, &wildCard_len0, &style0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|ssslOOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &defaultDirectory0, &defaultDirectory_len0, &defaultFilename0, &defaultFilename_len0, &wildCard0, &wildCard_len0, &style0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8)));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8)));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8)));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxFileCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxFileCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxFileCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxFileCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(defaultDirectory0, wxConvUTF8), wxString(defaultFilename0, wxConvUTF8), wxString(wildCard0, wxConvUTF8), (long) style0, *(wxPoint*) object_pointer0_6, *(wxSize*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxFileCtrl::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxFileCtrl::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxFileCtrl::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileCtrl::Create\n");
	}
}
/* }}} */

void php_wxGauge_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxGauge_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxGauge::Create(wxWindow &parent, int id, int range, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the gauge for two-step construction. */
PHP_METHOD(php_wxGauge, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long range0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll|OOlOs' (&parent0, &id0, &range0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &range0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0));

				references->AddReference(parent0, "wxGauge::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxGauge::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxGauge::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxGauge::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxGauge::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxGauge::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxGauge::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxGauge::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxGauge::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxGauge::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxGauge::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxGauge::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxGauge::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) range0, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxGauge::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxGauge::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxGauge::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxGauge::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxGauge::GetBezelFace()
   Returns the width of the 3D bezel face. */
PHP_METHOD(php_wxGauge, GetBezelFace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetBezelFace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetBezelFace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetBezelFace())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetBezelFace());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::GetBezelFace\n");
	}
}
/* }}} */

/* {{{ proto int wxGauge::GetRange()
   Returns the maximum position of the gauge. */
PHP_METHOD(php_wxGauge, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetRange())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetRange());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::GetRange\n");
	}
}
/* }}} */

/* {{{ proto int wxGauge::GetShadowWidth()
   Returns the 3D shadow margin width. */
PHP_METHOD(php_wxGauge, GetShadowWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetShadowWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetShadowWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetShadowWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetShadowWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::GetShadowWidth\n");
	}
}
/* }}} */

/* {{{ proto int wxGauge::GetValue()
   Returns the current position of the gauge. */
PHP_METHOD(php_wxGauge, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGauge::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxGauge_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::GetValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxGauge::IsVertical()
   Returns true if the gauge is vertical (has wxGA_VERTICAL style) and false otherwise. */
PHP_METHOD(php_wxGauge, IsVertical)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::IsVertical\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::IsVertical\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGauge::IsVertical())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxGauge_php*)_this)->IsVertical());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::IsVertical\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::Pulse()
   Switch the gauge to indeterminate mode (if required) and makes the gauge move a bit to indicate the user that some progress has been made. */
PHP_METHOD(php_wxGauge, Pulse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::Pulse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::Pulse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::Pulse()\n\n");
				#endif
				((wxGauge_php*)_this)->Pulse();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::Pulse\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::SetBezelFace(int width)
   Sets the 3D bezel face width. */
PHP_METHOD(php_wxGauge, SetBezelFace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetBezelFace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetBezelFace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetBezelFace((int) width0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetBezelFace((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::SetBezelFace\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::SetRange(int range)
   Sets the range (maximum value) of the gauge. */
PHP_METHOD(php_wxGauge, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long range0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&range0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &range0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetRange((int) range0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetRange((int) range0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::SetRange\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::SetShadowWidth(int width)
   Sets the 3D shadow width. */
PHP_METHOD(php_wxGauge, SetShadowWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetShadowWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetShadowWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetShadowWidth((int) width0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetShadowWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::SetShadowWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::SetValue(int pos)
   Sets the position of the gauge. */
PHP_METHOD(php_wxGauge, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxGauge::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxGauge){
				references = &((wxGauge_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGauge::SetValue((int) pos0)\n\n");
				#endif
				((wxGauge_php*)_this)->SetValue((int) pos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGauge::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGauge::wxGauge()
   Default constructor. */
PHP_METHOD(php_wxGauge, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGauge::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long range1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll|OOlOs' (&parent1, &id1, &range1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &range1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxGauge_php();

				((wxGauge_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 4 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(pos1, "wxGauge::wxGauge at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 5 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(pos1, "wxGauge::wxGauge at call with 5 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(size1, "wxGauge::wxGauge at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 6 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(pos1, "wxGauge::wxGauge at call with 6 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(size1, "wxGauge::wxGauge at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 7 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(pos1, "wxGauge::wxGauge at call with 7 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(size1, "wxGauge::wxGauge at call with 7 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(validator1, "wxGauge::wxGauge at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxGauge_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) range1, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxGauge_php*) _this)->references.Initialize();
				((wxGauge_php*) _this)->references.AddReference(parent1, "wxGauge::wxGauge at call with 8 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(pos1, "wxGauge::wxGauge at call with 8 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(size1, "wxGauge::wxGauge at call with 8 argument(s)");
				((wxGauge_php*) _this)->references.AddReference(validator1, "wxGauge::wxGauge at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxGauge);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxGauge_php*) _this)->phpObj = getThis();
		
		((wxGauge_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxGauge_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGauge::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxHeaderColumn_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHeaderColumn_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHeaderColumn_php* object = static_cast<wxHeaderColumn_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHeaderColumn done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto wxAlignment wxHeaderColumn::GetAlignment()
   Returns the current column alignment. */
wxAlignment wxHeaderColumn_php::GetAlignment()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetAlignment", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetAlignment", 12, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetAlignment'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (wxAlignment) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxBitmap wxHeaderColumn::GetBitmap()
   Returns the bitmap in the header of the column, if any. */
wxBitmap wxHeaderColumn_php::GetBitmap()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetBitmap", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetBitmap", 9, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetBitmap'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxBitmap_php* var = (wxBitmap_php*) return_object;
		var->references.UnInitialize();

		return *(wxBitmap*) return_object;
	
}
/* }}} */

/* {{{ proto int wxHeaderColumn::GetFlags()
   Get the column flags. */
int wxHeaderColumn_php::GetFlags()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetFlags", 8, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetFlags'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxHeaderColumn::GetMinWidth()
   Return the minimal column width. */
int wxHeaderColumn_php::GetMinWidth()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetMinWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetMinWidth", 11, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetMinWidth'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto string wxHeaderColumn::GetTitle()
   Get the text shown in the column header. */
wxString wxHeaderColumn_php::GetTitle()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTitle", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetTitle", 8, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetTitle'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto int wxHeaderColumn::GetWidth()
   Returns the current width of the column. */
int wxHeaderColumn_php::GetWidth()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetWidth", 8, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::GetWidth'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::HasFlag(int flag)
   Return true if the specified flag is currently set for this column. */
PHP_METHOD(php_wxHeaderColumn, HasFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::HasFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::HasFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::HasFlag((int) flag0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->HasFlag((int) flag0));
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->HasFlag((int) flag0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::HasFlag\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsHidden()
   Returns true if the column is currently hidden. */
PHP_METHOD(php_wxHeaderColumn, IsHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsHidden())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsHidden());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsHidden());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::IsHidden\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsReorderable()
   Returns true if the column can be dragged by user to change its order. */
PHP_METHOD(php_wxHeaderColumn, IsReorderable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsReorderable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsReorderable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsReorderable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsReorderable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsReorderable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::IsReorderable\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsResizeable()
   Return true if the column can be resized by the user. */
PHP_METHOD(php_wxHeaderColumn, IsResizeable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsResizeable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsResizeable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsResizeable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsResizeable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsResizeable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::IsResizeable\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsShown()
   Returns true if the column is currently shown. */
PHP_METHOD(php_wxHeaderColumn, IsShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsShown())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsShown());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsShown());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::IsShown\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsSortKey()
   Returns true if the column is currently used for sorting. */
bool wxHeaderColumn_php::IsSortKey()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::IsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "IsSortKey", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "IsSortKey", 9, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::IsSortKey'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsSortOrderAscending()
   Returns true, if the sort order is ascending. */
bool wxHeaderColumn_php::IsSortOrderAscending()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderColumn::IsSortOrderAscending\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "IsSortOrderAscending", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "IsSortOrderAscending", 20, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderColumn::IsSortOrderAscending'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxHeaderColumn::IsSortable()
   Returns true if the column can be clicked by user to sort the control contents by the field in this column. */
PHP_METHOD(php_wxHeaderColumn, IsSortable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumn::IsSortable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumn::IsSortable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumn){
				references = &((wxHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSettableHeaderColumn) && (!reference_type_found)){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumn::IsSortable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxSettableHeaderColumn_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxDataViewColumn)
				{
					ZVAL_BOOL(return_value, ((wxDataViewColumn_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortable());
				}
				else if(parent_rsrc_type == le_wxHeaderColumn)
				{
					ZVAL_BOOL(return_value, ((wxHeaderColumn_php*)_this)->IsSortable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumn::IsSortable\n");
	}
}
/* }}} */

void php_wxSettableHeaderColumn_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSettableHeaderColumn_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxSettableHeaderColumn_php* object = static_cast<wxSettableHeaderColumn_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxSettableHeaderColumn done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxSettableHeaderColumn::UnsetAsSortKey()
   Don't use this column for sorting. */
PHP_METHOD(php_wxSettableHeaderColumn, UnsetAsSortKey)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::UnsetAsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::UnsetAsSortKey\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::UnsetAsSortKey()\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->UnsetAsSortKey();
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->UnsetAsSortKey();
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->UnsetAsSortKey();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::UnsetAsSortKey\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::ToggleSortOrder()
   Inverses the sort order. */
PHP_METHOD(php_wxSettableHeaderColumn, ToggleSortOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ToggleSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ToggleSortOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ToggleSortOrder()\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ToggleSortOrder();
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ToggleSortOrder();
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ToggleSortOrder();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::ToggleSortOrder\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::ToggleFlag(int flag)
   Toggle the specified flag for the column. */
PHP_METHOD(php_wxSettableHeaderColumn, ToggleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ToggleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ToggleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ToggleFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ToggleFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ToggleFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ToggleFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::ToggleFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetWidth(int width)
   Set the column width. */
void wxSettableHeaderColumn_php::SetWidth(int width)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], width);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetWidth", 8, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetWidth'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetTitle(string title)
   Set the text to display in the column header. */
void wxSettableHeaderColumn_php::SetTitle(const wxString& title)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetTitle", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(title.size()+1));
	strcpy(temp_string, (const char *) title.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetTitle", 8, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetTitle'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetSortable(bool sortable)
   Allow clicking the column to sort the control contents by the field in this column. */
PHP_METHOD(php_wxSettableHeaderColumn, SetSortable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetSortable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetSortable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool sortable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&sortable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sortable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetSortable(sortable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetSortable(sortable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetSortable(sortable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetSortable(sortable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::SetSortable\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetSortOrder(bool ascending)
   Sets this column as the sort key for the associated control. */
void wxSettableHeaderColumn_php::SetSortOrder(bool ascending)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSortOrder", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_BOOL(arguments[0], ascending);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetSortOrder", 12, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetSortOrder'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetResizeable(bool resizable)
   Call this to enable or disable interactive resizing of the column by the user. */
PHP_METHOD(php_wxSettableHeaderColumn, SetResizeable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetResizeable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetResizeable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool resizable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&resizable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &resizable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetResizeable(resizable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetResizeable(resizable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetResizeable(resizable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetResizeable(resizable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::SetResizeable\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetReorderable(bool reorderable)
   Allow changing the column order by dragging it. */
PHP_METHOD(php_wxSettableHeaderColumn, SetReorderable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetReorderable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetReorderable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool reorderable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&reorderable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &reorderable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetReorderable(reorderable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetReorderable(reorderable0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetReorderable(reorderable0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetReorderable(reorderable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::SetReorderable\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetMinWidth(int minWidth)
   Set the minimal column width. */
void wxSettableHeaderColumn_php::SetMinWidth(int minWidth)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMinWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], minWidth);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetMinWidth", 11, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetMinWidth'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetHidden(bool hidden)
   Hide or show the column. */
PHP_METHOD(php_wxSettableHeaderColumn, SetHidden)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetHidden\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetHidden\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool hidden0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&hidden0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hidden0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetHidden(hidden0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetHidden(hidden0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetHidden(hidden0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetHidden(hidden0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::SetHidden\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetFlags(int flags)
   Set the column flags. */
void wxSettableHeaderColumn_php::SetFlags(int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetFlags", 8, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetFlags'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetFlag(int flag)
   Set the specified flag for the column. */
PHP_METHOD(php_wxSettableHeaderColumn, SetFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::SetFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::SetFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::SetFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->SetFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->SetFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->SetFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::SetFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetBitmap(wxBitmap bitmap)
   Set the bitmap to be displayed in the column header. */
void wxSettableHeaderColumn_php::SetBitmap(const wxBitmap& bitmap)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetBitmap", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxBitmap_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&bitmap, le_wxBitmap));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetBitmap", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetBitmap'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::SetAlignment(wxAlignment align)
   Set the alignment of the column header. */
void wxSettableHeaderColumn_php::SetAlignment(wxAlignment align)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxSettableHeaderColumn::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetAlignment", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], align);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetAlignment", 12, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxSettableHeaderColumn::SetAlignment'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::ClearFlag(int flag)
   Clear the specified flag for the column. */
PHP_METHOD(php_wxSettableHeaderColumn, ClearFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ClearFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ClearFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ClearFlag((int) flag0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ClearFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ClearFlag((int) flag0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ClearFlag((int) flag0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::ClearFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxSettableHeaderColumn::ChangeFlag(int flag, bool set)
   Set or clear the given flag. */
PHP_METHOD(php_wxSettableHeaderColumn, ChangeFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSettableHeaderColumn::ChangeFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSettableHeaderColumn::ChangeFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSettableHeaderColumn){
				references = &((wxSettableHeaderColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxDataViewColumn) && (!reference_type_found)){
				references = &((wxDataViewColumn_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderColumnSimple) && (!reference_type_found)){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool set0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&flag0, &set0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0, &set0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSettableHeaderColumn::ChangeFlag((int) flag0, set0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxDataViewColumn)
				{
					((wxDataViewColumn_php*)_this)->ChangeFlag((int) flag0, set0);
				}
				else if(parent_rsrc_type == le_wxHeaderColumnSimple)
				{
					((wxHeaderColumnSimple_php*)_this)->ChangeFlag((int) flag0, set0);
				}
				else if(parent_rsrc_type == le_wxSettableHeaderColumn)
				{
					((wxSettableHeaderColumn_php*)_this)->ChangeFlag((int) flag0, set0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSettableHeaderColumn::ChangeFlag\n");
	}
}
/* }}} */

void php_wxHeaderColumnSimple_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHeaderColumnSimple_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHeaderColumnSimple_php* object = static_cast<wxHeaderColumnSimple_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHeaderColumnSimple done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto wxAlignment wxHeaderColumnSimple::GetAlignment()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetAlignment())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetAlignment());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxHeaderColumnSimple::GetBitmap()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::GetBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxHeaderColumnSimple_php*)_this)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderColumnSimple::GetFlags()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetFlags())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetFlags\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderColumnSimple::GetMinWidth()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetMinWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetMinWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetMinWidth\n");
	}
}
/* }}} */

/* {{{ proto string wxHeaderColumnSimple::GetTitle()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetTitle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxHeaderColumnSimple::GetTitle().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxHeaderColumnSimple_php*)_this)->GetTitle();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetTitle\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderColumnSimple::GetWidth()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::GetWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderColumnSimple::GetWidth())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderColumnSimple_php*)_this)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumnSimple::IsSortKey()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, IsSortKey)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::IsSortKey\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::IsSortKey\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumnSimple::IsSortKey())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortKey());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::IsSortKey\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderColumnSimple::IsSortOrderAscending()
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, IsSortOrderAscending)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::IsSortOrderAscending\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::IsSortOrderAscending\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderColumnSimple::IsSortOrderAscending())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderColumnSimple_php*)_this)->IsSortOrderAscending());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::IsSortOrderAscending\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetAlignment(wxAlignment align)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long align0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&align0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &align0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetAlignment((wxAlignment) align0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetAlignment((wxAlignment) align0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetBitmap(wxBitmap bitmap)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxHeaderColumnSimple::SetBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetFlags(int flags)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetFlags((int) flags0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetFlags((int) flags0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetMinWidth(int minWidth)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetMinWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetMinWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetMinWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long minWidth0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&minWidth0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minWidth0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetMinWidth((int) minWidth0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetMinWidth((int) minWidth0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetMinWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetSortOrder(bool ascending)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetSortOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetSortOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetSortOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool ascending0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&ascending0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ascending0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetSortOrder(ascending0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetSortOrder(ascending0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetSortOrder\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetTitle(string title)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetTitle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetTitle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&title0, &title_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetTitle(wxString(title0, wxConvUTF8))\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetTitle(wxString(title0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetTitle\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::SetWidth(int width)
   Trivial implementations of the base class pure virtual functions. */
PHP_METHOD(php_wxHeaderColumnSimple, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderColumnSimple::SetWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderColumnSimple){
				references = &((wxHeaderColumnSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderColumnSimple::SetWidth((int) width0)\n\n");
				#endif
				((wxHeaderColumnSimple_php*)_this)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderColumnSimple::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderColumnSimple::wxHeaderColumnSimple(string title, int width, wxAlignment align, int flags)
   Constructor for a column header. */
PHP_METHOD(php_wxHeaderColumnSimple, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderColumnSimple::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	long width0;
	long align0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	void* object_pointer1_0 = 0;
	long width1;
	long align1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&title0, &title_len0, &width0, &align0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0, &width0, &align0, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|lll' (&bitmap1, php_wxBitmap_entry, &width1, &align1, &flags1)\n");
		#endif
		char parse_parameters_string[] = "O|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &width1, &align1, &flags1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8));

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(wxString(title0, wxConvUTF8), (int) width0, (wxAlignment) align0, (int) flags0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1, "wxHeaderColumnSimple::wxHeaderColumnSimple at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1, "wxHeaderColumnSimple::wxHeaderColumnSimple at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1, "wxHeaderColumnSimple::wxHeaderColumnSimple at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1, (int) flags1)\n");
				#endif
				_this = new wxHeaderColumnSimple_php(*(wxBitmap*) object_pointer1_0, (int) width1, (wxAlignment) align1, (int) flags1);

				((wxHeaderColumnSimple_php*) _this)->references.Initialize();
				((wxHeaderColumnSimple_php*) _this)->references.AddReference(bitmap1, "wxHeaderColumnSimple::wxHeaderColumnSimple at call with 4 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderColumnSimple);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxHeaderColumnSimple_php*) _this)->phpObj = getThis();
		
		((wxHeaderColumnSimple_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderColumnSimple_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxHeaderColumnSimple::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxHeaderCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHeaderCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxHeaderCtrl::AddColumnsItems(wxMenu &menu, int idColumnsBase)
   Helper function appending the checkable items corresponding to all the columns to the given menu. */
PHP_METHOD(php_wxHeaderCtrl, AddColumnsItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::AddColumnsItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::AddColumnsItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* menu0 = 0;
	void* object_pointer0_0 = 0;
	long idColumnsBase0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&menu0, php_wxMenu_entry, &idColumnsBase0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0, php_wxMenu_entry, &idColumnsBase0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(menu0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::AddColumnsItems(*(wxMenu*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->AddColumnsItems(*(wxMenu*) object_pointer0_0);

				references->AddReference(menu0, "wxHeaderCtrl::AddColumnsItems at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::AddColumnsItems(*(wxMenu*) object_pointer0_0, (int) idColumnsBase0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->AddColumnsItems(*(wxMenu*) object_pointer0_0, (int) idColumnsBase0);

				references->AddReference(menu0, "wxHeaderCtrl::AddColumnsItems at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::AddColumnsItems\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderCtrl::Create(wxWindow &parent, int winid, wxPoint pos, wxSize size, int style, string name)
   Create the header control window. */
PHP_METHOD(php_wxHeaderCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long winid0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &winid0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &winid0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxHeaderCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxHeaderCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxHeaderCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxHeaderCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxHeaderCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) winid0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxHeaderCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxHeaderCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxHeaderCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto wxHeaderColumn wxHeaderCtrl::GetColumn(int idx)
   Method to be implemented by the derived classes to return the information for the given column. */
const wxHeaderColumn& wxHeaderCtrl_php::GetColumn(unsigned int idx)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetColumn", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetColumn", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHeaderCtrl::GetColumn'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxHeaderColumn_php* var = (wxHeaderColumn_php*) return_object;
		var->references.UnInitialize();

		return *(wxHeaderColumn*) return_object;
	
}
/* }}} */

/* {{{ proto int wxHeaderCtrl::GetColumnAt(int pos)
   Return the index of the column displayed at the given position. */
PHP_METHOD(php_wxHeaderCtrl, GetColumnAt)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnAt\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnAt\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnAt((unsigned int) pos0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnAt((unsigned int) pos0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::GetColumnAt\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderCtrl::GetColumnCount()
   Return the number of columns in the control. */
PHP_METHOD(php_wxHeaderCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::GetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderCtrl::GetColumnPos(int idx)
   Get the position at which this column is currently displayed. */
PHP_METHOD(php_wxHeaderCtrl, GetColumnPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::GetColumnPos\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::GetColumnPos\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxHeaderCtrl::GetColumnPos((unsigned int) idx0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxHeaderCtrl_php*)_this)->GetColumnPos((unsigned int) idx0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::GetColumnPos\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderCtrl::IsEmpty()
   Return whether the control has any columns. */
PHP_METHOD(php_wxHeaderCtrl, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::IsEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::IsEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->IsEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::IsEmpty\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::OnColumnCountChanging(int count)
   Can be overridden in the derived class to update internal data structures when the number of the columns in the control changes. */
void wxHeaderCtrl_php::OnColumnCountChanging(unsigned int count)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::OnColumnCountChanging\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnColumnCountChanging", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], count);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnColumnCountChanging", 21, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHeaderCtrl::OnColumnCountChanging(count);
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::ResetColumnsOrder()
   Reset the columns order to the natural one. */
PHP_METHOD(php_wxHeaderCtrl, ResetColumnsOrder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ResetColumnsOrder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ResetColumnsOrder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::ResetColumnsOrder()\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->ResetColumnsOrder();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::ResetColumnsOrder\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::SetColumnCount(int count)
   Set the number of columns in the control. */
PHP_METHOD(php_wxHeaderCtrl, SetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::SetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::SetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::SetColumnCount((unsigned int) count0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->SetColumnCount((unsigned int) count0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::SetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderCtrl::ShowColumnsMenu(wxPoint pt, string title)
   Show the popup menu allowing the user to show or hide the columns. */
PHP_METHOD(php_wxHeaderCtrl, ShowColumnsMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ShowColumnsMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ShowColumnsMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	void* object_pointer0_0 = 0;
	char* title0;
	long title_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|s' (&pt0, php_wxPoint_entry, &title0, &title_len0)\n");
		#endif
		char parse_parameters_string[] = "O|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry, &title0, &title_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowColumnsMenu(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowColumnsMenu(*(wxPoint*) object_pointer0_0));

				references->AddReference(pt0, "wxHeaderCtrl::ShowColumnsMenu at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowColumnsMenu(*(wxPoint*) object_pointer0_0, wxString(title0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowColumnsMenu(*(wxPoint*) object_pointer0_0, wxString(title0, wxConvUTF8)));

				references->AddReference(pt0, "wxHeaderCtrl::ShowColumnsMenu at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::ShowColumnsMenu\n");
	}
}
/* }}} */

/* {{{ proto bool wxHeaderCtrl::ShowCustomizeDialog()
   Show the column customization dialog. */
PHP_METHOD(php_wxHeaderCtrl, ShowCustomizeDialog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::ShowCustomizeDialog\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::ShowCustomizeDialog\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHeaderCtrl::ShowCustomizeDialog())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHeaderCtrl_php*)_this)->ShowCustomizeDialog());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::ShowCustomizeDialog\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::UpdateColumn(int idx)
   Update the column with the given index. */
PHP_METHOD(php_wxHeaderCtrl, UpdateColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::UpdateColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrl::UpdateColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrl){
				references = &((wxHeaderCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHeaderCtrlSimple) && (!reference_type_found)){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrl::UpdateColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrl_php*)_this)->UpdateColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrl::UpdateColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::UpdateColumnVisibility(int idx, bool show)
   Method called when the column visibility is changed by the user. */
void wxHeaderCtrl_php::UpdateColumnVisibility(unsigned int idx, bool show)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::UpdateColumnVisibility\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "UpdateColumnVisibility", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
	ZVAL_BOOL(arguments[1], show);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "UpdateColumnVisibility", 22, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHeaderCtrl::UpdateColumnVisibility(idx, show);
}
/* }}} */

/* {{{ proto bool wxHeaderCtrl::UpdateColumnWidthToFit(int idx, int widthTitle)
   Method which may be implemented by the derived classes to allow double clicking the column separator to resize the column to fit its contents. */
bool wxHeaderCtrl_php::UpdateColumnWidthToFit(unsigned int idx, int widthTitle)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrl::UpdateColumnWidthToFit\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "UpdateColumnWidthToFit", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
	ZVAL_LONG(arguments[1], widthTitle);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "UpdateColumnWidthToFit", 22, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHeaderCtrl::UpdateColumnWidthToFit(idx, widthTitle);
}
/* }}} */

/* {{{ proto  wxHeaderCtrl::wxHeaderCtrl()
   Default constructor not creating the underlying window. */
PHP_METHOD(php_wxHeaderCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long winid1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHeaderCtrl_php();

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 3 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1, "wxHeaderCtrl::wxHeaderCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 4 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1, "wxHeaderCtrl::wxHeaderCtrl at call with 4 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1, "wxHeaderCtrl::wxHeaderCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 5 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1, "wxHeaderCtrl::wxHeaderCtrl at call with 5 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1, "wxHeaderCtrl::wxHeaderCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHeaderCtrl_php*) _this)->references.Initialize();
				((wxHeaderCtrl_php*) _this)->references.AddReference(parent1, "wxHeaderCtrl::wxHeaderCtrl at call with 6 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(pos1, "wxHeaderCtrl::wxHeaderCtrl at call with 6 argument(s)");
				((wxHeaderCtrl_php*) _this)->references.AddReference(size1, "wxHeaderCtrl::wxHeaderCtrl at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxHeaderCtrl_php*) _this)->phpObj = getThis();
		
		((wxHeaderCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxHeaderCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxHeaderCtrlSimple_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHeaderCtrlSimple_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxHeaderCtrlSimple::AppendColumn(wxHeaderColumnSimple col)
   Append the column to the end of the control. */
PHP_METHOD(php_wxHeaderCtrlSimple, AppendColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::AppendColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::AppendColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxHeaderColumnSimple_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxHeaderColumnSimple_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::AppendColumn(*(wxHeaderColumnSimple*) object_pointer0_0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->AppendColumn(*(wxHeaderColumnSimple*) object_pointer0_0);

				references->AddReference(col0, "wxHeaderCtrlSimple::AppendColumn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::AppendColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::DeleteColumn(int idx)
   Delete the column at the given position. */
PHP_METHOD(php_wxHeaderCtrlSimple, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::DeleteColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->DeleteColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::DeleteColumn\n");
	}
}
/* }}} */

/* {{{ proto int wxHeaderCtrlSimple::GetBestFittingWidth(int idx)
   This function can be overridden in the classes deriving from this control instead of overriding UpdateColumnWidthToFit(). */
int wxHeaderCtrlSimple_php::GetBestFittingWidth(unsigned int idx)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHeaderCtrlSimple::GetBestFittingWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetBestFittingWidth", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], idx);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetBestFittingWidth", 19, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHeaderCtrlSimple::GetBestFittingWidth(idx);
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::HideColumn(int idx)
   Hide the column with the given index. */
PHP_METHOD(php_wxHeaderCtrlSimple, HideColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::HideColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::HideColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::HideColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->HideColumn((unsigned int) idx0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::HideColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::InsertColumn(wxHeaderColumnSimple col, int idx)
   Insert the column at the given position. */
PHP_METHOD(php_wxHeaderCtrlSimple, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&col0, php_wxHeaderColumnSimple_entry, &idx0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxHeaderColumnSimple_entry, &idx0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::InsertColumn(*(wxHeaderColumnSimple*) object_pointer0_0, (unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->InsertColumn(*(wxHeaderColumnSimple*) object_pointer0_0, (unsigned int) idx0);

				references->AddReference(col0, "wxHeaderCtrlSimple::InsertColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::InsertColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::RemoveSortIndicator()
   Remove the sort indicator from the column being used as sort key. */
PHP_METHOD(php_wxHeaderCtrlSimple, RemoveSortIndicator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::RemoveSortIndicator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::RemoveSortIndicator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::RemoveSortIndicator()\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->RemoveSortIndicator();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::RemoveSortIndicator\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::ShowColumn(int idx, bool show)
   Show or hide the column. */
PHP_METHOD(php_wxHeaderCtrlSimple, ShowColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::ShowColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::ShowColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&idx0, &show0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowColumn((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowColumn((unsigned int) idx0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowColumn((unsigned int) idx0, show0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowColumn((unsigned int) idx0, show0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::ShowColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::ShowSortIndicator(int idx, bool sortOrder)
   Update the column sort indicator. */
PHP_METHOD(php_wxHeaderCtrlSimple, ShowSortIndicator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::ShowSortIndicator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHeaderCtrlSimple::ShowSortIndicator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHeaderCtrlSimple){
				references = &((wxHeaderCtrlSimple_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool sortOrder0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&idx0, &sortOrder0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0, &sortOrder0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowSortIndicator((unsigned int) idx0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowSortIndicator((unsigned int) idx0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHeaderCtrlSimple::ShowSortIndicator((unsigned int) idx0, sortOrder0)\n\n");
				#endif
				((wxHeaderCtrlSimple_php*)_this)->ShowSortIndicator((unsigned int) idx0, sortOrder0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHeaderCtrlSimple::ShowSortIndicator\n");
	}
}
/* }}} */

/* {{{ proto  wxHeaderCtrlSimple::wxHeaderCtrlSimple()
   Default constructor not creating the underlying window. */
PHP_METHOD(php_wxHeaderCtrlSimple, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHeaderCtrlSimple::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long winid1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &winid1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHeaderCtrlSimple_php();

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 3 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 4 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 4 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 5 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 5 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHeaderCtrlSimple_php((wxWindow*) object_pointer1_0, (wxWindowID) winid1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHeaderCtrlSimple_php*) _this)->references.Initialize();
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(parent1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 6 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(pos1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 6 argument(s)");
				((wxHeaderCtrlSimple_php*) _this)->references.AddReference(size1, "wxHeaderCtrlSimple::wxHeaderCtrlSimple at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHeaderCtrlSimple);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxHeaderCtrlSimple_php*) _this)->phpObj = getThis();
		
		((wxHeaderCtrlSimple_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHeaderCtrlSimple_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxHeaderCtrlSimple::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxHtmlListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxHtmlListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxHtmlListBox_php* object = static_cast<wxHtmlListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxHtmlListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxHtmlListBox::wxHtmlListBox()
   Default constructor, you must call Create() later. */
PHP_METHOD(php_wxHtmlListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHtmlListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxHtmlListBox_php();

				((wxHtmlListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 3 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1, "wxHtmlListBox::wxHtmlListBox at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 4 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1, "wxHtmlListBox::wxHtmlListBox at call with 4 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(size1, "wxHtmlListBox::wxHtmlListBox at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 5 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1, "wxHtmlListBox::wxHtmlListBox at call with 5 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(size1, "wxHtmlListBox::wxHtmlListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxHtmlListBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxHtmlListBox_php*) _this)->references.Initialize();
				((wxHtmlListBox_php*) _this)->references.AddReference(parent1, "wxHtmlListBox::wxHtmlListBox at call with 6 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(pos1, "wxHtmlListBox::wxHtmlListBox at call with 6 argument(s)");
				((wxHtmlListBox_php*) _this)->references.AddReference(size1, "wxHtmlListBox::wxHtmlListBox at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHtmlListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxHtmlListBox_php*) _this)->phpObj = getThis();
		
		((wxHtmlListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHtmlListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxHtmlListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxHtmlListBox::OnLinkClicked(int n, wxHtmlLinkInfo link)
   Called when the user clicks on hypertext link. */
void wxHtmlListBox_php::OnLinkClicked(size_t n, const wxHtmlLinkInfo& link)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnLinkClicked\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnLinkClicked", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
	object_init_ex(arguments[1], php_wxHtmlLinkInfo_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&link, le_wxHtmlLinkInfo));
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnLinkClicked", 13, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxHtmlListBox::OnLinkClicked(n, link);
}
/* }}} */

/* {{{ proto wxColour wxHtmlListBox::GetSelectedTextColour(wxColour colFg)
   This virtual function may be overridden to customize the appearance of the selected cells. */
wxColour wxHtmlListBox_php::GetSelectedTextColour(const wxColour& colFg)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::GetSelectedTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelectedTextColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colFg, le_wxColour));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetSelectedTextColour", 21, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxColour_php* var = (wxColour_php*) return_object;
		var->references.UnInitialize();

		return *(wxColour*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::GetSelectedTextColour(colFg);
}
/* }}} */

/* {{{ proto wxColour wxHtmlListBox::GetSelectedTextBgColour(wxColour colBg)
   This virtual function may be overridden to change the appearance of the background of the selected cells in the same way as GetSelectedTextColour(). */
wxColour wxHtmlListBox_php::GetSelectedTextBgColour(const wxColour& colBg)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::GetSelectedTextBgColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetSelectedTextBgColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colBg, le_wxColour));
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetSelectedTextBgColour", 23, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxColour_php* var = (wxColour_php*) return_object;
		var->references.UnInitialize();

		return *(wxColour*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::GetSelectedTextBgColour(colBg);
}
/* }}} */

/* {{{ proto string wxHtmlListBox::OnGetItemMarkup(int n)
   This function may be overridden to decorate HTML returned by OnGetItem(). */
wxString wxHtmlListBox_php::OnGetItemMarkup(size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnGetItemMarkup\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemMarkup", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItemMarkup", 15, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxHtmlListBox::OnGetItemMarkup(n);
}
/* }}} */

/* {{{ proto string wxHtmlListBox::OnGetItem(int n)
   This method must be implemented in the derived class and should return the body (i.e. */
wxString wxHtmlListBox_php::OnGetItem(size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHtmlListBox::OnGetItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItem", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHtmlListBox::OnGetItem'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto bool wxHtmlListBox::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Creates the control and optionally sets the initial number of items in it (it may also be set or changed later with wxVListBox::SetItemCount). */
PHP_METHOD(php_wxHtmlListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHtmlListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHtmlListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHtmlListBox){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxHtmlListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxHtmlListBox::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxHtmlListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxHtmlListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxHtmlListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHtmlListBox::Create\n");
	}
}
/* }}} */

void php_wxSimpleHtmlListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSimpleHtmlListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxSimpleHtmlListBox_php* object = static_cast<wxSimpleHtmlListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxSimpleHtmlListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto bool wxSimpleHtmlListBox::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int n, string choices, int style, wxValidator validator, string name)
   Creates the HTML listbox for two-step construction. */
PHP_METHOD(php_wxSimpleHtmlListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSimpleHtmlListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSimpleHtmlListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSimpleHtmlListBox){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long n0;
	zval* choices0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_7 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	zval* choices1 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_7 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_5 = 1;
		HashTable* arr_hash0_5;
		if(arguments_received > 5)
		{
			arr_hash0_5 = Z_ARRVAL_P(choices0);
			array_count0_5 = zend_hash_num_elements(arr_hash0_5);
		}
		wxString* strings_array0_5 = new wxString[array_count0_5];
		bool strings_continue0_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");
				delete[] strings_array0_5;

				return;
				break;
			}
			case 7:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				delete[] strings_array0_5;

				return;
				break;
			}
			case 8:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				delete[] strings_array0_5;
				references->AddReference(validator0, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index0_5 = 0;
				zval** temp_array_value0_5 = 0;
				while(strings_continue0_5)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_5, (void**)&temp_array_value0_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_5);
						strings_array0_5[array_index0_5] = wxString(Z_STRVAL_PP(temp_array_value0_5), wxConvUTF8);
						array_index0_5++;
					}
					else
					{
						strings_continue0_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (int) n0, strings_array0_5, (long) style0, *(wxValidator*) object_pointer0_7, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSimpleHtmlListBox::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxSimpleHtmlListBox::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxSimpleHtmlListBox::Create at call with 9 argument(s)");
				delete[] strings_array0_5;
				references->AddReference(validator0, "wxSimpleHtmlListBox::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_4;
		bool strings_continue1_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4));

				references->AddReference(parent1, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(pos1, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");
				references->AddReference(size1, "wxSimpleHtmlListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1));

				references->AddReference(parent1, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxSimpleHtmlListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6));

				references->AddReference(parent1, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");
				references->AddReference(validator1, "wxSimpleHtmlListBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index1_4 = 0;
				zval** temp_array_value1_4 = 0;
				while(strings_continue1_4)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_4, (void**)&temp_array_value1_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_4);
						strings_array1_4.Add(wxString(Z_STRVAL_PP(temp_array_value1_4), wxConvUTF8));
						array_index1_4++;
					}
					else
					{
						strings_continue1_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSimpleHtmlListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSimpleHtmlListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, strings_array1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");
				references->AddReference(validator1, "wxSimpleHtmlListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSimpleHtmlListBox::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxSimpleHtmlListBox::wxSimpleHtmlListBox(wxWindow &parent, int id, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Constructor, creating and showing the HTML list box. */
PHP_METHOD(php_wxSimpleHtmlListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSimpleHtmlListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 5 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 5 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 6 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 6 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 7 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 7 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 7 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(validator0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxSimpleHtmlListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(parent0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 8 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(pos0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 8 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(size0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 8 argument(s)");
				((wxSimpleHtmlListBox_php*) _this)->references.AddReference(validator0, "wxSimpleHtmlListBox::wxSimpleHtmlListBox at call with 8 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSimpleHtmlListBox_php();

				((wxSimpleHtmlListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSimpleHtmlListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSimpleHtmlListBox_php*) _this)->phpObj = getThis();
		
		((wxSimpleHtmlListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSimpleHtmlListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSimpleHtmlListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxHyperlinkCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxHyperlinkCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxHyperlinkCtrl::Create(wxWindow &parent, int id, string label, string url, wxPoint pos, wxSize size, int style, string name)
   Creates the hyperlink control. */
PHP_METHOD(php_wxHyperlinkCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_4 = 0;
	zval* size0 = 0;
	void* object_pointer0_5 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlss|OOls' (&parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlss|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8)));

				references->AddReference(parent0, "wxHyperlinkCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4));

				references->AddReference(parent0, "wxHyperlinkCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxHyperlinkCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5));

				references->AddReference(parent0, "wxHyperlinkCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxHyperlinkCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxHyperlinkCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0));

				references->AddReference(parent0, "wxHyperlinkCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxHyperlinkCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxHyperlinkCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxHyperlinkCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxHyperlinkCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxHyperlinkCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxHyperlinkCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxHyperlinkCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxHyperlinkCtrl::GetHoverColour()
   Returns the colour used to print the label of the hyperlink when the mouse is over the control. */
PHP_METHOD(php_wxHyperlinkCtrl, GetHoverColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetHoverColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetHoverColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetHoverColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetHoverColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::GetHoverColour\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxHyperlinkCtrl::GetNormalColour()
   Returns the colour used to print the label when the link has never been clicked before (i.e. */
PHP_METHOD(php_wxHyperlinkCtrl, GetNormalColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetNormalColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetNormalColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetNormalColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetNormalColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::GetNormalColour\n");
	}
}
/* }}} */

/* {{{ proto string wxHyperlinkCtrl::GetURL()
   Returns the URL associated with the hyperlink. */
PHP_METHOD(php_wxHyperlinkCtrl, GetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxHyperlinkCtrl::GetURL().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetURL();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::GetURL\n");
	}
}
/* }}} */

/* {{{ proto bool wxHyperlinkCtrl::GetVisited()
   Returns true if the hyperlink has already been clicked by the user at least one time. */
bool wxHyperlinkCtrl_php::GetVisited()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHyperlinkCtrl::GetVisited\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetVisited", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetVisited", 10, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHyperlinkCtrl::GetVisited'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxColour wxHyperlinkCtrl::GetVisitedColour()
   Returns the colour used to print the label when the mouse is not over the control and the link has already been clicked before (i.e. */
PHP_METHOD(php_wxHyperlinkCtrl, GetVisitedColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::GetVisitedColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::GetVisitedColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::GetVisitedColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxHyperlinkCtrl_php*)_this)->GetVisitedColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::GetVisitedColour\n");
	}
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::SetHoverColour(wxColour colour)
   Sets the colour used to print the label of the hyperlink when the mouse is over the control. */
PHP_METHOD(php_wxHyperlinkCtrl, SetHoverColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetHoverColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetHoverColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetHoverColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetHoverColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxHyperlinkCtrl::SetHoverColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::SetHoverColour\n");
	}
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::SetNormalColour(wxColour colour)
   Sets the colour used to print the label when the link has never been clicked before (i.e. */
PHP_METHOD(php_wxHyperlinkCtrl, SetNormalColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetNormalColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetNormalColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetNormalColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetNormalColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxHyperlinkCtrl::SetNormalColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::SetNormalColour\n");
	}
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::SetURL(string url)
   Sets the URL associated with the hyperlink. */
PHP_METHOD(php_wxHyperlinkCtrl, SetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetURL(wxString(url0, wxConvUTF8))\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetURL(wxString(url0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::SetURL\n");
	}
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::SetVisited(bool visited)
   Marks the hyperlink as visited (see wxHyperlinkCtrl::SetVisitedColour). */
void wxHyperlinkCtrl_php::SetVisited(bool visited)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxHyperlinkCtrl::SetVisited\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetVisited", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_BOOL(arguments[0], visited);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetVisited", 10, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxHyperlinkCtrl::SetVisited'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::SetVisitedColour(wxColour colour)
   Sets the colour used to print the label when the mouse is not over the control and the link has already been clicked before (i.e. */
PHP_METHOD(php_wxHyperlinkCtrl, SetVisitedColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::SetVisitedColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxHyperlinkCtrl::SetVisitedColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxHyperlinkCtrl){
				references = &((wxHyperlinkCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(colour0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxHyperlinkCtrl::SetVisitedColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxHyperlinkCtrl_php*)_this)->SetVisitedColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxHyperlinkCtrl::SetVisitedColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxHyperlinkCtrl::SetVisitedColour\n");
	}
}
/* }}} */

/* {{{ proto  wxHyperlinkCtrl::wxHyperlinkCtrl(wxWindow &parent, int id, string label, string url, wxPoint pos, wxSize size, int style, string name)
   Constructor. */
PHP_METHOD(php_wxHyperlinkCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxHyperlinkCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_4 = 0;
	zval* size0 = 0;
	void* object_pointer0_5 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlss|OOls' (&parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlss|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8))\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8));

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 5 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 6 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 6 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0)\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0);

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 7 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 7 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxHyperlinkCtrl_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_4, *(wxSize*) object_pointer0_5, (long) style0, wxString(name0, wxConvUTF8));

				((wxHyperlinkCtrl_php*) _this)->references.Initialize();
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(parent0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 8 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(pos0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 8 argument(s)");
				((wxHyperlinkCtrl_php*) _this)->references.AddReference(size0, "wxHyperlinkCtrl::wxHyperlinkCtrl at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxHyperlinkCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxHyperlinkCtrl_php*) _this)->phpObj = getThis();
		
		((wxHyperlinkCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxHyperlinkCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxHyperlinkCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxListBox::wxListBox(wxWindow &parent, int id, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Constructor, creating and showing a list box. */
PHP_METHOD(php_wxListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0, "wxListBox::wxListBox at call with 5 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(pos0, "wxListBox::wxListBox at call with 5 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(size0, "wxListBox::wxListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0, "wxListBox::wxListBox at call with 6 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(pos0, "wxListBox::wxListBox at call with 6 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(size0, "wxListBox::wxListBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6)\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6);

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0, "wxListBox::wxListBox at call with 7 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(pos0, "wxListBox::wxListBox at call with 7 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(size0, "wxListBox::wxListBox at call with 7 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(validator0, "wxListBox::wxListBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8));

				((wxListBox_php*) _this)->references.Initialize();
				((wxListBox_php*) _this)->references.AddReference(parent0, "wxListBox::wxListBox at call with 8 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(pos0, "wxListBox::wxListBox at call with 8 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(size0, "wxListBox::wxListBox at call with 8 argument(s)");
				((wxListBox_php*) _this)->references.AddReference(validator0, "wxListBox::wxListBox at call with 8 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxListBox_php();

				((wxListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxListBox_php*) _this)->phpObj = getThis();
		
		((wxListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxListBox::SetStringSelection(string string)
   Selects the item with the specified string in the control. */
PHP_METHOD(php_wxListBox, SetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* s1;
	long s_len1;
	bool select1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sb' (&s1, &s_len1, &select1)\n");
		#endif
		char parse_parameters_string[] = "sb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s1, &s_len1, &select1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::SetStringSelection(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->SetStringSelection(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::SetStringSelection(wxString(s1, wxConvUTF8), select1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->SetStringSelection(wxString(s1, wxConvUTF8), select1));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::SetStringSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::SetString(int n, string string)
   Sets the label for the given item. */
PHP_METHOD(php_wxListBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxListBox_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::SetString\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::SetSelection(int n)
   Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. */
PHP_METHOD(php_wxListBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetSelection((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::SetFirstItem(string string)
   Set the specified item to be the first visible item. */
PHP_METHOD(php_wxListBox, SetFirstItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::SetFirstItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::SetFirstItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	long n1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n1)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetFirstItem(wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxListBox_php*)_this)->SetFirstItem(wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::SetFirstItem((int) n1)\n\n");
				#endif
				((wxListBox_php*)_this)->SetFirstItem((int) n1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::SetFirstItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxListBox::IsSorted()
   Return true if the listbox has wxLB_SORT style. */
PHP_METHOD(php_wxListBox, IsSorted)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::IsSorted\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::IsSorted\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::IsSorted())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->IsSorted());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::IsSorted\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::InsertItems(array items, int pos)
   Insert the given number of strings before the specified position. */
PHP_METHOD(php_wxListBox, InsertItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::InsertItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::InsertItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* items0 = 0;
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'al' (&items0, &pos0)\n");
		#endif
		char parse_parameters_string[] = "al";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &items0, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 2:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(items0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::InsertItems(strings_array0_0, (unsigned int) pos0)\n\n");
				#endif
				((wxListBox_php*)_this)->InsertItems(strings_array0_0, (unsigned int) pos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::InsertItems\n");
	}
}
/* }}} */

/* {{{ proto bool wxListBox::IsSelected(int n)
   Determines whether an item is selected. */
PHP_METHOD(php_wxListBox, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::IsSelected((int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->IsSelected((int) n0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto int wxListBox::HitTest(int x, int y)
   This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. */
PHP_METHOD(php_wxListBox, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* point1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&point1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::HitTest((int) x0, (int) y0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->HitTest((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::HitTest(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->HitTest(*(wxPoint*) object_pointer1_0));

				references->AddReference(point1, "wxListBox::HitTest at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::HitTest\n");
	}
}
/* }}} */

/* {{{ proto string wxListBox::GetString(int n)
   Returns the label of the item with the given index. */
PHP_METHOD(php_wxListBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxListBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::GetString\n");
	}
}
/* }}} */

/* {{{ proto int wxListBox::GetSelection()
   Returns the index of the selected item or wxNOT_FOUND if no item is selected. */
PHP_METHOD(php_wxListBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto int wxListBox::GetCount()
   Returns the number of items in the control. */
PHP_METHOD(php_wxListBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::GetCount\n");
	}
}
/* }}} */

/* {{{ proto int wxListBox::FindString(string string, bool caseSensitive)
   Finds an item whose label matches the given string. */
PHP_METHOD(php_wxListBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool caseSensitive0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &caseSensitive0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &caseSensitive0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListBox::FindString(wxString(string0, wxConvUTF8), caseSensitive0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), caseSensitive0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::FindString\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::EnsureVisible(int n)
   Ensure that the item with the given index is currently shown. */
PHP_METHOD(php_wxListBox, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::EnsureVisible((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->EnsureVisible((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::EnsureVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxListBox::Deselect(int n)
   Deselects an item in the list box. */
PHP_METHOD(php_wxListBox, Deselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::Deselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::Deselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListBox::Deselect((int) n0)\n\n");
				#endif
				((wxListBox_php*)_this)->Deselect((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::Deselect\n");
	}
}
/* }}} */

/* {{{ proto bool wxListBox::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, array choices, int style, wxValidator validator, string name)
   Creates the listbox for two-step construction. */
PHP_METHOD(php_wxListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListBox){
				references = &((wxListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxCheckListBox) && (!reference_type_found)){
				references = &((wxCheckListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxRearrangeList) && (!reference_type_found)){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	zval* choices0 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long n1;
	zval* choices1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_7 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlOOa|lOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlOOa|lOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &choices0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 9)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlalOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlalOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &n1, &choices1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_4;
		bool strings_continue0_4 = true;

		switch(arguments_received)
		{
			case 5:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4));

				references->AddReference(parent0, "wxListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0));

				references->AddReference(parent0, "wxListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxListBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxListBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxListBox::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxListBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index0_4 = 0;
				zval** temp_array_value0_4 = 0;
				while(strings_continue0_4)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_4, (void**)&temp_array_value0_4) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_4);
						strings_array0_4.Add(wxString(Z_STRVAL_PP(temp_array_value0_4), wxConvUTF8));
						array_index0_4++;
					}
					else
					{
						strings_continue0_4 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, strings_array0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxListBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxListBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxListBox::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		int array_count1_5 = 1;
		HashTable* arr_hash1_5;
		if(arguments_received > 5)
		{
			arr_hash1_5 = Z_ARRVAL_P(choices1);
			array_count1_5 = zend_hash_num_elements(arr_hash1_5);
		}
		wxString* strings_array1_5 = new wxString[array_count1_5];
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1));

				references->AddReference(parent1, "wxListBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2));

				references->AddReference(parent1, "wxListBox::Create at call with 3 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3));

				references->AddReference(parent1, "wxListBox::Create at call with 4 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 4 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1));

				references->AddReference(parent1, "wxListBox::Create at call with 5 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 5 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5));

				references->AddReference(parent1, "wxListBox::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 6 argument(s)");
				delete[] strings_array1_5;

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1));

				references->AddReference(parent1, "wxListBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 7 argument(s)");
				delete[] strings_array1_5;

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7));

				references->AddReference(parent1, "wxListBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 8 argument(s)");
				delete[] strings_array1_5;
				references->AddReference(validator1, "wxListBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5[array_index1_5] = wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8);
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (int) n1, strings_array1_5, (long) style1, *(wxValidator*) object_pointer1_7, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxListBox::Create at call with 9 argument(s)");
				references->AddReference(pos1, "wxListBox::Create at call with 9 argument(s)");
				references->AddReference(size1, "wxListBox::Create at call with 9 argument(s)");
				delete[] strings_array1_5;
				references->AddReference(validator1, "wxListBox::Create at call with 9 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListBox::Create\n");
	}
}
/* }}} */

void php_wxListCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxListCtrl::wxListCtrl()
   Default constructor. */
PHP_METHOD(php_wxListCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxListCtrl_php();

				((wxListCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 3 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(pos1, "wxListCtrl::wxListCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 4 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(pos1, "wxListCtrl::wxListCtrl at call with 4 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(size1, "wxListCtrl::wxListCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 5 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(pos1, "wxListCtrl::wxListCtrl at call with 5 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(size1, "wxListCtrl::wxListCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 6 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(pos1, "wxListCtrl::wxListCtrl at call with 6 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(size1, "wxListCtrl::wxListCtrl at call with 6 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(validator1, "wxListCtrl::wxListCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxListCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxListCtrl_php*) _this)->references.Initialize();
				((wxListCtrl_php*) _this)->references.AddReference(parent1, "wxListCtrl::wxListCtrl at call with 7 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(pos1, "wxListCtrl::wxListCtrl at call with 7 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(size1, "wxListCtrl::wxListCtrl at call with 7 argument(s)");
				((wxListCtrl_php*) _this)->references.AddReference(validator1, "wxListCtrl::wxListCtrl at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxListCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxListCtrl_php*) _this)->phpObj = getThis();
		
		((wxListCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxListCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxListCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxListCtrl::SetWindowStyleFlag(int style)
   Sets the whole window style, deleting all items. */
PHP_METHOD(php_wxListCtrl, SetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetWindowStyleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetWindowStyleFlag((long) style0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetWindowStyleFlag((long) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetWindowStyleFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetTextColour(wxColour col)
   Sets the text colour of the list control. */
PHP_METHOD(php_wxListCtrl, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(col0, "wxListCtrl::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetSingleStyle(int style, bool add)
   Adds or removes a single window style. */
PHP_METHOD(php_wxListCtrl, SetSingleStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetSingleStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetSingleStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool add0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&style0, &add0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, &add0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetSingleStyle((long) style0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetSingleStyle((long) style0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetSingleStyle((long) style0, add0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetSingleStyle((long) style0, add0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetSingleStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetItemTextColour(int item, wxColour col)
   Sets the colour for this item. */
PHP_METHOD(php_wxListCtrl, SetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemTextColour((long) item0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemTextColour((long) item0, *(wxColour*) object_pointer0_1);

				references->AddReference(col0, "wxListCtrl::SetItemTextColour at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetItemText(int item, string text)
   Sets the item text for this item. */
PHP_METHOD(php_wxListCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemText((long) item0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemText((long) item0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemText\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetItemState(int item, int state, int stateMask)
   Sets the item state. */
PHP_METHOD(php_wxListCtrl, SetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long state0;
	long stateMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&item0, &state0, &stateMask0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &state0, &stateMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemState((long) item0, (long) state0, (long) stateMask0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemState((long) item0, (long) state0, (long) stateMask0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemState\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetItemPosition(int item, wxPoint pos)
   Sets the position of the item, in icon or small icon view. */
PHP_METHOD(php_wxListCtrl, SetItemPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* pos0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &pos0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemPosition((long) item0, *(wxPoint*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemPosition((long) item0, *(wxPoint*) object_pointer0_1));

				references->AddReference(pos0, "wxListCtrl::SetItemPosition at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetItemFont(int item, wxFont font)
   Sets the item's font. */
PHP_METHOD(php_wxListCtrl, SetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* font0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemFont((long) item0, *(wxFont*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemFont((long) item0, *(wxFont*) object_pointer0_1);

				references->AddReference(font0, "wxListCtrl::SetItemFont at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetItemData(int item, int data)
   Associates application-defined data with this item. */
PHP_METHOD(php_wxListCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long data0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&item0, &data0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &data0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemData((long) item0, (long) data0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemData((long) item0, (long) data0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemData\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetItemCount(int count)
   This method can only be used with virtual list controls. */
PHP_METHOD(php_wxListCtrl, SetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemCount((long) count0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemCount((long) count0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetItemColumnImage(int item, int column, int image)
   Sets the image associated with the item. */
PHP_METHOD(php_wxListCtrl, SetItemColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long column0;
	long image0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&item0, &column0, &image0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &column0, &image0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItemColumnImage((long) item0, (long) column0, (int) image0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItemColumnImage((long) item0, (long) column0, (int) image0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemColumnImage\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetItemBackgroundColour(int item, wxColour col)
   Sets the background colour for this item. */
PHP_METHOD(php_wxListCtrl, SetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetItemBackgroundColour((long) item0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetItemBackgroundColour((long) item0, *(wxColour*) object_pointer0_1);

				references->AddReference(col0, "wxListCtrl::SetItemBackgroundColour at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItemBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::SetItem(int index, int column, string label, int imageId)
   Sets an item string field at a particular column. */
PHP_METHOD(php_wxListCtrl, SetItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	long column0;
	char* label0;
	long label_len0;
	long imageId0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* info1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls|l' (&index0, &column0, &label0, &label_len0, &imageId0)\n");
		#endif
		char parse_parameters_string[] = "lls|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0, &column0, &label0, &label_len0, &imageId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info1, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info1, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8)));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8), (int) imageId0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->SetItem((long) index0, (int) column0, wxString(label0, wxConvUTF8), (int) imageId0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetItem(*(wxListItem*) object_pointer1_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetItem(*(wxListItem*) object_pointer1_0));

				references->AddReference(info1, "wxListCtrl::SetItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetItem\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::SetImageList(wxImageList &imageList, int which)
   Sets the image list associated with the control. */
PHP_METHOD(php_wxListCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&imageList0, &which0)\n");
		#endif
		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::SetImageList((wxImageList*) object_pointer0_0, (int) which0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0, (int) which0);

				references->AddReference(imageList0, "wxListCtrl::SetImageList at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetImageList\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetColumnWidth(int col, int width)
   Sets the column width. */
PHP_METHOD(php_wxListCtrl, SetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetColumnWidth((int) col0, (int) width0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetColumnWidth((int) col0, (int) width0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetColumnWidth\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetColumn(int col, wxListItem &item)
   Sets information about this column. */
PHP_METHOD(php_wxListCtrl, SetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &item0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &item0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetColumn((int) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetColumn((int) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(item0, "wxListCtrl::SetColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::SetBackgroundColour(wxColour col)
   Sets the background colour. */
PHP_METHOD(php_wxListCtrl, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::SetBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::SetBackgroundColour(*(wxColour*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->SetBackgroundColour(*(wxColour*) object_pointer0_0));

				references->AddReference(col0, "wxListCtrl::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::ScrollList(int dx, int dy)
   Scrolls the list control. */
PHP_METHOD(php_wxListCtrl, ScrollList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::ScrollList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::ScrollList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dx0;
	long dy0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx0, &dy0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx0, &dy0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::ScrollList((int) dx0, (int) dy0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->ScrollList((int) dx0, (int) dy0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::ScrollList\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::RefreshItems(int itemFrom, int itemTo)
   Redraws the items between itemFrom and itemTo. */
PHP_METHOD(php_wxListCtrl, RefreshItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::RefreshItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::RefreshItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long itemFrom0;
	long itemTo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&itemFrom0, &itemTo0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &itemFrom0, &itemTo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::RefreshItems((long) itemFrom0, (long) itemTo0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->RefreshItems((long) itemFrom0, (long) itemTo0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::RefreshItems\n");
	}
}
/* }}} */

/* {{{ proto string wxListCtrl::OnGetItemText(int item, int column)
   This function must be overridden in the derived class for a control with wxLC_VIRTUAL style. */
wxString wxListCtrl_php::OnGetItemText(long item, long column)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemText", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
	ZVAL_LONG(arguments[1], column);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItemText", 13, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemText(item, column);
}
/* }}} */

/* {{{ proto  wxListCtrl::RefreshItem(int item)
   Redraws the given item. */
PHP_METHOD(php_wxListCtrl, RefreshItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::RefreshItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::RefreshItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::RefreshItem((long) item0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->RefreshItem((long) item0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::RefreshItem\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::OnGetItemImage(int item)
   This function must be overridden in the derived class for a control with wxLC_VIRTUAL style having an "image list" (see SetImageList(); if the control doesn't have an image list, it is not necessary to override it). */
int wxListCtrl_php::OnGetItemImage(long item)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemImage", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItemImage", 14, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemImage(item);
}
/* }}} */

/* {{{ proto int wxListCtrl::OnGetItemColumnImage(int item, int column)
   Override this function in the derived class for a control with wxLC_VIRTUAL and wxLC_REPORT styles in order to specify the image index for the given line and column. */
int wxListCtrl_php::OnGetItemColumnImage(long item, long column)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemColumnImage", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
	ZVAL_LONG(arguments[1], column);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItemColumnImage", 20, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemColumnImage(item, column);
}
/* }}} */

/* {{{ proto wxListItemAttr wxListCtrl::OnGetItemAttr(int item)
   This function may be overridden in the derived class for a control with wxLC_VIRTUAL style. */
wxListItemAttr* wxListCtrl_php::OnGetItemAttr(long item)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxListCtrl::OnGetItemAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnGetItemAttr", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], item);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnGetItemAttr", 13, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}

		//Threat it as a normal object on the calling function and not a php user space intiialized one
		wxListItemAttr_php* var = (wxListItemAttr_php*) return_object;
		var->references.UnInitialize();

		return (wxListItemAttr*) return_object;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxListCtrl::OnGetItemAttr(item);
}
/* }}} */

/* {{{ proto int wxListCtrl::InsertItem(wxListItem &info)
   Inserts an item, returning the index of the new item if successful, -1 otherwise. */
PHP_METHOD(php_wxListCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* info0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long index1;
	char* label1;
	long label_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	long index2;
	long imageIndex2;
	bool overload2_called = false;
	//Parameters for overload 3
	long index3;
	char* label3;
	long label_len3;
	long imageIndex3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&index1, &label1, &label_len1)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index1, &label1, &label_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&index2, &imageIndex2)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index2, &imageIndex2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsl' (&index3, &label3, &label_len3, &imageIndex3)\n");
		#endif
		char parse_parameters_string[] = "lsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index3, &label3, &label_len3, &imageIndex3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem(*(wxListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem(*(wxListItem*) object_pointer0_0));

				references->AddReference(info0, "wxListCtrl::InsertItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index1, wxString(label1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index1, wxString(label1, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index2, (int) imageIndex2))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index2, (int) imageIndex2));


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertItem((long) index3, wxString(label3, wxConvUTF8), (int) imageIndex3))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertItem((long) index3, wxString(label3, wxConvUTF8), (int) imageIndex3));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::InsertItem\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxListCtrl::GetViewRect()
   Returns the rectangle taken by all items in the control. */
PHP_METHOD(php_wxListCtrl, GetViewRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetViewRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetViewRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetViewRect() to return new object\n\n");
				#endif
				wxRect value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetViewRect();
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetViewRect\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetTopItem()
   Gets the index of the topmost visible item when in list or report view. */
PHP_METHOD(php_wxListCtrl, GetTopItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetTopItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetTopItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetTopItem())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetTopItem());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetTopItem\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListCtrl::GetTextColour()
   Gets the text colour of the list control. */
PHP_METHOD(php_wxListCtrl, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetTextColour() to return new object\n\n");
				#endif
				wxColour value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetTextColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::GetSubItemRect(int item, int subItem, wxRect &rect, int code)
   Returns the rectangle representing the size and position, in physical coordinates, of the given subitem, i.e. */
PHP_METHOD(php_wxListCtrl, GetSubItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetSubItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetSubItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long subItem0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	long code0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO|l' (&item0, &subItem0, &rect0, php_wxRect_entry, &code0)\n");
		#endif
		char parse_parameters_string[] = "llO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &subItem0, &rect0, php_wxRect_entry, &code0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2));

				references->AddReference(rect0, "wxListCtrl::GetSubItemRect at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2, (int) code0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetSubItemRect((long) item0, (long) subItem0, *(wxRect*) object_pointer0_2, (int) code0));

				references->AddReference(rect0, "wxListCtrl::GetSubItemRect at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetSubItemRect\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetSelectedItemCount()
   Returns the number of selected items in the list control. */
PHP_METHOD(php_wxListCtrl, GetSelectedItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetSelectedItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetSelectedItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetSelectedItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetSelectedItemCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetSelectedItemCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::Arrange(int flag)
   Arranges the items in icon or small icon view. */
PHP_METHOD(php_wxListCtrl, Arrange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::Arrange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::Arrange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Arrange())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Arrange());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Arrange((int) flag0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Arrange((int) flag0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::Arrange\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::AssignImageList(wxImageList &imageList, int which)
   Sets the image list associated with the control and takes ownership of it (i.e. */
PHP_METHOD(php_wxListCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&imageList0, &which0)\n");
		#endif
		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::AssignImageList((wxImageList*) object_pointer0_0, (int) which0)\n\n");
				#endif
				((wxListCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0, (int) which0);

				references->AddReference(imageList0, "wxListCtrl::AssignImageList at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::AssignImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxListCtrl::ClearAll()
   Deletes all items and all columns. */
PHP_METHOD(php_wxListCtrl, ClearAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::ClearAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::ClearAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::ClearAll()\n\n");
				#endif
				((wxListCtrl_php*)_this)->ClearAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::ClearAll\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the list control. */
PHP_METHOD(php_wxListCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxListCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxListCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxListCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxListCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxListCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxListCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxListCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxListCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxListCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxListCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxListCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxListCtrl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxListCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxListCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxListCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxListCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxListCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::DeleteAllItems()
   Deletes all items in the list control. */
PHP_METHOD(php_wxListCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteAllItems())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteAllItems());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::DeleteAllItems\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::DeleteColumn(int col)
   Deletes a column. */
PHP_METHOD(php_wxListCtrl, DeleteColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteColumn((int) col0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteColumn((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::DeleteColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::DeleteItem(int item)
   Deletes the specified item. */
PHP_METHOD(php_wxListCtrl, DeleteItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::DeleteItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::DeleteItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::DeleteItem((long) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->DeleteItem((long) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::DeleteItem\n");
	}
}
/* }}} */

/* {{{ proto wxTextCtrl wxListCtrl::EditLabel(int item, wxClassInfo &textControlClass)
   Starts editing the label of the given item. */
PHP_METHOD(php_wxListCtrl, EditLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::EditLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::EditLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* textControlClass0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|z' (&item0, &textControlClass0)\n");
		#endif
		char parse_parameters_string[] = "l|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &textControlClass0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(textControlClass0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(textControlClass0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(textControlClass0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::EditLabel((long) item0) to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return1;
				value_to_return1 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->EditLabel((long) item0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxListCtrl::EditLabel at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::EditLabel((long) item0, (wxClassInfo*) object_pointer0_1) to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return2;
				value_to_return2 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->EditLabel((long) item0, (wxClassInfo*) object_pointer0_1);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxListCtrl::EditLabel at call with 2 argument(s)");
				}

				references->AddReference(textControlClass0, "wxListCtrl::EditLabel at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::EditLabel\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::EnsureVisible(int item)
   Ensures this item is visible. */
PHP_METHOD(php_wxListCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::EnsureVisible((long) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->EnsureVisible((long) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::EnsureVisible\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::FindItem(int start, string str, bool partial)
   Find an item whose label matches this string, starting from start or the beginning if start is -1. */
PHP_METHOD(php_wxListCtrl, FindItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::FindItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::FindItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long start0;
	char* str0;
	long str_len0;
	bool partial0;
	bool overload0_called = false;
	//Parameters for overload 1
	long start1;
	long data1;
	bool overload1_called = false;
	//Parameters for overload 2
	long start2;
	zval* pt2 = 0;
	void* object_pointer2_1 = 0;
	long direction2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls|b' (&start0, &str0, &str_len0, &partial0)\n");
		#endif
		char parse_parameters_string[] = "ls|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start0, &str0, &str_len0, &partial0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&start1, &data1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start1, &data1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lOl' (&start2, &pt2, php_wxPoint_entry, &direction2)\n");
		#endif
		char parse_parameters_string[] = "lOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start2, &pt2, php_wxPoint_entry, &direction2 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pt2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start0, wxString(str0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start0, wxString(str0, wxConvUTF8)));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start0, wxString(str0, wxConvUTF8), partial0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start0, wxString(str0, wxConvUTF8), partial0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start1, (wxUIntPtr) data1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start1, (wxUIntPtr) data1));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::FindItem((long) start2, *(wxPoint*) object_pointer2_1, (int) direction2))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->FindItem((long) start2, *(wxPoint*) object_pointer2_1, (int) direction2));

				references->AddReference(pt2, "wxListCtrl::FindItem at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::FindItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::GetColumn(int col, wxListItem &item)
   Gets information about this column. */
PHP_METHOD(php_wxListCtrl, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	zval* item0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &item0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &item0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetColumn((int) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetColumn((int) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(item0, "wxListCtrl::GetColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetColumn\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetColumnCount()
   Returns the number of columns. */
PHP_METHOD(php_wxListCtrl, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetColumnWidth(int col)
   Gets the column width (report view only). */
PHP_METHOD(php_wxListCtrl, GetColumnWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetColumnWidth\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetColumnWidth\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetColumnWidth((int) col0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetColumnWidth((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetColumnWidth\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetCountPerPage()
   Gets the number of items that can fit vertically in the visible area of the list control (list or report view) or the total number of items in the list control (icon or small icon view). */
PHP_METHOD(php_wxListCtrl, GetCountPerPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetCountPerPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetCountPerPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetCountPerPage())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetCountPerPage());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetCountPerPage\n");
	}
}
/* }}} */

/* {{{ proto wxTextCtrl wxListCtrl::GetEditControl()
   Returns the edit control being currently used to edit a label. */
PHP_METHOD(php_wxListCtrl, GetEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetEditControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetEditControl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxListCtrl_php*)_this)->GetEditControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxListCtrl::GetEditControl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetEditControl\n");
	}
}
/* }}} */

/* {{{ proto wxImageList wxListCtrl::GetImageList(int which)
   Returns the specified image list. */
PHP_METHOD(php_wxListCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&which0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &which0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetImageList((int) which0) to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return1;
				value_to_return1 = (wxImageList_php*) ((wxListCtrl_php*)_this)->GetImageList((int) which0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxListCtrl::GetImageList at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetImageList\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::GetItem(wxListItem &info)
   Gets information about the item. */
PHP_METHOD(php_wxListCtrl, GetItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* info0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItem(*(wxListItem*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItem(*(wxListItem*) object_pointer0_0));

				references->AddReference(info0, "wxListCtrl::GetItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItem\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListCtrl::GetItemBackgroundColour(int item)
   Returns the colour for this item. */
PHP_METHOD(php_wxListCtrl, GetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemBackgroundColour((long) item0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemBackgroundColour((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetItemCount()
   Returns the number of items in the list control. */
PHP_METHOD(php_wxListCtrl, GetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetItemCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemCount\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxListCtrl::GetItemFont(int item)
   Returns the item's font. */
PHP_METHOD(php_wxListCtrl, GetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemFont((long) item0) to return new object\n\n");
				#endif
				wxFont value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemFont((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxFont));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::GetItemPosition(int item, wxPoint &pos)
   Returns the position of the item, in icon or small icon view. */
PHP_METHOD(php_wxListCtrl, GetItemPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* pos0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&item0, &pos0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemPosition((long) item0, *(wxPoint*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemPosition((long) item0, *(wxPoint*) object_pointer0_1));

				references->AddReference(pos0, "wxListCtrl::GetItemPosition at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemPosition\n");
	}
}
/* }}} */

/* {{{ proto bool wxListCtrl::GetItemRect(int item, wxRect &rect, int code)
   Returns the rectangle representing the item's size and position, in physical coordinates. */
PHP_METHOD(php_wxListCtrl, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	long code0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO|l' (&item0, &rect0, php_wxRect_entry, &code0)\n");
		#endif
		char parse_parameters_string[] = "lO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &rect0, php_wxRect_entry, &code0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemRect((long) item0, *(wxRect*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemRect((long) item0, *(wxRect*) object_pointer0_1));

				references->AddReference(rect0, "wxListCtrl::GetItemRect at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListCtrl::GetItemRect((long) item0, *(wxRect*) object_pointer0_1, (int) code0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxListCtrl_php*)_this)->GetItemRect((long) item0, *(wxRect*) object_pointer0_1, (int) code0));

				references->AddReference(rect0, "wxListCtrl::GetItemRect at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemRect\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxListCtrl::GetItemSpacing()
   Retrieves the spacing between icons in pixels: horizontal spacing is returned as x component of the wxSize object and the vertical spacing as its y component. */
PHP_METHOD(php_wxListCtrl, GetItemSpacing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemSpacing\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemSpacing\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemSpacing() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxListCtrl_php*)_this)->GetItemSpacing();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemSpacing\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetItemState(int item, int stateMask)
   Gets the item state. */
PHP_METHOD(php_wxListCtrl, GetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long stateMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&item0, &stateMask0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &stateMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetItemState((long) item0, (long) stateMask0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetItemState((long) item0, (long) stateMask0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemState\n");
	}
}
/* }}} */

/* {{{ proto string wxListCtrl::GetItemText(int item, int col)
   Gets the item text for this item. */
PHP_METHOD(php_wxListCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&item0, &col0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListCtrl::GetItemText((long) item0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemText((long) item0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListCtrl::GetItemText((long) item0, (int) col0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				value_to_return2 = ((wxListCtrl_php*)_this)->GetItemText((long) item0, (int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemText\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListCtrl::GetItemTextColour(int item)
   Returns the colour for this item. */
PHP_METHOD(php_wxListCtrl, GetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListCtrl::GetItemTextColour((long) item0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxListCtrl_php*)_this)->GetItemTextColour((long) item0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetItemTextColour\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::GetNextItem(int item, int geometry, int state)
   Searches for an item with the given geometry or state, starting from item but excluding the item itself. */
PHP_METHOD(php_wxListCtrl, GetNextItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::GetNextItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::GetNextItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	long geometry0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|ll' (&item0, &geometry0, &state0)\n");
		#endif
		char parse_parameters_string[] = "l|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &geometry0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0, (int) geometry0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0, (int) geometry0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::GetNextItem((long) item0, (int) geometry0, (int) state0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->GetNextItem((long) item0, (int) geometry0, (int) state0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::GetNextItem\n");
	}
}
/* }}} */

/* {{{ proto int wxListCtrl::InsertColumn(int col, wxListItem info)
   For report view mode (only), inserts a column. */
PHP_METHOD(php_wxListCtrl, InsertColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListCtrl::InsertColumn\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListCtrl::InsertColumn\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListCtrl){
				references = &((wxListCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxListView) && (!reference_type_found)){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	zval* info0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long col1;
	char* heading1;
	long heading_len1;
	long format1;
	long width1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&col0, &info0, php_wxListItem_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &info0, php_wxListItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(info0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls|ll' (&col1, &heading1, &heading_len1, &format1, &width1)\n");
		#endif
		char parse_parameters_string[] = "ls|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col1, &heading1, &heading_len1, &format1, &width1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col0, *(wxListItem*) object_pointer0_1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col0, *(wxListItem*) object_pointer0_1));

				references->AddReference(info0, "wxListCtrl::InsertColumn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8)));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListCtrl::InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1, (int) width1))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxListCtrl_php*)_this)->InsertColumn((long) col1, wxString(heading1, wxConvUTF8), (int) format1, (int) width1));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListCtrl::InsertColumn\n");
	}
}
/* }}} */

void php_wxListView_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxListView_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxListView::ClearColumnImage(int col)
   Resets the column image -- after calling this function, no image will be shown. */
PHP_METHOD(php_wxListView, ClearColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::ClearColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::ClearColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::ClearColumnImage((int) col0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->ClearColumnImage((int) col0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::ClearColumnImage\n");
	}
}
/* }}} */

/* {{{ proto  wxListView::Focus(int index)
   Sets focus to the item with the given index. */
PHP_METHOD(php_wxListView, Focus)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::Focus\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::Focus\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Focus((long) index0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Focus((long) index0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::Focus\n");
	}
}
/* }}} */

/* {{{ proto int wxListView::GetFirstSelected()
   Returns the first selected item in a (presumably) multiple selection control. */
PHP_METHOD(php_wxListView, GetFirstSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetFirstSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetFirstSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetFirstSelected())\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetFirstSelected());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::GetFirstSelected\n");
	}
}
/* }}} */

/* {{{ proto int wxListView::GetFocusedItem()
   Returns the currently focused item or -1 if none. */
PHP_METHOD(php_wxListView, GetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetFocusedItem())\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetFocusedItem());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::GetFocusedItem\n");
	}
}
/* }}} */

/* {{{ proto int wxListView::GetNextSelected(int item)
   Used together with GetFirstSelected() to iterate over all selected items in the control. */
PHP_METHOD(php_wxListView, GetNextSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::GetNextSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::GetNextSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListView::GetNextSelected((long) item0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_LONG(return_value, ((wxListView_php*)_this)->GetNextSelected((long) item0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::GetNextSelected\n");
	}
}
/* }}} */

/* {{{ proto bool wxListView::IsSelected(int index)
   Returns true if the item with the given index is selected, false otherwise. */
PHP_METHOD(php_wxListView, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListView::IsSelected((long) index0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					ZVAL_BOOL(return_value, ((wxListView_php*)_this)->IsSelected((long) index0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto  wxListView::Select(int n, bool on)
   Selects or unselects the given item. */
PHP_METHOD(php_wxListView, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool on0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&n0, &on0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &on0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Select((long) n0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Select((long) n0);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::Select((long) n0, on0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->Select((long) n0, on0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::Select\n");
	}
}
/* }}} */

/* {{{ proto  wxListView::SetColumnImage(int col, int image)
   Sets the column image for the specified column. */
PHP_METHOD(php_wxListView, SetColumnImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListView::SetColumnImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxListView::SetColumnImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxListView){
				references = &((wxListView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long image0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &image0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &image0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListView::SetColumnImage((int) col0, (int) image0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxListView)
				{
					((wxListView_php*)_this)->SetColumnImage((int) col0, (int) image0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListView::SetColumnImage\n");
	}
}
/* }}} */

void php_wxRadioBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRadioBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxRadioBox::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int n, string choices, int majorDimension, int style, wxValidator validator, string name)
   Creates the radiobox for two-step construction. */
PHP_METHOD(php_wxRadioBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long n0;
	zval* choices0;
	long majorDimension0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_9 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long majorDimension1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlallOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &majorDimension0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlallOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &n0, &choices0, &majorDimension0, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 10){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_9 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_9 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|llOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|llOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_6 = 1;
		HashTable* arr_hash0_6;
		if(arguments_received > 6)
		{
			arr_hash0_6 = Z_ARRVAL_P(choices0);
			array_count0_6 = zend_hash_num_elements(arr_hash0_6);
		}
		wxString* strings_array0_6 = new wxString[array_count0_6];
		bool strings_continue0_6 = true;

		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxRadioBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxRadioBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxRadioBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0));

				references->AddReference(parent0, "wxRadioBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6));

				references->AddReference(parent0, "wxRadioBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 7 argument(s)");
				delete[] strings_array0_6;

				return;
				break;
			}
			case 8:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0));

				references->AddReference(parent0, "wxRadioBox::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 8 argument(s)");
				delete[] strings_array0_6;

				return;
				break;
			}
			case 9:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0));

				references->AddReference(parent0, "wxRadioBox::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 9 argument(s)");
				delete[] strings_array0_6;

				return;
				break;
			}
			case 10:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9));

				references->AddReference(parent0, "wxRadioBox::Create at call with 10 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 10 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 10 argument(s)");
				delete[] strings_array0_6;
				references->AddReference(validator0, "wxRadioBox::Create at call with 10 argument(s)");

				return;
				break;
			}
			case 11:
			{
				int array_index0_6 = 0;
				zval** temp_array_value0_6 = 0;
				while(strings_continue0_6)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_6, (void**)&temp_array_value0_6) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_6);
						strings_array0_6[array_index0_6] = wxString(Z_STRVAL_PP(temp_array_value0_6), wxConvUTF8);
						array_index0_6++;
					}
					else
					{
						strings_continue0_6 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (int) n0, strings_array0_6, (int) majorDimension0, (long) style0, *(wxValidator*) object_pointer0_9, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxRadioBox::Create at call with 11 argument(s)");
				references->AddReference(pos0, "wxRadioBox::Create at call with 11 argument(s)");
				references->AddReference(size0, "wxRadioBox::Create at call with 11 argument(s)");
				delete[] strings_array0_6;
				references->AddReference(validator0, "wxRadioBox::Create at call with 11 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5));

				references->AddReference(parent1, "wxRadioBox::Create at call with 6 argument(s)");
				references->AddReference(pos1, "wxRadioBox::Create at call with 6 argument(s)");
				references->AddReference(size1, "wxRadioBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1));

				references->AddReference(parent1, "wxRadioBox::Create at call with 7 argument(s)");
				references->AddReference(pos1, "wxRadioBox::Create at call with 7 argument(s)");
				references->AddReference(size1, "wxRadioBox::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1));

				references->AddReference(parent1, "wxRadioBox::Create at call with 8 argument(s)");
				references->AddReference(pos1, "wxRadioBox::Create at call with 8 argument(s)");
				references->AddReference(size1, "wxRadioBox::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8));

				references->AddReference(parent1, "wxRadioBox::Create at call with 9 argument(s)");
				references->AddReference(pos1, "wxRadioBox::Create at call with 9 argument(s)");
				references->AddReference(size1, "wxRadioBox::Create at call with 9 argument(s)");
				references->AddReference(validator1, "wxRadioBox::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Create((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8)));

				references->AddReference(parent1, "wxRadioBox::Create at call with 10 argument(s)");
				references->AddReference(pos1, "wxRadioBox::Create at call with 10 argument(s)");
				references->AddReference(size1, "wxRadioBox::Create at call with 10 argument(s)");
				references->AddReference(validator1, "wxRadioBox::Create at call with 10 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxRadioBox::Enable(int n, bool enable)
   Enables or disables an individual button in the radiobox. */
PHP_METHOD(php_wxRadioBox, Enable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Enable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Enable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&n0, &enable0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Enable((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Enable((unsigned int) n0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Enable((unsigned int) n0, enable0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Enable((unsigned int) n0, enable0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::Enable\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::FindString(string string, bool bCase)
   Finds a button matching the given string, returning the position if found, or wxNOT_FOUND if not found. */
PHP_METHOD(php_wxRadioBox, FindString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::FindString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::FindString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	bool bCase0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&string0, &string_len0, &bCase0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0, &bCase0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::FindString(wxString(string0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->FindString(wxString(string0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::FindString(wxString(string0, wxConvUTF8), bCase0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->FindString(wxString(string0, wxConvUTF8), bCase0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::FindString\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::GetColumnCount()
   Returns the number of columns in the radiobox. */
PHP_METHOD(php_wxRadioBox, GetColumnCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetColumnCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetColumnCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetColumnCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetColumnCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetColumnCount\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::GetCount()
   Returns the number of items in the control. */
PHP_METHOD(php_wxRadioBox, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetCount\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::GetItemFromPoint(wxPoint pt)
   Returns a radio box item under the point, a zero-based item index, or wxNOT_FOUND if no item is under the point. */
PHP_METHOD(php_wxRadioBox, GetItemFromPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemFromPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemFromPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetItemFromPoint(*(wxPoint*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetItemFromPoint(*(wxPoint*) object_pointer0_0));

				references->AddReference(pt0, "wxRadioBox::GetItemFromPoint at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetItemFromPoint\n");
	}
}
/* }}} */

/* {{{ proto string wxRadioBox::GetItemHelpText(int item)
   Returns the helptext associated with the specified item if any or wxEmptyString. */
PHP_METHOD(php_wxRadioBox, GetItemHelpText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemHelpText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemHelpText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxRadioBox::GetItemHelpText((unsigned int) item0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxRadioBox_php*)_this)->GetItemHelpText((unsigned int) item0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetItemHelpText\n");
	}
}
/* }}} */

/* {{{ proto wxToolTip wxRadioBox::GetItemToolTip(int item)
   Returns the tooltip associated with the specified item if any or NULL. */
PHP_METHOD(php_wxRadioBox, GetItemToolTip)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetItemToolTip\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetItemToolTip\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::GetItemToolTip((unsigned int) item0) to return object pointer\n\n");
				#endif
				wxToolTip_php* value_to_return1;
				value_to_return1 = (wxToolTip_php*) ((wxRadioBox_php*)_this)->GetItemToolTip((unsigned int) item0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxToolTip_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxToolTip));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxRadioBox::GetItemToolTip at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetItemToolTip\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::GetRowCount()
   Returns the number of rows in the radiobox. */
PHP_METHOD(php_wxRadioBox, GetRowCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetRowCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetRowCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetRowCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetRowCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetRowCount\n");
	}
}
/* }}} */

/* {{{ proto int wxRadioBox::GetSelection()
   Returns the index of the selected item or wxNOT_FOUND if no item is selected. */
PHP_METHOD(php_wxRadioBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRadioBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxRadioBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto string wxRadioBox::GetString(int n)
   Returns the label of the item with the given index. */
PHP_METHOD(php_wxRadioBox, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::GetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxRadioBox::GetString((unsigned int) n0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxRadioBox_php*)_this)->GetString((unsigned int) n0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::GetString\n");
	}
}
/* }}} */

/* {{{ proto bool wxRadioBox::IsItemEnabled(int n)
   Returns true if the item is enabled or false if it was disabled using Enable(n, false). */
PHP_METHOD(php_wxRadioBox, IsItemEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::IsItemEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::IsItemEnabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::IsItemEnabled((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->IsItemEnabled((unsigned int) n0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::IsItemEnabled\n");
	}
}
/* }}} */

/* {{{ proto bool wxRadioBox::IsItemShown(int n)
   Returns true if the item is currently shown or false if it was hidden using Show(n, false). */
PHP_METHOD(php_wxRadioBox, IsItemShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::IsItemShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::IsItemShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::IsItemShown((unsigned int) n0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->IsItemShown((unsigned int) n0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::IsItemShown\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioBox::SetItemHelpText(int item, string helptext)
   Sets the helptext for an item. */
PHP_METHOD(php_wxRadioBox, SetItemHelpText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetItemHelpText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetItemHelpText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	char* helptext0;
	long helptext_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &helptext0, &helptext_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &helptext0, &helptext_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetItemHelpText((unsigned int) item0, wxString(helptext0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetItemHelpText((unsigned int) item0, wxString(helptext0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::SetItemHelpText\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioBox::SetItemToolTip(int item, string text)
   Sets the tooltip text for the specified item in the radio group. */
PHP_METHOD(php_wxRadioBox, SetItemToolTip)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetItemToolTip\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetItemToolTip\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&item0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetItemToolTip((unsigned int) item0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetItemToolTip((unsigned int) item0, wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::SetItemToolTip\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioBox::SetSelection(int n)
   Sets the selection to the given item n or removes the selection entirely if n == wxNOT_FOUND. */
PHP_METHOD(php_wxRadioBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetSelection((int) n0)\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetSelection((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioBox::SetString(int n, string string)
   Sets the label for the given item. */
PHP_METHOD(php_wxRadioBox, SetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::SetString\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::SetString\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	char* string0;
	long string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&n0, &string0, &string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioBox::SetString((unsigned int) n0, wxString(string0, wxConvUTF8))\n\n");
				#endif
				((wxRadioBox_php*)_this)->SetString((unsigned int) n0, wxString(string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::SetString\n");
	}
}
/* }}} */

/* {{{ proto bool wxRadioBox::Show(int item, bool show)
   Shows or hides individual buttons. */
PHP_METHOD(php_wxRadioBox, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::Show\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioBox::Show\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioBox){
				references = &((wxRadioBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &show0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Show((unsigned int) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Show((unsigned int) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioBox::Show((unsigned int) item0, show0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioBox_php*)_this)->Show((unsigned int) item0, show0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioBox::Show\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioBox::wxRadioBox()
   Default constructor. */
PHP_METHOD(php_wxRadioBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	zval* choices1 = 0;
	long majorDimension1;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 6  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlsOOa|llOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlsOOa|llOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &choices1, &majorDimension1, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRadioBox_php();

				((wxRadioBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_5;
		bool strings_continue1_5 = true;

		switch(arguments_received)
		{
			case 6:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1, "wxRadioBox::wxRadioBox at call with 6 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(pos1, "wxRadioBox::wxRadioBox at call with 6 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(size1, "wxRadioBox::wxRadioBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1, "wxRadioBox::wxRadioBox at call with 7 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(pos1, "wxRadioBox::wxRadioBox at call with 7 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(size1, "wxRadioBox::wxRadioBox at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1, "wxRadioBox::wxRadioBox at call with 8 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(pos1, "wxRadioBox::wxRadioBox at call with 8 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(size1, "wxRadioBox::wxRadioBox at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8)\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8);

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1, "wxRadioBox::wxRadioBox at call with 9 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(pos1, "wxRadioBox::wxRadioBox at call with 9 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(size1, "wxRadioBox::wxRadioBox at call with 9 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(validator1, "wxRadioBox::wxRadioBox at call with 9 argument(s)");
				break;
			}
			case 10:
			{
				int array_index1_5 = 0;
				zval** temp_array_value1_5 = 0;
				while(strings_continue1_5)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_5, (void**)&temp_array_value1_5) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_5);
						strings_array1_5.Add(wxString(Z_STRVAL_PP(temp_array_value1_5), wxConvUTF8));
						array_index1_5++;
					}
					else
					{
						strings_continue1_5 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, strings_array1_5, (int) majorDimension1, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8));

				((wxRadioBox_php*) _this)->references.Initialize();
				((wxRadioBox_php*) _this)->references.AddReference(parent1, "wxRadioBox::wxRadioBox at call with 10 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(pos1, "wxRadioBox::wxRadioBox at call with 10 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(size1, "wxRadioBox::wxRadioBox at call with 10 argument(s)");
				((wxRadioBox_php*) _this)->references.AddReference(validator1, "wxRadioBox::wxRadioBox at call with 10 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRadioBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxRadioBox_php*) _this)->phpObj = getThis();
		
		((wxRadioBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRadioBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRadioBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxRadioButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRadioButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxRadioButton::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the choice for two-step construction. */
PHP_METHOD(php_wxRadioButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxRadioButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxRadioButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxRadioButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxRadioButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxRadioButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxRadioButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxRadioButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxRadioButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxRadioButton::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxRadioButton::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxRadioButton::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxRadioButton::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxRadioButton::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxRadioButton::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxRadioButton::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxRadioButton::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxRadioButton::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioButton::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxRadioButton::GetValue()
   Returns true if the radio button is checked, false otherwise. */
PHP_METHOD(php_wxRadioButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRadioButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRadioButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioButton::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioButton::SetValue(bool value)
   Sets the radio button to checked or unchecked status. */
PHP_METHOD(php_wxRadioButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRadioButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRadioButton){
				references = &((wxRadioButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&value0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRadioButton::SetValue(value0)\n\n");
				#endif
				((wxRadioButton_php*)_this)->SetValue(value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRadioButton::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxRadioButton::wxRadioButton()
   Default constructor. */
PHP_METHOD(php_wxRadioButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRadioButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRadioButton_php();

				((wxRadioButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 4 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(pos1, "wxRadioButton::wxRadioButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 5 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(pos1, "wxRadioButton::wxRadioButton at call with 5 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(size1, "wxRadioButton::wxRadioButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 6 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(pos1, "wxRadioButton::wxRadioButton at call with 6 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(size1, "wxRadioButton::wxRadioButton at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 7 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(pos1, "wxRadioButton::wxRadioButton at call with 7 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(size1, "wxRadioButton::wxRadioButton at call with 7 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(validator1, "wxRadioButton::wxRadioButton at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxRadioButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxRadioButton_php*) _this)->references.Initialize();
				((wxRadioButton_php*) _this)->references.AddReference(parent1, "wxRadioButton::wxRadioButton at call with 8 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(pos1, "wxRadioButton::wxRadioButton at call with 8 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(size1, "wxRadioButton::wxRadioButton at call with 8 argument(s)");
				((wxRadioButton_php*) _this)->references.AddReference(validator1, "wxRadioButton::wxRadioButton at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRadioButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxRadioButton_php*) _this)->phpObj = getThis();
		
		((wxRadioButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRadioButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRadioButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxRearrangeList_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxRearrangeList_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxRearrangeList::CanMoveCurrentDown()
   Return true if the currently selected item can be moved down. */
PHP_METHOD(php_wxRearrangeList, CanMoveCurrentDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::CanMoveCurrentDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::CanMoveCurrentDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::CanMoveCurrentDown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->CanMoveCurrentDown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRearrangeList::CanMoveCurrentDown\n");
	}
}
/* }}} */

/* {{{ proto bool wxRearrangeList::CanMoveCurrentUp()
   Return true if the currently selected item can be moved up. */
PHP_METHOD(php_wxRearrangeList, CanMoveCurrentUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::CanMoveCurrentUp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::CanMoveCurrentUp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::CanMoveCurrentUp())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->CanMoveCurrentUp());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRearrangeList::CanMoveCurrentUp\n");
	}
}
/* }}} */

/* {{{ proto bool wxRearrangeList::MoveCurrentDown()
   Move the currently selected item one position below. */
PHP_METHOD(php_wxRearrangeList, MoveCurrentDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::MoveCurrentDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::MoveCurrentDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::MoveCurrentDown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->MoveCurrentDown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRearrangeList::MoveCurrentDown\n");
	}
}
/* }}} */

/* {{{ proto bool wxRearrangeList::MoveCurrentUp()
   Move the currently selected item one position above. */
PHP_METHOD(php_wxRearrangeList, MoveCurrentUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::MoveCurrentUp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeList::MoveCurrentUp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeList){
				references = &((wxRearrangeList_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRearrangeList::MoveCurrentUp())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxRearrangeList_php*)_this)->MoveCurrentUp());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRearrangeList::MoveCurrentUp\n");
	}
}
/* }}} */

/* {{{ proto  wxRearrangeList::wxRearrangeList()
   Default constructor. */
PHP_METHOD(php_wxRearrangeList, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeList::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRearrangeList_php();

				((wxRearrangeList_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRearrangeList);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxRearrangeList_php*) _this)->phpObj = getThis();
		
		((wxRearrangeList_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRearrangeList_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRearrangeList::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxRearrangeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRearrangeCtrl_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxRearrangeCtrl_php* object = static_cast<wxRearrangeCtrl_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRearrangeCtrl done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxRearrangeCtrl::wxRearrangeCtrl()
   Default constructor. */
PHP_METHOD(php_wxRearrangeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxRearrangeCtrl_php();

				((wxRearrangeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxRearrangeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxRearrangeCtrl_php*) _this)->phpObj = getThis();
		
		((wxRearrangeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxRearrangeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRearrangeCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxRearrangeList wxRearrangeCtrl::GetList()
   Return the listbox which is the main part of this control. */
PHP_METHOD(php_wxRearrangeCtrl, GetList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRearrangeCtrl::GetList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxRearrangeCtrl::GetList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxRearrangeCtrl){
				references = &((wxRearrangeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRearrangeCtrl::GetList() to return object pointer\n\n");
				#endif
				wxRearrangeList_php* value_to_return0;
				value_to_return0 = (wxRearrangeList_php*) ((wxRearrangeCtrl_php*)_this)->GetList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRearrangeList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxRearrangeList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxRearrangeCtrl::GetList at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRearrangeCtrl::GetList\n");
	}
}
/* }}} */

void php_wxScrollBar_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxScrollBar_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxScrollBar::wxScrollBar(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Constructor, creating and showing a scrollbar. */
PHP_METHOD(php_wxScrollBar, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 3 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(pos0, "wxScrollBar::wxScrollBar at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 4 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(pos0, "wxScrollBar::wxScrollBar at call with 4 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(size0, "wxScrollBar::wxScrollBar at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 5 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(pos0, "wxScrollBar::wxScrollBar at call with 5 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(size0, "wxScrollBar::wxScrollBar at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5)\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5);

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 6 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(pos0, "wxScrollBar::wxScrollBar at call with 6 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(size0, "wxScrollBar::wxScrollBar at call with 6 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(validator0, "wxScrollBar::wxScrollBar at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxScrollBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8));

				((wxScrollBar_php*) _this)->references.Initialize();
				((wxScrollBar_php*) _this)->references.AddReference(parent0, "wxScrollBar::wxScrollBar at call with 7 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(pos0, "wxScrollBar::wxScrollBar at call with 7 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(size0, "wxScrollBar::wxScrollBar at call with 7 argument(s)");
				((wxScrollBar_php*) _this)->references.AddReference(validator0, "wxScrollBar::wxScrollBar at call with 7 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxScrollBar_php();

				((wxScrollBar_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxScrollBar);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxScrollBar_php*) _this)->phpObj = getThis();
		
		((wxScrollBar_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxScrollBar_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxScrollBar::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxScrollBar::SetThumbPosition(int viewStart)
   Sets the position of the scrollbar. */
PHP_METHOD(php_wxScrollBar, SetThumbPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::SetThumbPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::SetThumbPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long viewStart0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&viewStart0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &viewStart0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetThumbPosition((int) viewStart0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetThumbPosition((int) viewStart0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::SetThumbPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxScrollBar::SetScrollbar(int position, int thumbSize, int range, int pageSize, bool refresh)
   Sets the scrollbar properties. */
PHP_METHOD(php_wxScrollBar, SetScrollbar)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::SetScrollbar\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::SetScrollbar\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long position0;
	long thumbSize0;
	long range0;
	long pageSize0;
	bool refresh0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|b' (&position0, &thumbSize0, &range0, &pageSize0, &refresh0)\n");
		#endif
		char parse_parameters_string[] = "llll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &position0, &thumbSize0, &range0, &pageSize0, &refresh0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0);


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxScrollBar::SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0, refresh0)\n\n");
				#endif
				((wxScrollBar_php*)_this)->SetScrollbar((int) position0, (int) thumbSize0, (int) range0, (int) pageSize0, refresh0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::SetScrollbar\n");
	}
}
/* }}} */

/* {{{ proto int wxScrollBar::GetThumbSize()
   Returns the thumb or 'view' size. */
PHP_METHOD(php_wxScrollBar, GetThumbSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetThumbSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetThumbSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetThumbSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetThumbSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::GetThumbSize\n");
	}
}
/* }}} */

/* {{{ proto int wxScrollBar::GetThumbPosition()
   Returns the current position of the scrollbar thumb. */
PHP_METHOD(php_wxScrollBar, GetThumbPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetThumbPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetThumbPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetThumbPosition())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetThumbPosition());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::GetThumbPosition\n");
	}
}
/* }}} */

/* {{{ proto int wxScrollBar::GetPageSize()
   Returns the page size of the scrollbar. */
PHP_METHOD(php_wxScrollBar, GetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetPageSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetPageSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::GetPageSize\n");
	}
}
/* }}} */

/* {{{ proto int wxScrollBar::GetRange()
   Returns the length of the scrollbar. */
PHP_METHOD(php_wxScrollBar, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxScrollBar::GetRange())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxScrollBar_php*)_this)->GetRange());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::GetRange\n");
	}
}
/* }}} */

/* {{{ proto bool wxScrollBar::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Scrollbar creation function called by the scrollbar constructor. */
PHP_METHOD(php_wxScrollBar, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxScrollBar::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxScrollBar::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxScrollBar){
				references = &((wxScrollBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxScrollBar::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxScrollBar::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxScrollBar::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxScrollBar::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxScrollBar::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxScrollBar::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxScrollBar::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxScrollBar::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxScrollBar::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxScrollBar::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxScrollBar::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxScrollBar::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxScrollBar::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxScrollBar::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxScrollBar_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxScrollBar::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxScrollBar::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxScrollBar::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxScrollBar::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxScrollBar::Create\n");
	}
}
/* }}} */

void php_wxSlider_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSlider_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxSlider::wxSlider()
   Default constructor. */
PHP_METHOD(php_wxSlider, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	long value1;
	long minValue1;
	long maxValue1;
	zval* pos1 = 0;
	void* object_pointer1_5 = 0;
	zval* size1 = 0;
	void* object_pointer1_6 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_8 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 5  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zllll|OOlOs' (&parent1, &id1, &value1, &minValue1, &maxValue1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zllll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &minValue1, &maxValue1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSlider_php();

				((wxSlider_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 6 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(pos1, "wxSlider::wxSlider at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 7 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(pos1, "wxSlider::wxSlider at call with 7 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(size1, "wxSlider::wxSlider at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 8 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(pos1, "wxSlider::wxSlider at call with 8 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(size1, "wxSlider::wxSlider at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8)\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8);

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 9 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(pos1, "wxSlider::wxSlider at call with 9 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(size1, "wxSlider::wxSlider at call with 9 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(validator1, "wxSlider::wxSlider at call with 9 argument(s)");
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSlider_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, (int) value1, (int) minValue1, (int) maxValue1, *(wxPoint*) object_pointer1_5, *(wxSize*) object_pointer1_6, (long) style1, *(wxValidator*) object_pointer1_8, wxString(name1, wxConvUTF8));

				((wxSlider_php*) _this)->references.Initialize();
				((wxSlider_php*) _this)->references.AddReference(parent1, "wxSlider::wxSlider at call with 10 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(pos1, "wxSlider::wxSlider at call with 10 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(size1, "wxSlider::wxSlider at call with 10 argument(s)");
				((wxSlider_php*) _this)->references.AddReference(validator1, "wxSlider::wxSlider at call with 10 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSlider);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSlider_php*) _this)->phpObj = getThis();
		
		((wxSlider_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSlider_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSlider::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxSlider::SetValue(int value)
   Sets the slider position. */
PHP_METHOD(php_wxSlider, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetValue((int) value0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSlider::SetRange(int minValue, int maxValue)
   Sets the minimum and maximum slider values. */
PHP_METHOD(php_wxSlider, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long minValue0;
	long maxValue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&minValue0, &maxValue0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minValue0, &maxValue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetRange((int) minValue0, (int) maxValue0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetRange((int) minValue0, (int) maxValue0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::SetRange\n");
	}
}
/* }}} */

/* {{{ proto  wxSlider::SetPageSize(int pageSize)
   Sets the page size for the slider. */
PHP_METHOD(php_wxSlider, SetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pageSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pageSize0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pageSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetPageSize((int) pageSize0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetPageSize((int) pageSize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::SetPageSize\n");
	}
}
/* }}} */

/* {{{ proto  wxSlider::SetLineSize(int lineSize)
   Sets the line size for the slider. */
PHP_METHOD(php_wxSlider, SetLineSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::SetLineSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::SetLineSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long lineSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineSize0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSlider::SetLineSize((int) lineSize0)\n\n");
				#endif
				((wxSlider_php*)_this)->SetLineSize((int) lineSize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::SetLineSize\n");
	}
}
/* }}} */

/* {{{ proto int wxSlider::GetValue()
   Gets the current slider value. */
PHP_METHOD(php_wxSlider, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::GetValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxSlider::Create(wxWindow &parent, int id, int value, int minValue, int maxValue, wxPoint point, wxSize size, int style, wxValidator validator, string name)
   Used for two-step slider construction. */
PHP_METHOD(php_wxSlider, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	long value0;
	long minValue0;
	long maxValue0;
	zval* point0 = 0;
	void* object_pointer0_5 = 0;
	zval* size0 = 0;
	void* object_pointer0_6 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_8 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zllll|OOlOs' (&parent0, &id0, &value0, &minValue0, &maxValue0, &point0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zllll|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &minValue0, &maxValue0, &point0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 9){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_8 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_8 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0));

				references->AddReference(parent0, "wxSlider::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5));

				references->AddReference(parent0, "wxSlider::Create at call with 6 argument(s)");
				references->AddReference(point0, "wxSlider::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6));

				references->AddReference(parent0, "wxSlider::Create at call with 7 argument(s)");
				references->AddReference(point0, "wxSlider::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxSlider::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0));

				references->AddReference(parent0, "wxSlider::Create at call with 8 argument(s)");
				references->AddReference(point0, "wxSlider::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxSlider::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8));

				references->AddReference(parent0, "wxSlider::Create at call with 9 argument(s)");
				references->AddReference(point0, "wxSlider::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxSlider::Create at call with 9 argument(s)");
				references->AddReference(validator0, "wxSlider::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSlider::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSlider_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, (int) value0, (int) minValue0, (int) maxValue0, *(wxPoint*) object_pointer0_5, *(wxSize*) object_pointer0_6, (long) style0, *(wxValidator*) object_pointer0_8, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSlider::Create at call with 10 argument(s)");
				references->AddReference(point0, "wxSlider::Create at call with 10 argument(s)");
				references->AddReference(size0, "wxSlider::Create at call with 10 argument(s)");
				references->AddReference(validator0, "wxSlider::Create at call with 10 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxSlider::GetLineSize()
   Returns the line size. */
PHP_METHOD(php_wxSlider, GetLineSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetLineSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetLineSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetLineSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetLineSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::GetLineSize\n");
	}
}
/* }}} */

/* {{{ proto int wxSlider::GetMax()
   Gets the maximum slider value. */
PHP_METHOD(php_wxSlider, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::GetMax\n");
	}
}
/* }}} */

/* {{{ proto int wxSlider::GetMin()
   Gets the minimum slider value. */
PHP_METHOD(php_wxSlider, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::GetMin\n");
	}
}
/* }}} */

/* {{{ proto int wxSlider::GetPageSize()
   Returns the page size. */
PHP_METHOD(php_wxSlider, GetPageSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSlider::GetPageSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSlider::GetPageSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSlider){
				references = &((wxSlider_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSlider::GetPageSize())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSlider_php*)_this)->GetPageSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSlider::GetPageSize\n");
	}
}
/* }}} */

void php_wxSpinButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto int wxSpinButton::GetMin()
   Returns the minimum permissible value. */
PHP_METHOD(php_wxSpinButton, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::GetMin\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinButton::GetMax()
   Returns the maximum permissible value. */
PHP_METHOD(php_wxSpinButton, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::GetMax\n");
	}
}
/* }}} */

/* {{{ proto bool wxSpinButton::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Scrollbar creation function called by the spin button constructor. */
PHP_METHOD(php_wxSpinButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxSpinButton::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxSpinButton::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxSpinButton::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxSpinButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxSpinButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxSpinButton::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxSpinButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxSpinButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxSpinButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxSpinButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSpinButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxSpinButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxSpinButton::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinButton::GetValue()
   Returns the current spin button value. */
PHP_METHOD(php_wxSpinButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinButton::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinButton::SetRange(int min, int max)
   Sets the range of the spin button. */
PHP_METHOD(php_wxSpinButton, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long min0;
	long max0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&min0, &max0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &min0, &max0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinButton::SetRange((int) min0, (int) max0)\n\n");
				#endif
				((wxSpinButton_php*)_this)->SetRange((int) min0, (int) max0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::SetRange\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinButton::SetValue(int value)
   Sets the value of the spin button. */
PHP_METHOD(php_wxSpinButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinButton){
				references = &((wxSpinButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinButton::SetValue((int) value0)\n\n");
				#endif
				((wxSpinButton_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinButton::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinButton::wxSpinButton()
   Default constructor. */
PHP_METHOD(php_wxSpinButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinButton_php();

				((wxSpinButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 3 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(pos1, "wxSpinButton::wxSpinButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 4 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(pos1, "wxSpinButton::wxSpinButton at call with 4 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(size1, "wxSpinButton::wxSpinButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 5 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(pos1, "wxSpinButton::wxSpinButton at call with 5 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(size1, "wxSpinButton::wxSpinButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxSpinButton_php*) _this)->references.Initialize();
				((wxSpinButton_php*) _this)->references.AddReference(parent1, "wxSpinButton::wxSpinButton at call with 6 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(pos1, "wxSpinButton::wxSpinButton at call with 6 argument(s)");
				((wxSpinButton_php*) _this)->references.AddReference(size1, "wxSpinButton::wxSpinButton at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSpinButton_php*) _this)->phpObj = getThis();
		
		((wxSpinButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSpinButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxSpinCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxSpinCtrl::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int style, int min, int max, int initial, string name)
   Creation function called by the spin control constructor. */
PHP_METHOD(php_wxSpinCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	long min0;
	long max0;
	long initial0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlllls' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlllls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, (int) min0, (int) max0, (int) initial0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSpinCtrl::Create at call with 10 argument(s)");
				references->AddReference(pos0, "wxSpinCtrl::Create at call with 10 argument(s)");
				references->AddReference(size0, "wxSpinCtrl::Create at call with 10 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinCtrl::GetMax()
   Gets maximal allowable value. */
PHP_METHOD(php_wxSpinCtrl, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetMax())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::GetMax\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinCtrl::GetMin()
   Gets minimal allowable value. */
PHP_METHOD(php_wxSpinCtrl, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetMin())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::GetMin\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinCtrl::GetValue()
   Gets the value of the spin control. */
PHP_METHOD(php_wxSpinCtrl, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrl::GetValue())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrl_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrl::SetRange(int minVal, int maxVal)
   Sets range of allowable values. */
PHP_METHOD(php_wxSpinCtrl, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long minVal0;
	long maxVal0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&minVal0, &maxVal0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minVal0, &maxVal0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetRange((int) minVal0, (int) maxVal0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetRange((int) minVal0, (int) maxVal0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::SetRange\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrl::SetSelection(int from, int to)
   Select the text in the text part of the control between positions from (inclusive) and to (exclusive). */
PHP_METHOD(php_wxSpinCtrl, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetSelection((long) from0, (long) to0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrl::SetValue(int value)
   Sets the value of the spin control. */
PHP_METHOD(php_wxSpinCtrl, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrl::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrl){
				references = &((wxSpinCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrl::SetValue((int) value0)\n\n");
				#endif
				((wxSpinCtrl_php*)_this)->SetValue((int) value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrl::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrl::wxSpinCtrl()
   Default constructor. */
PHP_METHOD(php_wxSpinCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	long min1;
	long max1;
	long initial1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 10)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOlllls' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOlllls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinCtrl_php();

				((wxSpinCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 4 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 5 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 5 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 6 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 6 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 7 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 7 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 8 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 8 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1)\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1);

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 9 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 9 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 9 argument(s)");
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, (int) min1, (int) max1, (int) initial1, wxString(name1, wxConvUTF8));

				((wxSpinCtrl_php*) _this)->references.Initialize();
				((wxSpinCtrl_php*) _this)->references.AddReference(parent1, "wxSpinCtrl::wxSpinCtrl at call with 10 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(pos1, "wxSpinCtrl::wxSpinCtrl at call with 10 argument(s)");
				((wxSpinCtrl_php*) _this)->references.AddReference(size1, "wxSpinCtrl::wxSpinCtrl at call with 10 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSpinCtrl_php*) _this)->phpObj = getThis();
		
		((wxSpinCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSpinCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxSpinCtrlDouble_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSpinCtrlDouble_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxSpinCtrlDouble::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int style, float min, float max, float initial, float inc, string name)
   Creation function called by the spin control constructor. */
PHP_METHOD(php_wxSpinCtrlDouble, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	double min0;
	double max0;
	double initial0;
	double inc0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOldddds' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &inc0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOldddds";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &min0, &max0, &initial0, &inc0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 8 argument(s)");

				return;
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 9 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 9 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 9 argument(s)");

				return;
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 10 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 10 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 10 argument(s)");

				return;
				break;
			}
			case 11:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSpinCtrlDouble::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSpinCtrlDouble_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, min0, max0, initial0, inc0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSpinCtrlDouble::Create at call with 11 argument(s)");
				references->AddReference(pos0, "wxSpinCtrlDouble::Create at call with 11 argument(s)");
				references->AddReference(size0, "wxSpinCtrlDouble::Create at call with 11 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxSpinCtrlDouble::GetDigits()
   Gets the number of digits in the display. */
PHP_METHOD(php_wxSpinCtrlDouble, GetDigits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetDigits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetDigits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetDigits())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxSpinCtrlDouble_php*)_this)->GetDigits());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::GetDigits\n");
	}
}
/* }}} */

/* {{{ proto float wxSpinCtrlDouble::GetIncrement()
   Gets the increment value. */
PHP_METHOD(php_wxSpinCtrlDouble, GetIncrement)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetIncrement\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetIncrement\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetIncrement())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetIncrement());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::GetIncrement\n");
	}
}
/* }}} */

/* {{{ proto float wxSpinCtrlDouble::GetMax()
   Gets maximal allowable value. */
PHP_METHOD(php_wxSpinCtrlDouble, GetMax)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetMax\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetMax\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetMax())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetMax());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::GetMax\n");
	}
}
/* }}} */

/* {{{ proto float wxSpinCtrlDouble::GetMin()
   Gets minimal allowable value. */
PHP_METHOD(php_wxSpinCtrlDouble, GetMin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetMin\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetMin\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetMin())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetMin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::GetMin\n");
	}
}
/* }}} */

/* {{{ proto float wxSpinCtrlDouble::GetValue()
   Gets the value of the spin control. */
PHP_METHOD(php_wxSpinCtrlDouble, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSpinCtrlDouble::GetValue())\n\n");
				#endif
				ZVAL_DOUBLE(return_value, ((wxSpinCtrlDouble_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrlDouble::SetDigits(int digits)
   Sets the number of digits in the display. */
PHP_METHOD(php_wxSpinCtrlDouble, SetDigits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetDigits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetDigits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long digits0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&digits0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &digits0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetDigits((unsigned int) digits0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetDigits((unsigned int) digits0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::SetDigits\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrlDouble::SetIncrement(float inc)
   Sets the increment value. */
PHP_METHOD(php_wxSpinCtrlDouble, SetIncrement)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetIncrement\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetIncrement\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double inc0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&inc0)\n");
		#endif
		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &inc0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetIncrement(inc0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetIncrement(inc0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::SetIncrement\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrlDouble::SetRange(float minVal, float maxVal)
   Sets range of allowable values. */
PHP_METHOD(php_wxSpinCtrlDouble, SetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double minVal0;
	double maxVal0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&minVal0, &maxVal0)\n");
		#endif
		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &minVal0, &maxVal0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetRange(minVal0, maxVal0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetRange(minVal0, maxVal0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::SetRange\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrlDouble::SetValue(float value)
   Sets the value of the spin control. */
PHP_METHOD(php_wxSpinCtrlDouble, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSpinCtrlDouble::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSpinCtrlDouble){
				references = &((wxSpinCtrlDouble_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&value0)\n");
		#endif
		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSpinCtrlDouble::SetValue(value0)\n\n");
				#endif
				((wxSpinCtrlDouble_php*)_this)->SetValue(value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSpinCtrlDouble::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxSpinCtrlDouble::wxSpinCtrlDouble()
   Default constructor. */
PHP_METHOD(php_wxSpinCtrlDouble, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSpinCtrlDouble::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	double min1;
	double max1;
	double initial1;
	double inc1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 11)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lsOOldddds' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &inc1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lsOOldddds";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &min1, &max1, &initial1, &inc1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSpinCtrlDouble_php();

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 4 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 5 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 5 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 6 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 6 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 7 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 7 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 8 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 8 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 8 argument(s)");
				break;
			}
			case 9:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 9 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 9 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 9 argument(s)");
				break;
			}
			case 10:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1)\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1);

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 10 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 10 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 10 argument(s)");
				break;
			}
			case 11:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSpinCtrlDouble_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, min1, max1, initial1, inc1, wxString(name1, wxConvUTF8));

				((wxSpinCtrlDouble_php*) _this)->references.Initialize();
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(parent1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 11 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(pos1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 11 argument(s)");
				((wxSpinCtrlDouble_php*) _this)->references.AddReference(size1, "wxSpinCtrlDouble::wxSpinCtrlDouble at call with 11 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSpinCtrlDouble);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSpinCtrlDouble_php*) _this)->phpObj = getThis();
		
		((wxSpinCtrlDouble_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSpinCtrlDouble_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSpinCtrlDouble::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxSearchCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxSearchCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxSearchCtrl::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the text control for two-step construction. */
PHP_METHOD(php_wxSearchCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxSearchCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxSearchCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxSearchCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxSearchCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxSearchCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxSearchCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxSearchCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxSearchCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxSearchCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxSearchCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxSearchCtrl::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxSearchCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto string wxSearchCtrl::GetDescriptiveText()
   Return the text displayed when there is not yet any user input. */
PHP_METHOD(php_wxSearchCtrl, GetDescriptiveText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::GetDescriptiveText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::GetDescriptiveText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxSearchCtrl::GetDescriptiveText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxSearchCtrl_php*)_this)->GetDescriptiveText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::GetDescriptiveText\n");
	}
}
/* }}} */

/* {{{ proto wxMenu wxSearchCtrl::GetMenu()
   Returns a pointer to the search control's menu object or NULL if there is no menu attached. */
PHP_METHOD(php_wxSearchCtrl, GetMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::GetMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::GetMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::GetMenu() to return object pointer\n\n");
				#endif
				wxMenu_php* value_to_return0;
				value_to_return0 = (wxMenu_php*) ((wxSearchCtrl_php*)_this)->GetMenu();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxMenu_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxMenu));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxSearchCtrl::GetMenu at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::GetMenu\n");
	}
}
/* }}} */

/* {{{ proto bool wxSearchCtrl::IsCancelButtonVisible()
   Returns the cancel button's visibility state. */
PHP_METHOD(php_wxSearchCtrl, IsCancelButtonVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::IsCancelButtonVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::IsCancelButtonVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::IsCancelButtonVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsCancelButtonVisible());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::IsCancelButtonVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxSearchCtrl::IsSearchButtonVisible()
   Returns the search button visibility value. */
PHP_METHOD(php_wxSearchCtrl, IsSearchButtonVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::IsSearchButtonVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::IsSearchButtonVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSearchCtrl::IsSearchButtonVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsSearchButtonVisible());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::IsSearchButtonVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxSearchCtrl::SetDescriptiveText(string text)
   Set the text to be displayed in the search control when the user has not yet typed anything in it. */
PHP_METHOD(php_wxSearchCtrl, SetDescriptiveText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::SetDescriptiveText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::SetDescriptiveText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::SetDescriptiveText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->SetDescriptiveText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::SetDescriptiveText\n");
	}
}
/* }}} */

/* {{{ proto  wxSearchCtrl::SetMenu(wxMenu &menu)
   Sets the search control's menu object. */
PHP_METHOD(php_wxSearchCtrl, SetMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::SetMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::SetMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* menu0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(menu0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::SetMenu((wxMenu*) object_pointer0_0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->SetMenu((wxMenu*) object_pointer0_0);

				references->AddReference(menu0, "wxSearchCtrl::SetMenu at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::SetMenu\n");
	}
}
/* }}} */

/* {{{ proto  wxSearchCtrl::ShowCancelButton(bool show)
   Shows or hides the cancel button. */
PHP_METHOD(php_wxSearchCtrl, ShowCancelButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::ShowCancelButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::ShowCancelButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::ShowCancelButton(show0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->ShowCancelButton(show0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::ShowCancelButton\n");
	}
}
/* }}} */

/* {{{ proto  wxSearchCtrl::ShowSearchButton(bool show)
   Sets the search button visibility value on the search control. */
PHP_METHOD(php_wxSearchCtrl, ShowSearchButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::ShowSearchButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxSearchCtrl::ShowSearchButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxSearchCtrl){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSearchCtrl::ShowSearchButton(show0)\n\n");
				#endif
				((wxSearchCtrl_php*)_this)->ShowSearchButton(show0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSearchCtrl::ShowSearchButton\n");
	}
}
/* }}} */

/* {{{ proto  wxSearchCtrl::wxSearchCtrl()
   Default constructor. */
PHP_METHOD(php_wxSearchCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSearchCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxSearchCtrl_php();

				((wxSearchCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 4 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1, "wxSearchCtrl::wxSearchCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 5 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1, "wxSearchCtrl::wxSearchCtrl at call with 5 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(size1, "wxSearchCtrl::wxSearchCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 6 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1, "wxSearchCtrl::wxSearchCtrl at call with 6 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(size1, "wxSearchCtrl::wxSearchCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 7 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1, "wxSearchCtrl::wxSearchCtrl at call with 7 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(size1, "wxSearchCtrl::wxSearchCtrl at call with 7 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(validator1, "wxSearchCtrl::wxSearchCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxSearchCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxSearchCtrl_php*) _this)->references.Initialize();
				((wxSearchCtrl_php*) _this)->references.AddReference(parent1, "wxSearchCtrl::wxSearchCtrl at call with 8 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(pos1, "wxSearchCtrl::wxSearchCtrl at call with 8 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(size1, "wxSearchCtrl::wxSearchCtrl at call with 8 argument(s)");
				((wxSearchCtrl_php*) _this)->references.AddReference(validator1, "wxSearchCtrl::wxSearchCtrl at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxSearchCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxSearchCtrl_php*) _this)->phpObj = getThis();
		
		((wxSearchCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxSearchCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSearchCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxStaticBitmap_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticBitmap_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxStaticBitmap::Create(wxWindow &parent, int id, wxBitmap label, wxPoint pos, wxSize size, int style, string name)
   Creation function, for two-step construction. */
PHP_METHOD(php_wxStaticBitmap, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* label0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOls' (&parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0, "wxStaticBitmap::Create at call with 3 argument(s)");
				references->AddReference(label0, "wxStaticBitmap::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxStaticBitmap::Create at call with 4 argument(s)");
				references->AddReference(label0, "wxStaticBitmap::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxStaticBitmap::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxStaticBitmap::Create at call with 5 argument(s)");
				references->AddReference(label0, "wxStaticBitmap::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxStaticBitmap::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxStaticBitmap::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxStaticBitmap::Create at call with 6 argument(s)");
				references->AddReference(label0, "wxStaticBitmap::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxStaticBitmap::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxStaticBitmap::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBitmap::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBitmap_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticBitmap::Create at call with 7 argument(s)");
				references->AddReference(label0, "wxStaticBitmap::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxStaticBitmap::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxStaticBitmap::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBitmap::Create\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxStaticBitmap::GetBitmap()
   Returns the bitmap currently used in the control. */
PHP_METHOD(php_wxStaticBitmap, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::GetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::GetBitmap() to return new object\n\n");
				#endif
				wxBitmap value_to_return0;
				value_to_return0 = ((wxStaticBitmap_php*)_this)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBitmap::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxStaticBitmap::GetIcon()
   Returns the icon currently used in the control. */
PHP_METHOD(php_wxStaticBitmap, GetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::GetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::GetIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::GetIcon() to return new object\n\n");
				#endif
				wxIcon value_to_return0;
				value_to_return0 = ((wxStaticBitmap_php*)_this)->GetIcon();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxIcon));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBitmap::GetIcon\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticBitmap::SetBitmap(wxBitmap label)
   Sets the bitmap label. */
PHP_METHOD(php_wxStaticBitmap, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::SetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* label0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&label0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxStaticBitmap_php*)_this)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(label0, "wxStaticBitmap::SetBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBitmap::SetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticBitmap::SetIcon(wxIcon label)
   Sets the label to the given icon. */
PHP_METHOD(php_wxStaticBitmap, SetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::SetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBitmap::SetIcon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBitmap){
				references = &((wxStaticBitmap_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* label0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&label0, php_wxIcon_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticBitmap::SetIcon(*(wxIcon*) object_pointer0_0)\n\n");
				#endif
				((wxStaticBitmap_php*)_this)->SetIcon(*(wxIcon*) object_pointer0_0);

				references->AddReference(label0, "wxStaticBitmap::SetIcon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBitmap::SetIcon\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticBitmap::wxStaticBitmap()
   Default constructor. */
PHP_METHOD(php_wxStaticBitmap, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBitmap::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* label1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOls' (&parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticBitmap_php();

				((wxStaticBitmap_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1, "wxStaticBitmap::wxStaticBitmap at call with 3 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(label1, "wxStaticBitmap::wxStaticBitmap at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1, "wxStaticBitmap::wxStaticBitmap at call with 4 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(label1, "wxStaticBitmap::wxStaticBitmap at call with 4 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1, "wxStaticBitmap::wxStaticBitmap at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1, "wxStaticBitmap::wxStaticBitmap at call with 5 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(label1, "wxStaticBitmap::wxStaticBitmap at call with 5 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1, "wxStaticBitmap::wxStaticBitmap at call with 5 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(size1, "wxStaticBitmap::wxStaticBitmap at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1, "wxStaticBitmap::wxStaticBitmap at call with 6 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(label1, "wxStaticBitmap::wxStaticBitmap at call with 6 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1, "wxStaticBitmap::wxStaticBitmap at call with 6 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(size1, "wxStaticBitmap::wxStaticBitmap at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBitmap_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticBitmap_php*) _this)->references.Initialize();
				((wxStaticBitmap_php*) _this)->references.AddReference(parent1, "wxStaticBitmap::wxStaticBitmap at call with 7 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(label1, "wxStaticBitmap::wxStaticBitmap at call with 7 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(pos1, "wxStaticBitmap::wxStaticBitmap at call with 7 argument(s)");
				((wxStaticBitmap_php*) _this)->references.AddReference(size1, "wxStaticBitmap::wxStaticBitmap at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticBitmap);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxStaticBitmap_php*) _this)->phpObj = getThis();
		
		((wxStaticBitmap_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticBitmap_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxStaticBitmap::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxStaticBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticBox_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxStaticBox::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, string name)
   Creates the static box for two-step construction. */
PHP_METHOD(php_wxStaticBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticBox){
				references = &((wxStaticBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxStaticBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxStaticBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxStaticBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxStaticBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxStaticBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxStaticBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxStaticBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxStaticBox::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticBox::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxStaticBox::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxStaticBox::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticBox::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticBox::wxStaticBox()
   Default constructor. */
PHP_METHOD(php_wxStaticBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticBox_php();

				((wxStaticBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1, "wxStaticBox::wxStaticBox at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1, "wxStaticBox::wxStaticBox at call with 4 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(pos1, "wxStaticBox::wxStaticBox at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1, "wxStaticBox::wxStaticBox at call with 5 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(pos1, "wxStaticBox::wxStaticBox at call with 5 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(size1, "wxStaticBox::wxStaticBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1, "wxStaticBox::wxStaticBox at call with 6 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(pos1, "wxStaticBox::wxStaticBox at call with 6 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(size1, "wxStaticBox::wxStaticBox at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticBox_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticBox_php*) _this)->references.Initialize();
				((wxStaticBox_php*) _this)->references.AddReference(parent1, "wxStaticBox::wxStaticBox at call with 7 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(pos1, "wxStaticBox::wxStaticBox at call with 7 argument(s)");
				((wxStaticBox_php*) _this)->references.AddReference(size1, "wxStaticBox::wxStaticBox at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxStaticBox_php*) _this)->phpObj = getThis();
		
		((wxStaticBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxStaticBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxStaticLine_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticLine_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxStaticLine::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Creates the static line for two-step construction. */
PHP_METHOD(php_wxStaticLine, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxStaticLine::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxStaticLine::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxStaticLine::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxStaticLine::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxStaticLine::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxStaticLine::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxStaticLine::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxStaticLine::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxStaticLine::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxStaticLine::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticLine::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxStaticLine::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxStaticLine::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticLine::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxStaticLine::GetDefaultSize()
   This static function returns the size which will be given to the smaller dimension of the static line, i.e. */
PHP_METHOD(php_wxStaticLine, GetDefaultSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::GetDefaultSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::GetDefaultSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxStaticLine::GetDefaultSize())\n\n");
				#endif
				ZVAL_LONG(return_value, wxStaticLine::GetDefaultSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticLine::GetDefaultSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxStaticLine::IsVertical()
   Returns true if the line is vertical, false if horizontal. */
PHP_METHOD(php_wxStaticLine, IsVertical)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::IsVertical\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticLine::IsVertical\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticLine){
				references = &((wxStaticLine_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticLine::IsVertical())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticLine_php*)_this)->IsVertical());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticLine::IsVertical\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticLine::wxStaticLine()
   Default constructor. */
PHP_METHOD(php_wxStaticLine, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticLine::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticLine_php();

				((wxStaticLine_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 3 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(pos1, "wxStaticLine::wxStaticLine at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 4 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(pos1, "wxStaticLine::wxStaticLine at call with 4 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(size1, "wxStaticLine::wxStaticLine at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 5 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(pos1, "wxStaticLine::wxStaticLine at call with 5 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(size1, "wxStaticLine::wxStaticLine at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticLine_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticLine_php*) _this)->references.Initialize();
				((wxStaticLine_php*) _this)->references.AddReference(parent1, "wxStaticLine::wxStaticLine at call with 6 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(pos1, "wxStaticLine::wxStaticLine at call with 6 argument(s)");
				((wxStaticLine_php*) _this)->references.AddReference(size1, "wxStaticLine::wxStaticLine at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticLine);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxStaticLine_php*) _this)->phpObj = getThis();
		
		((wxStaticLine_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticLine_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxStaticLine::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxStaticText_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxStaticText_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxStaticText::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, string name)
   Creation function, for two-step construction. */
PHP_METHOD(php_wxStaticText, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticText::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxStaticText::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxStaticText::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxStaticText::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxStaticText::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxStaticText::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxStaticText::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxStaticText::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxStaticText::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxStaticText::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxStaticText::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxStaticText::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticText::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxStaticText::IsEllipsized()
   Returns true if the window styles for this control contains one of the wxST_ELLIPSIZE_START, wxST_ELLIPSIZE_MIDDLE or wxST_ELLIPSIZE_END styles. */
PHP_METHOD(php_wxStaticText, IsEllipsized)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::IsEllipsized\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::IsEllipsized\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxStaticText::IsEllipsized())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxStaticText_php*)_this)->IsEllipsized());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticText::IsEllipsized\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticText::Wrap(int width)
   This functions wraps the controls label so that each of its lines becomes at most width pixels wide if possible (the lines are broken at words boundaries so it might not be the case if words are too long). */
PHP_METHOD(php_wxStaticText, Wrap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::Wrap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxStaticText::Wrap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxStaticText){
				references = &((wxStaticText_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxStaticText::Wrap((int) width0)\n\n");
				#endif
				((wxStaticText_php*)_this)->Wrap((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStaticText::Wrap\n");
	}
}
/* }}} */

/* {{{ proto  wxStaticText::wxStaticText()
   Default constructor. */
PHP_METHOD(php_wxStaticText, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStaticText::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOls' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxStaticText_php();

				((wxStaticText_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1, "wxStaticText::wxStaticText at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1, "wxStaticText::wxStaticText at call with 4 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(pos1, "wxStaticText::wxStaticText at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1, "wxStaticText::wxStaticText at call with 5 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(pos1, "wxStaticText::wxStaticText at call with 5 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(size1, "wxStaticText::wxStaticText at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1, "wxStaticText::wxStaticText at call with 6 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(pos1, "wxStaticText::wxStaticText at call with 6 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(size1, "wxStaticText::wxStaticText at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxStaticText_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, wxString(name1, wxConvUTF8));

				((wxStaticText_php*) _this)->references.Initialize();
				((wxStaticText_php*) _this)->references.AddReference(parent1, "wxStaticText::wxStaticText at call with 7 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(pos1, "wxStaticText::wxStaticText at call with 7 argument(s)");
				((wxStaticText_php*) _this)->references.AddReference(size1, "wxStaticText::wxStaticText at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxStaticText);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxStaticText_php*) _this)->phpObj = getThis();
		
		((wxStaticText_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxStaticText_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxStaticText::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxTextCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxTextCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxTextCtrl::wxTextCtrl()
   Default ctor. */
PHP_METHOD(php_wxTextCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* value1;
	long value_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &value1, &value_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTextCtrl_php();

				((wxTextCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8))\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8));

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 4 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(pos1, "wxTextCtrl::wxTextCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 5 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(pos1, "wxTextCtrl::wxTextCtrl at call with 5 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(size1, "wxTextCtrl::wxTextCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 6 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(pos1, "wxTextCtrl::wxTextCtrl at call with 6 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(size1, "wxTextCtrl::wxTextCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 7 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(pos1, "wxTextCtrl::wxTextCtrl at call with 7 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(size1, "wxTextCtrl::wxTextCtrl at call with 7 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(validator1, "wxTextCtrl::wxTextCtrl at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxTextCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(value1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxTextCtrl_php*) _this)->references.Initialize();
				((wxTextCtrl_php*) _this)->references.AddReference(parent1, "wxTextCtrl::wxTextCtrl at call with 8 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(pos1, "wxTextCtrl::wxTextCtrl at call with 8 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(size1, "wxTextCtrl::wxTextCtrl at call with 8 argument(s)");
				((wxTextCtrl_php*) _this)->references.AddReference(validator1, "wxTextCtrl::wxTextCtrl at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTextCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxTextCtrl_php*) _this)->phpObj = getThis();
		
		((wxTextCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTextCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTextCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto int wxTextCtrl::XYToPosition(int x, int y)
   Converts the given zero based column and line number to a position. */
PHP_METHOD(php_wxTextCtrl, XYToPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::XYToPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::XYToPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::XYToPosition((long) x0, (long) y0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->XYToPosition((long) x0, (long) y0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::XYToPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxTextCtrl::ShowPosition(int pos)
   Makes the line containing the given position visible. */
PHP_METHOD(php_wxTextCtrl, ShowPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::ShowPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::ShowPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::ShowPosition((long) pos0)\n\n");
				#endif
				((wxTextCtrl_php*)_this)->ShowPosition((long) pos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::ShowPosition\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::SetStyle(int start, int end, wxTextAttr style)
   Changes the style of the given range. */
PHP_METHOD(php_wxTextCtrl, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long start0;
	long end0;
	zval* style0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO' (&start0, &end0, &style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "llO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &start0, &end0, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SetStyle((long) start0, (long) end0, *(wxTextAttr*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetStyle((long) start0, (long) end0, *(wxTextAttr*) object_pointer0_2));

				references->AddReference(style0, "wxTextCtrl::SetStyle at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::SetStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxTextCtrl::SetModified(bool modified)
   Marks the control as being modified by the user or not. */
PHP_METHOD(php_wxTextCtrl, SetModified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetModified\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetModified\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool modified0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&modified0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &modified0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::SetModified(modified0)\n\n");
				#endif
				((wxTextCtrl_php*)_this)->SetModified(modified0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::SetModified\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::SetDefaultStyle(wxTextAttr style)
   Changes the default style to use for the new text which is going to be added to the control using WriteText() or AppendText(). */
PHP_METHOD(php_wxTextCtrl, SetDefaultStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SetDefaultStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SetDefaultStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* style0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SetDefaultStyle(*(wxTextAttr*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetDefaultStyle(*(wxTextAttr*) object_pointer0_0));

				references->AddReference(style0, "wxTextCtrl::SetDefaultStyle at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::SetDefaultStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::SaveFile(string filename, int fileType)
   Saves the contents of the control in a text file. */
PHP_METHOD(php_wxTextCtrl, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::SaveFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	long fileType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|sl' (&filename0, &filename_len0, &fileType0)\n");
		#endif
		char parse_parameters_string[] = "|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0, &fileType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::SaveFile(wxString(filename0, wxConvUTF8), (int) fileType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SaveFile(wxString(filename0, wxConvUTF8), (int) fileType0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::SaveFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::PositionToXY(int pos, int &x, int &y)
   Converts given position to a zero-based column, line number pair. */
PHP_METHOD(php_wxTextCtrl, PositionToXY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::PositionToXY\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::PositionToXY\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long* x0;
	zval* x0_ref;
	long* y0;
	zval* y0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&pos0, x0, y0)\n");
		#endif
		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, x0, y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &x0_ref, &y0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::PositionToXY((long) pos0, (long*) x0, (long*) y0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->PositionToXY((long) pos0, (long*) x0, (long*) y0));

				size_t elements_returned0_1 = sizeof(x0)/sizeof(*x0);
				array_init(x0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(x0_ref, x0[i]);
				}
				size_t elements_returned0_2 = sizeof(y0)/sizeof(*y0);
				array_init(y0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(y0_ref, y0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::PositionToXY\n");
	}
}
/* }}} */

/* {{{ proto  wxTextCtrl::MarkDirty()
   Mark text as modified (dirty). */
PHP_METHOD(php_wxTextCtrl, MarkDirty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::MarkDirty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::MarkDirty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::MarkDirty()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->MarkDirty();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::MarkDirty\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::LoadFile(string filename, int fileType)
   Loads and displays the named file, if it exists. */
PHP_METHOD(php_wxTextCtrl, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::LoadFile\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	long fileType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&filename0, &filename_len0, &fileType0)\n");
		#endif
		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0, &fileType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::LoadFile(wxString(filename0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->LoadFile(wxString(filename0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::LoadFile(wxString(filename0, wxConvUTF8), (int) fileType0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->LoadFile(wxString(filename0, wxConvUTF8), (int) fileType0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::IsSingleLine()
   Returns true if this is a single line edit control and false otherwise. */
PHP_METHOD(php_wxTextCtrl, IsSingleLine)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsSingleLine\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsSingleLine\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsSingleLine())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsSingleLine());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::IsSingleLine\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::IsMultiLine()
   Returns true if this is a multi line edit control and false otherwise. */
PHP_METHOD(php_wxTextCtrl, IsMultiLine)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsMultiLine\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsMultiLine\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsMultiLine())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsMultiLine());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::IsMultiLine\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::IsModified()
   Returns true if the text has been modified by user. */
PHP_METHOD(php_wxTextCtrl, IsModified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::IsModified\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::IsModified\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::IsModified())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsModified());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::IsModified\n");
	}
}
/* }}} */

/* {{{ proto int wxTextCtrl::GetNumberOfLines()
   Returns the number of lines in the text control buffer. */
PHP_METHOD(php_wxTextCtrl, GetNumberOfLines)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetNumberOfLines\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetNumberOfLines\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::GetNumberOfLines())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetNumberOfLines());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::GetNumberOfLines\n");
	}
}
/* }}} */

/* {{{ proto string wxTextCtrl::GetLineText(int lineNo)
   Returns the contents of a given line in the text control, not including any trailing newline character(s). */
PHP_METHOD(php_wxTextCtrl, GetLineText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetLineText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetLineText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long lineNo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineNo0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineNo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextCtrl::GetLineText((long) lineNo0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTextCtrl_php*)_this)->GetLineText((long) lineNo0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::GetLineText\n");
	}
}
/* }}} */

/* {{{ proto int wxTextCtrl::GetLineLength(int lineNo)
   Gets the length of the specified line, not including any trailing newline character(s). */
PHP_METHOD(php_wxTextCtrl, GetLineLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetLineLength\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetLineLength\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long lineNo0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&lineNo0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &lineNo0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextCtrl::GetLineLength((long) lineNo0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetLineLength((long) lineNo0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::GetLineLength\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::EmulateKeyPress(wxKeyEvent event)
   This function inserts into the control the character which would have been inserted if the given key event had occurred in the text control. */
PHP_METHOD(php_wxTextCtrl, EmulateKeyPress)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::EmulateKeyPress\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::EmulateKeyPress\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* event0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxKeyEvent_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxKeyEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(event0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::EmulateKeyPress(*(wxKeyEvent*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->EmulateKeyPress(*(wxKeyEvent*) object_pointer0_0));

				references->AddReference(event0, "wxTextCtrl::EmulateKeyPress at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::EmulateKeyPress\n");
	}
}
/* }}} */

/* {{{ proto  wxTextCtrl::DiscardEdits()
   Resets the internal modified flag as if the current changes had been saved. */
PHP_METHOD(php_wxTextCtrl, DiscardEdits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::DiscardEdits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::DiscardEdits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::DiscardEdits()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->DiscardEdits();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::DiscardEdits\n");
	}
}
/* }}} */

/* {{{ proto  wxTextCtrl::Cut()
   Copies the selected text to the clipboard and removes the selection. */
PHP_METHOD(php_wxTextCtrl, Cut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::Cut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::Cut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::Cut()\n\n");
				#endif
				((wxTextCtrl_php*)_this)->Cut();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::Cut\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::Create(wxWindow &parent, int id, string value, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the text control for two-step construction. */
PHP_METHOD(php_wxTextCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* value0;
	long value_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlOs' (&parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &value0, &value_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8)));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxTextCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxTextCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxTextCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxTextCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxTextCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxTextCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxTextCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxTextCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(value0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxTextCtrl::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxTextCtrl::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxTextCtrl::Create at call with 8 argument(s)");
				references->AddReference(validator0, "wxTextCtrl::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto wxTextAttr wxTextCtrl::GetDefaultStyle()
   Returns the style currently used for the new text. */
PHP_METHOD(php_wxTextCtrl, GetDefaultStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetDefaultStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetDefaultStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextCtrl::GetDefaultStyle() to return object reference\n\n");
				#endif
				wxTextAttr_php* value_to_return0;
				value_to_return0 = (wxTextAttr_php*) &((wxTextCtrl_php*)_this)->GetDefaultStyle();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextAttr_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextAttr));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxTextCtrl::GetDefaultStyle at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::GetDefaultStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextCtrl::GetStyle(int position, wxTextAttr &style)
   Returns the style at this position in the text control. */
PHP_METHOD(php_wxTextCtrl, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextCtrl::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextCtrl::GetStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextCtrl){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long position0;
	zval* style0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&position0, &style0, php_wxTextAttr_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &position0, &style0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(style0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(style0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextCtrl::GetStyle((long) position0, *(wxTextAttr*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->GetStyle((long) position0, *(wxTextAttr*) object_pointer0_1));

				references->AddReference(style0, "wxTextCtrl::GetStyle at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextCtrl::GetStyle\n");
	}
}
/* }}} */

void php_wxTextEntry_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextEntry_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxTextEntry_php* object = static_cast<wxTextEntry_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextEntry done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxTextEntry::WriteText(string text)
   Writes the text into the text control at the current insertion position. */
PHP_METHOD(php_wxTextEntry, WriteText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::WriteText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::WriteText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::WriteText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->WriteText(wxString(text0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::WriteText\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Undo()
   If there is an undo facility and the last operation can be undone, undoes the last operation. */
PHP_METHOD(php_wxTextEntry, Undo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Undo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Undo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Undo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Undo();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Undo();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Undo\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetValue(string value)
   Sets the new text control value. */
PHP_METHOD(php_wxTextEntry, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetValue(wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetSelection(int from, int to)
   Selects the text starting at the first position up to (but not including) the character at the last position. */
PHP_METHOD(php_wxTextEntry, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetSelection((long) from0, (long) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetSelection((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetSelection((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetSelection((long) from0, (long) to0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetMaxLength(int len)
   This function sets the maximum number of characters the user can enter into the control. */
PHP_METHOD(php_wxTextEntry, SetMaxLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetMaxLength\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetMaxLength\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&len0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetMaxLength((unsigned long) len0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SetMaxLength((unsigned long) len0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetMaxLength((unsigned long) len0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetMaxLength\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::SetMargins(int left, int top)
   Attempts to set the control margins. */
PHP_METHOD(php_wxTextEntry, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long left0;
	long top0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&left0, &top0)\n");
		#endif
		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &top0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins((wxCoord) left0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins((wxCoord) left0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins((wxCoord) left0));
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins((wxCoord) left0, (wxCoord) top0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins((wxCoord) left0, (wxCoord) top0));
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetMargins(*(wxPoint*) object_pointer1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0));
				}

				references->AddReference(pt1, "wxTextEntry::SetMargins at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetInsertionPointEnd()
   Sets the insertion point at the end of the text control. */
PHP_METHOD(php_wxTextEntry, SetInsertionPointEnd)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetInsertionPointEnd\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetInsertionPointEnd\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetInsertionPointEnd()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetInsertionPointEnd();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetInsertionPointEnd();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetInsertionPointEnd\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetInsertionPoint(int pos)
   Sets the insertion point at the given position. */
PHP_METHOD(php_wxTextEntry, SetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetInsertionPoint((long) pos0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetInsertionPoint((long) pos0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetInsertionPoint((long) pos0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetInsertionPoint\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::SetHint(string hint)
   Sets a hint shown in an empty unfocused text control. */
PHP_METHOD(php_wxTextEntry, SetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* hint0;
	long hint_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&hint0, &hint_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hint0, &hint_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::SetHint(wxString(hint0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->SetHint(wxString(hint0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetHint\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SetEditable(bool editable)
   Makes the text item editable or read-only, overriding the wxTE_READONLY flag. */
PHP_METHOD(php_wxTextEntry, SetEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SetEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SetEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool editable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&editable0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &editable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SetEditable(editable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SetEditable(editable0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SetEditable(editable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SetEditable\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::SelectAll()
   Selects all text in the control. */
PHP_METHOD(php_wxTextEntry, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::SelectAll()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->SelectAll();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->SelectAll();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Replace(int from, int to, string value)
   Replaces the text starting at the first position up to (but not including) the character at the last position with the given text. */
PHP_METHOD(php_wxTextEntry, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Replace\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&from0, &to0, &value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Replace((long) from0, (long) to0, wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Replace\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Remove(int from, int to)
   Removes the text starting at the first given position up to (but not including) the character at the last position. */
PHP_METHOD(php_wxTextEntry, Remove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Remove\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Remove\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Remove((long) from0, (long) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Remove((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Remove((long) from0, (long) to0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Remove\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Redo()
   If there is a redo facility and the last operation can be redone, redoes the last operation. */
PHP_METHOD(php_wxTextEntry, Redo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Redo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Redo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Redo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->Redo();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Redo();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Redo\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Paste()
   Pastes text from the clipboard to the text item. */
PHP_METHOD(php_wxTextEntry, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Paste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Paste()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Paste();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Paste();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Paste\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::IsEditable()
   Returns true if the controls contents may be edited by user (note that it always can be changed by the program). */
PHP_METHOD(php_wxTextEntry, IsEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::IsEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::IsEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::IsEditable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->IsEditable());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->IsEditable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::IsEditable\n");
	}
}
/* }}} */

/* {{{ proto string wxTextEntry::GetValue()
   Gets the contents of the control. */
PHP_METHOD(php_wxTextEntry, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetValue().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetValue();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetValue();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetValue\n");
	}
}
/* }}} */

/* {{{ proto string wxTextEntry::GetStringSelection()
   Gets the text currently selected in the control. */
PHP_METHOD(php_wxTextEntry, GetStringSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetStringSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetStringSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetStringSelection().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					value_to_return0 = ((wxComboCtrl_php*)_this)->GetStringSelection();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetStringSelection();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetStringSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::GetSelection(int &from, int &to)
   Gets the current selection span. */
PHP_METHOD(php_wxTextEntry, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* from0;
	zval* from0_ref;
	long* to0;
	zval* to0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (from0, to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, from0, to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &from0_ref, &to0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::GetSelection((long*) from0, (long*) to0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->GetSelection((long*) from0, (long*) to0);
				}

				size_t elements_returned0_0 = sizeof(from0)/sizeof(*from0);
				array_init(from0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(from0_ref, from0[i]);
				}
				size_t elements_returned0_1 = sizeof(to0)/sizeof(*to0);
				array_init(to0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(to0_ref, to0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto string wxTextEntry::GetRange(int from, int to)
   Returns the string containing the text starting in the positions from and up to to in the control. */
PHP_METHOD(php_wxTextEntry, GetRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetRange((long) from0, (long) to0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return2;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return2 = ((wxTextCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return2 = ((wxSearchCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return2 = ((wxComboBox_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return2 = ((wxBitmapComboBox_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					value_to_return2 = ((wxComboCtrl_php*)_this)->GetRange((long) from0, (long) to0);
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return2 = ((wxTextEntry_php*)_this)->GetRange((long) from0, (long) to0);
				}
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetRange\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxTextEntry::GetMargins()
   Returns the margins used by the control. */
PHP_METHOD(php_wxTextEntry, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetMargins();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetMargins\n");
	}
}
/* }}} */

/* {{{ proto int wxTextEntry::GetLastPosition()
   Returns the zero based index of the last position in the text control, which is equal to the number of characters in the control. */
PHP_METHOD(php_wxTextEntry, GetLastPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetLastPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetLastPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextEntry::GetLastPosition())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_LONG(return_value, ((wxSearchCtrl_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_LONG(return_value, ((wxComboBox_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_LONG(return_value, ((wxBitmapComboBox_php*)_this)->GetLastPosition());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_LONG(return_value, ((wxTextEntry_php*)_this)->GetLastPosition());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetLastPosition\n");
	}
}
/* }}} */

/* {{{ proto int wxTextEntry::GetInsertionPoint()
   Returns the insertion point, or cursor, position. */
PHP_METHOD(php_wxTextEntry, GetInsertionPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetInsertionPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetInsertionPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextEntry::GetInsertionPoint())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_LONG(return_value, ((wxTextCtrl_php*)_this)->GetInsertionPoint());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_LONG(return_value, ((wxSearchCtrl_php*)_this)->GetInsertionPoint());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_LONG(return_value, ((wxTextEntry_php*)_this)->GetInsertionPoint());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetInsertionPoint\n");
	}
}
/* }}} */

/* {{{ proto string wxTextEntry::GetHint()
   Returns the current hint string. */
PHP_METHOD(php_wxTextEntry, GetHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::GetHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::GetHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextEntry::GetHint().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					value_to_return0 = ((wxTextCtrl_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					value_to_return0 = ((wxSearchCtrl_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					value_to_return0 = ((wxComboBox_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					value_to_return0 = ((wxBitmapComboBox_php*)_this)->GetHint();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					value_to_return0 = ((wxTextEntry_php*)_this)->GetHint();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::GetHint\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Copy()
   Copies the selected text to the clipboard. */
PHP_METHOD(php_wxTextEntry, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Copy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Copy()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Copy();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Copy();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Copy\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::Clear()
   Clears the text in the control. */
PHP_METHOD(php_wxTextEntry, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::Clear()\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->Clear();
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->Clear();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::ChangeValue(string value)
   Sets the new text control value. */
PHP_METHOD(php_wxTextEntry, ChangeValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::ChangeValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::ChangeValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::ChangeValue(wxString(value0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->ChangeValue(wxString(value0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::ChangeValue\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::CanUndo()
   Returns true if there is an undo facility available and the last operation can be undone. */
PHP_METHOD(php_wxTextEntry, CanUndo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanUndo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanUndo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanUndo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanUndo());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanUndo());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::CanUndo\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::CanRedo()
   Returns true if there is a redo facility available and the last operation can be redone. */
PHP_METHOD(php_wxTextEntry, CanRedo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanRedo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanRedo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanRedo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanRedo());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanRedo());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::CanRedo\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::CanPaste()
   Returns true if the contents of the clipboard can be pasted into the text control. */
PHP_METHOD(php_wxTextEntry, CanPaste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanPaste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanPaste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanPaste())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanPaste());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanPaste());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::CanPaste\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::CanCut()
   Returns true if the selection can be cut to the clipboard. */
PHP_METHOD(php_wxTextEntry, CanCut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanCut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanCut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanCut())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanCut());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanCut());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::CanCut\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::CanCopy()
   Returns true if the selection can be copied to the clipboard. */
PHP_METHOD(php_wxTextEntry, CanCopy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::CanCopy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::CanCopy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::CanCopy())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->CanCopy());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->CanCopy());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::CanCopy\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::AutoCompleteFileNames()
   Call this function to enable auto-completion of the text typed in a single-line text control using all valid file system paths. */
PHP_METHOD(php_wxTextEntry, AutoCompleteFileNames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoCompleteFileNames\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoCompleteFileNames\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoCompleteFileNames())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoCompleteFileNames());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoCompleteFileNames());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::AutoCompleteFileNames\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::AutoCompleteDirectories()
   Call this function to enable auto-completion of the text using the file system directories. */
PHP_METHOD(php_wxTextEntry, AutoCompleteDirectories)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoCompleteDirectories\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoCompleteDirectories\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoCompleteDirectories())\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoCompleteDirectories());
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoCompleteDirectories());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::AutoCompleteDirectories\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextEntry::AutoComplete(wxTextCompleter &completer)
   Enable auto-completion using the provided completer object. */
PHP_METHOD(php_wxTextEntry, AutoComplete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AutoComplete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AutoComplete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* completer0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* choices1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&completer0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &completer0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(completer0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(completer0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxTextCompleterSimple))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(completer0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&choices1)\n");
		#endif
		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &choices1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoComplete((wxTextCompleter*) object_pointer0_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoComplete((wxTextCompleter*) object_pointer0_0));
				}

				references->AddReference(completer0, "wxTextEntry::AutoComplete at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(choices1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextEntry::AutoComplete(strings_array1_0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					ZVAL_BOOL(return_value, ((wxTextCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					ZVAL_BOOL(return_value, ((wxSearchCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					ZVAL_BOOL(return_value, ((wxComboBox_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					ZVAL_BOOL(return_value, ((wxBitmapComboBox_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					ZVAL_BOOL(return_value, ((wxComboCtrl_php*)_this)->AutoComplete(strings_array1_0));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					ZVAL_BOOL(return_value, ((wxTextEntry_php*)_this)->AutoComplete(strings_array1_0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::AutoComplete\n");
	}
}
/* }}} */

/* {{{ proto  wxTextEntry::AppendText(string text)
   Appends the text to the end of the text control. */
PHP_METHOD(php_wxTextEntry, AppendText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextEntry::AppendText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTextEntry::AppendText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTextEntry){
				references = &((wxTextEntry_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxTextCtrl) && (!reference_type_found)){
				references = &((wxTextCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSearchCtrl) && (!reference_type_found)){
				references = &((wxSearchCtrl_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboBox) && (!reference_type_found)){
				references = &((wxComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapComboBox) && (!reference_type_found)){
				references = &((wxBitmapComboBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxComboCtrl) && (!reference_type_found)){
				references = &((wxComboCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextEntry::AppendText(wxString(text0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxTextCtrl)
				{
					((wxTextCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxSearchCtrl)
				{
					((wxSearchCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboBox)
				{
					((wxComboBox_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxBitmapComboBox)
				{
					((wxBitmapComboBox_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxComboCtrl)
				{
					((wxComboCtrl_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}
				else if(parent_rsrc_type == le_wxTextEntry)
				{
					((wxTextEntry_php*)_this)->AppendText(wxString(text0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextEntry::AppendText\n");
	}
}
/* }}} */

void php_wxToggleButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxToggleButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxToggleButton::Create(wxWindow &parent, int id, string label, wxPoint pos, wxSize size, int style, wxValidator val, string name)
   Creates the toggle button for two-step construction. */
PHP_METHOD(php_wxToggleButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* label0;
	long label_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* val0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, &label_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8)));

				references->AddReference(parent0, "wxToggleButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxToggleButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxToggleButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxToggleButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxToggleButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxToggleButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxToggleButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxToggleButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxToggleButton::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxToggleButton::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxToggleButton::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxToggleButton::Create at call with 7 argument(s)");
				references->AddReference(val0, "wxToggleButton::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(label0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxToggleButton::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxToggleButton::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxToggleButton::Create at call with 8 argument(s)");
				references->AddReference(val0, "wxToggleButton::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToggleButton::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxToggleButton::GetValue()
   Gets the state of the toggle button. */
PHP_METHOD(php_wxToggleButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToggleButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxToggleButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToggleButton::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxToggleButton::SetValue(bool state)
   Sets the toggle button to the given state. */
PHP_METHOD(php_wxToggleButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxToggleButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxToggleButton){
				references = &((wxToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxBitmapToggleButton) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToggleButton::SetValue(state0)\n\n");
				#endif
				((wxToggleButton_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToggleButton::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxToggleButton::wxToggleButton()
   Default constructor. */
PHP_METHOD(php_wxToggleButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToggleButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	char* label1;
	long label_len1;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* val1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zls|OOlOs' (&parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zls|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, &label_len1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxToggleButton_php();

				((wxToggleButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8))\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8));

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 4 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(pos1, "wxToggleButton::wxToggleButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 5 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(pos1, "wxToggleButton::wxToggleButton at call with 5 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(size1, "wxToggleButton::wxToggleButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 6 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(pos1, "wxToggleButton::wxToggleButton at call with 6 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(size1, "wxToggleButton::wxToggleButton at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 7 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(pos1, "wxToggleButton::wxToggleButton at call with 7 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(size1, "wxToggleButton::wxToggleButton at call with 7 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(val1, "wxToggleButton::wxToggleButton at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, wxString(label1, wxConvUTF8), *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxToggleButton_php*) _this)->references.Initialize();
				((wxToggleButton_php*) _this)->references.AddReference(parent1, "wxToggleButton::wxToggleButton at call with 8 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(pos1, "wxToggleButton::wxToggleButton at call with 8 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(size1, "wxToggleButton::wxToggleButton at call with 8 argument(s)");
				((wxToggleButton_php*) _this)->references.AddReference(val1, "wxToggleButton::wxToggleButton at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxToggleButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxToggleButton_php*) _this)->phpObj = getThis();
		
		((wxToggleButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxToggleButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxToggleButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxBitmapToggleButton_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxBitmapToggleButton_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxBitmapToggleButton::Create(wxWindow &parent, int id, wxBitmap label, wxPoint pos, wxSize size, int style, wxValidator val, string name)
   Create method for two-step construction. */
PHP_METHOD(php_wxBitmapToggleButton, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* label0 = 0;
	void* object_pointer0_2 = 0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	zval* val0 = 0;
	void* object_pointer0_6 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &label0, php_wxBitmap_entry, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &val0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 3 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 4 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxBitmapToggleButton::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 5 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxBitmapToggleButton::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxBitmapToggleButton::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 6 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxBitmapToggleButton::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxBitmapToggleButton::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 7 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxBitmapToggleButton::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxBitmapToggleButton::Create at call with 7 argument(s)");
				references->AddReference(val0, "wxBitmapToggleButton::Create at call with 7 argument(s)");

				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxBitmap*) object_pointer0_2, *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, *(wxValidator*) object_pointer0_6, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxBitmapToggleButton::Create at call with 8 argument(s)");
				references->AddReference(label0, "wxBitmapToggleButton::Create at call with 8 argument(s)");
				references->AddReference(pos0, "wxBitmapToggleButton::Create at call with 8 argument(s)");
				references->AddReference(size0, "wxBitmapToggleButton::Create at call with 8 argument(s)");
				references->AddReference(val0, "wxBitmapToggleButton::Create at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapToggleButton::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmapToggleButton::GetValue()
   Gets the state of the toggle button. */
PHP_METHOD(php_wxBitmapToggleButton, GetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::GetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapToggleButton::GetValue())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxBitmapToggleButton_php*)_this)->GetValue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapToggleButton::GetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapToggleButton::SetValue(bool state)
   Sets the toggle button to the given state. */
PHP_METHOD(php_wxBitmapToggleButton, SetValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxBitmapToggleButton::SetValue\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxBitmapToggleButton){
				references = &((wxBitmapToggleButton_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&state0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapToggleButton::SetValue(state0)\n\n");
				#endif
				((wxBitmapToggleButton_php*)_this)->SetValue(state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapToggleButton::SetValue\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapToggleButton::wxBitmapToggleButton()
   Default constructor. */
PHP_METHOD(php_wxBitmapToggleButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapToggleButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* label1 = 0;
	void* object_pointer1_2 = 0;
	zval* pos1 = 0;
	void* object_pointer1_3 = 0;
	zval* size1 = 0;
	void* object_pointer1_4 = 0;
	long style1;
	zval* val1 = 0;
	void* object_pointer1_6 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zlO|OOlOs' (&parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "zlO|OOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &label1, php_wxBitmap_entry, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &val1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(label1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(label1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(label1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 7){
				if(Z_TYPE_P(val1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(val1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_6 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_6 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(val1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxBitmapToggleButton_php();

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 3 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 4 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 4 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 5 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 5 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 5 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 6 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 6 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 6 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6)\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6);

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 7 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 7 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 7 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 7 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(val1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 7 argument(s)");
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxBitmapToggleButton_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxBitmap*) object_pointer1_2, *(wxPoint*) object_pointer1_3, *(wxSize*) object_pointer1_4, (long) style1, *(wxValidator*) object_pointer1_6, wxString(name1, wxConvUTF8));

				((wxBitmapToggleButton_php*) _this)->references.Initialize();
				((wxBitmapToggleButton_php*) _this)->references.AddReference(parent1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 8 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(label1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 8 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(pos1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 8 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(size1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 8 argument(s)");
				((wxBitmapToggleButton_php*) _this)->references.AddReference(val1, "wxBitmapToggleButton::wxBitmapToggleButton at call with 8 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxBitmapToggleButton);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxBitmapToggleButton_php*) _this)->phpObj = getThis();
		
		((wxBitmapToggleButton_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxBitmapToggleButton_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmapToggleButton::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

void php_wxTreeCtrl_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxTreeCtrl_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto  wxTreeCtrl::wxTreeCtrl()
   Default Constructor. */
PHP_METHOD(php_wxTreeCtrl, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	void* object_pointer1_2 = 0;
	zval* size1 = 0;
	void* object_pointer1_3 = 0;
	long style1;
	zval* validator1 = 0;
	void* object_pointer1_5 = 0;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOlOs' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1)\n");
		#endif
		char parse_parameters_string[] = "z|lOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &validator1, php_wxValidator_entry, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxTreeCtrl_php();

				((wxTreeCtrl_php*) _this)->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 3 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1, "wxTreeCtrl::wxTreeCtrl at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 4 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1, "wxTreeCtrl::wxTreeCtrl at call with 4 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(size1, "wxTreeCtrl::wxTreeCtrl at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 5 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1, "wxTreeCtrl::wxTreeCtrl at call with 5 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(size1, "wxTreeCtrl::wxTreeCtrl at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5)\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5);

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 6 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1, "wxTreeCtrl::wxTreeCtrl at call with 6 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(size1, "wxTreeCtrl::wxTreeCtrl at call with 6 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(validator1, "wxTreeCtrl::wxTreeCtrl at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8))\n");
				#endif
				_this = new wxTreeCtrl_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, *(wxValidator*) object_pointer1_5, wxString(name1, wxConvUTF8));

				((wxTreeCtrl_php*) _this)->references.Initialize();
				((wxTreeCtrl_php*) _this)->references.AddReference(parent1, "wxTreeCtrl::wxTreeCtrl at call with 7 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(pos1, "wxTreeCtrl::wxTreeCtrl at call with 7 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(size1, "wxTreeCtrl::wxTreeCtrl at call with 7 argument(s)");
				((wxTreeCtrl_php*) _this)->references.AddReference(validator1, "wxTreeCtrl::wxTreeCtrl at call with 7 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxTreeCtrl);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxTreeCtrl_php*) _this)->phpObj = getThis();
		
		((wxTreeCtrl_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxTreeCtrl_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTreeCtrl::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::AddRoot(string text, int image, int selImage, wxTreeItemData &data)
   Adds the root node to the tree, returning the new item. */
PHP_METHOD(php_wxTreeCtrl, AddRoot)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AddRoot\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AddRoot\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|llz' (&text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "s|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 4){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_3) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->AddRoot(wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_3);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(data0, "wxTreeCtrl::AddRoot at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::AddRoot\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::AppendItem(wxTreeItemId parent, string text, int image, int selImage, wxTreeItemData &data)
   Appends an item to the end of the branch identified by parent, return a new item id. */
PHP_METHOD(php_wxTreeCtrl, AppendItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AppendItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AppendItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::AppendItem at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::AppendItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::AppendItem at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->AppendItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::AppendItem at call with 5 argument(s)");
				references->AddReference(data0, "wxTreeCtrl::AppendItem at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::AppendItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::AssignImageList(wxImageList &imageList)
   Sets the normal image list. */
PHP_METHOD(php_wxTreeCtrl, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AssignImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->AssignImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeCtrl::AssignImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::AssignImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::AssignStateImageList(wxImageList &imageList)
   Sets the state image list. */
PHP_METHOD(php_wxTreeCtrl, AssignStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::AssignStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::AssignStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::AssignStateImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->AssignStateImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeCtrl::AssignStateImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::AssignStateImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::ClearFocusedItem()
   Clears the currently focused item. */
PHP_METHOD(php_wxTreeCtrl, ClearFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ClearFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ClearFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ClearFocusedItem()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ClearFocusedItem();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ClearFocusedItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::Collapse(wxTreeItemId item)
   Collapses the given item. */
PHP_METHOD(php_wxTreeCtrl, Collapse)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Collapse\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Collapse\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Collapse(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Collapse(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::Collapse at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Collapse\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::CollapseAll()
   Collapses the root item. */
PHP_METHOD(php_wxTreeCtrl, CollapseAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::CollapseAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::CollapseAllChildren(wxTreeItemId item)
   Collapses this item and all of its children, recursively. */
PHP_METHOD(php_wxTreeCtrl, CollapseAllChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAllChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAllChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAllChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAllChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::CollapseAllChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::CollapseAllChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::CollapseAndReset(wxTreeItemId item)
   Collapses the given item and removes all children. */
PHP_METHOD(php_wxTreeCtrl, CollapseAndReset)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::CollapseAndReset\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::CollapseAndReset\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::CollapseAndReset(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->CollapseAndReset(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::CollapseAndReset at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::CollapseAndReset\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, wxValidator validator, string name)
   Creates the tree control. */
PHP_METHOD(php_wxTreeCtrl, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	zval* validator0 = 0;
	void* object_pointer0_5 = 0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOlOs' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOlOs";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &validator0, php_wxValidator_entry, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(validator0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(validator0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(validator0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxTreeCtrl::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxTreeCtrl::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxTreeCtrl::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxTreeCtrl::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxTreeCtrl::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxTreeCtrl::Create at call with 6 argument(s)");
				references->AddReference(validator0, "wxTreeCtrl::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, *(wxValidator*) object_pointer0_5, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxTreeCtrl::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxTreeCtrl::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxTreeCtrl::Create at call with 7 argument(s)");
				references->AddReference(validator0, "wxTreeCtrl::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::Delete(wxTreeItemId item)
   Deletes the specified item. */
PHP_METHOD(php_wxTreeCtrl, Delete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Delete\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Delete\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Delete(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Delete(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::Delete at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Delete\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::DeleteAllItems()
   Deletes all items in the control. */
PHP_METHOD(php_wxTreeCtrl, DeleteAllItems)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::DeleteAllItems\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::DeleteAllItems\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::DeleteAllItems()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->DeleteAllItems();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::DeleteAllItems\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::DeleteChildren(wxTreeItemId item)
   Deletes all children of the given item (but not the item itself). */
PHP_METHOD(php_wxTreeCtrl, DeleteChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::DeleteChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::DeleteChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::DeleteChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->DeleteChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::DeleteChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::DeleteChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::EndEditLabel(wxTreeItemId item, bool discardChanges)
   Ends label editing. */
PHP_METHOD(php_wxTreeCtrl, EndEditLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::EndEditLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::EndEditLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool discardChanges0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &discardChanges0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &discardChanges0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EndEditLabel(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EndEditLabel(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::EndEditLabel at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EndEditLabel(*(wxTreeItemId*) object_pointer0_0, discardChanges0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EndEditLabel(*(wxTreeItemId*) object_pointer0_0, discardChanges0);

				references->AddReference(item0, "wxTreeCtrl::EndEditLabel at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::EndEditLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::EnsureVisible(wxTreeItemId item)
   Scrolls and/or expands items to ensure that the given item is visible. */
PHP_METHOD(php_wxTreeCtrl, EnsureVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::EnsureVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::EnsureVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::EnsureVisible(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->EnsureVisible(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::EnsureVisible at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::EnsureVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::Expand(wxTreeItemId item)
   Expands the given item. */
PHP_METHOD(php_wxTreeCtrl, Expand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Expand\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Expand\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Expand(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Expand(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::Expand at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Expand\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::ExpandAll()
   Expands all items in the tree. */
PHP_METHOD(php_wxTreeCtrl, ExpandAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ExpandAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ExpandAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ExpandAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ExpandAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ExpandAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::ExpandAllChildren(wxTreeItemId item)
   Expands the given item and all its children recursively. */
PHP_METHOD(php_wxTreeCtrl, ExpandAllChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ExpandAllChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ExpandAllChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ExpandAllChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ExpandAllChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::ExpandAllChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ExpandAllChildren\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::GetBoundingRect(wxTreeItemId item, wxRect &rect, bool textOnly)
   Retrieves the rectangle bounding the item. */
PHP_METHOD(php_wxTreeCtrl, GetBoundingRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetBoundingRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetBoundingRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* rect0 = 0;
	void* object_pointer0_1 = 0;
	bool textOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|b' (&item0, php_wxTreeItemId_entry, &rect0, php_wxRect_entry, &textOnly0)\n");
		#endif
		char parse_parameters_string[] = "OO|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &rect0, php_wxRect_entry, &textOnly0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1));

				references->AddReference(item0, "wxTreeCtrl::GetBoundingRect at call with 2 argument(s)");
				references->AddReference(rect0, "wxTreeCtrl::GetBoundingRect at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1, textOnly0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetBoundingRect(*(wxTreeItemId*) object_pointer0_0, *(wxRect*) object_pointer0_1, textOnly0));

				references->AddReference(item0, "wxTreeCtrl::GetBoundingRect at call with 3 argument(s)");
				references->AddReference(rect0, "wxTreeCtrl::GetBoundingRect at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetBoundingRect\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeCtrl::GetChildrenCount(wxTreeItemId item, bool recursively)
   Returns the number of items in the branch. */
PHP_METHOD(php_wxTreeCtrl, GetChildrenCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetChildrenCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetChildrenCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool recursively0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &recursively0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &recursively0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetChildrenCount(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetChildrenCount(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::GetChildrenCount at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetChildrenCount(*(wxTreeItemId*) object_pointer0_0, recursively0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetChildrenCount(*(wxTreeItemId*) object_pointer0_0, recursively0));

				references->AddReference(item0, "wxTreeCtrl::GetChildrenCount at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetChildrenCount\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeCtrl::GetCount()
   Returns the number of items in the control. */
PHP_METHOD(php_wxTreeCtrl, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetCount\n");
	}
}
/* }}} */

/* {{{ proto wxTextCtrl wxTreeCtrl::GetEditControl()
   Returns the edit control being currently used to edit a label. */
PHP_METHOD(php_wxTreeCtrl, GetEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetEditControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetEditControl() to return object pointer\n\n");
				#endif
				wxTextCtrl_php* value_to_return0;
				value_to_return0 = (wxTextCtrl_php*) ((wxTreeCtrl_php*)_this)->GetEditControl();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTextCtrl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxTextCtrl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeCtrl::GetEditControl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetEditControl\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetFirstVisibleItem()
   Returns the first visible item. */
PHP_METHOD(php_wxTreeCtrl, GetFirstVisibleItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetFirstVisibleItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetFirstVisibleItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetFirstVisibleItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetFirstVisibleItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetFirstVisibleItem\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetFocusedItem()
   Returns the item last clicked or otherwise selected. */
PHP_METHOD(php_wxTreeCtrl, GetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetFocusedItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetFocusedItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetFocusedItem\n");
	}
}
/* }}} */

/* {{{ proto wxImageList wxTreeCtrl::GetImageList()
   Returns the normal image list. */
PHP_METHOD(php_wxTreeCtrl, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxTreeCtrl_php*)_this)->GetImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeCtrl::GetImageList at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetImageList\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeCtrl::GetIndent()
   Returns the current tree control indentation. */
PHP_METHOD(php_wxTreeCtrl, GetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetIndent())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetIndent\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxTreeCtrl::GetItemBackgroundColour(wxTreeItemId item)
   Returns the background colour of the item. */
PHP_METHOD(php_wxTreeCtrl, GetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));

				references->AddReference(item0, "wxTreeCtrl::GetItemBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemData wxTreeCtrl::GetItemData(wxTreeItemId item)
   Returns the tree item data associated with the item. */
PHP_METHOD(php_wxTreeCtrl, GetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemData(*(wxTreeItemId*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxTreeItemData_php* value_to_return1;
				value_to_return1 = (wxTreeItemData_php*) ((wxTreeCtrl_php*)_this)->GetItemData(*(wxTreeItemId*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxTreeItemData_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxTreeItemData));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeCtrl::GetItemData at call with 1 argument(s)");
				}

				references->AddReference(item0, "wxTreeCtrl::GetItemData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemData\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxTreeCtrl::GetItemFont(wxTreeItemId item)
   Returns the font of the item label. */
PHP_METHOD(php_wxTreeCtrl, GetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemFont(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxFont value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemFont(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxFont));

				references->AddReference(item0, "wxTreeCtrl::GetItemFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemFont\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeCtrl::GetItemImage(wxTreeItemId item, wxTreeItemIcon which)
   Gets the specified item image. */
PHP_METHOD(php_wxTreeCtrl, GetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&item0, php_wxTreeItemId_entry, &which0)\n");
		#endif
		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemImage(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemImage(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::GetItemImage at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemImage(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemIcon) which0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemImage(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemIcon) which0));

				references->AddReference(item0, "wxTreeCtrl::GetItemImage at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemImage\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetItemParent(wxTreeItemId item)
   Returns the item's parent. */
PHP_METHOD(php_wxTreeCtrl, GetItemParent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemParent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemParent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemParent(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemParent(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetItemParent at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemParent\n");
	}
}
/* }}} */

/* {{{ proto int wxTreeCtrl::GetItemState(wxTreeItemId item)
   Gets the specified item state. */
PHP_METHOD(php_wxTreeCtrl, GetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTreeCtrl::GetItemState(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxTreeCtrl_php*)_this)->GetItemState(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::GetItemState at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemState\n");
	}
}
/* }}} */

/* {{{ proto string wxTreeCtrl::GetItemText(wxTreeItemId item)
   Returns the item label. */
PHP_METHOD(php_wxTreeCtrl, GetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTreeCtrl::GetItemText(*(wxTreeItemId*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemText(*(wxTreeItemId*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(item0, "wxTreeCtrl::GetItemText at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemText\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxTreeCtrl::GetItemTextColour(wxTreeItemId item)
   Returns the colour of the item label. */
PHP_METHOD(php_wxTreeCtrl, GetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetItemTextColour(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxColour value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetItemTextColour(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxColour));

				references->AddReference(item0, "wxTreeCtrl::GetItemTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetItemTextColour\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetLastChild(wxTreeItemId item)
   Returns the last child of the item (or an invalid tree item if this item has no children). */
PHP_METHOD(php_wxTreeCtrl, GetLastChild)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetLastChild\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetLastChild\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetLastChild(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetLastChild(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetLastChild at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetLastChild\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetNextSibling(wxTreeItemId item)
   Returns the next sibling of the specified item; call GetPrevSibling() for the previous sibling. */
PHP_METHOD(php_wxTreeCtrl, GetNextSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetNextSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetNextSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetNextSibling(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetNextSibling(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetNextSibling at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetNextSibling\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetNextVisible(wxTreeItemId item)
   Returns the next visible item or an invalid item if this item is the last visible one. */
PHP_METHOD(php_wxTreeCtrl, GetNextVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetNextVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetNextVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetNextVisible(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetNextVisible(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetNextVisible at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetNextVisible\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetPrevSibling(wxTreeItemId item)
   Returns the previous sibling of the specified item; call GetNextSibling() for the next sibling. */
PHP_METHOD(php_wxTreeCtrl, GetPrevSibling)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetPrevSibling\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetPrevSibling\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetPrevSibling(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetPrevSibling(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetPrevSibling at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetPrevSibling\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetPrevVisible(wxTreeItemId item)
   Returns the previous visible item or an invalid item if this item is the first visible one. */
PHP_METHOD(php_wxTreeCtrl, GetPrevVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetPrevVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetPrevVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetPrevVisible(*(wxTreeItemId*) object_pointer0_0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return1;
				value_to_return1 = ((wxTreeCtrl_php*)_this)->GetPrevVisible(*(wxTreeItemId*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(item0, "wxTreeCtrl::GetPrevVisible at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetPrevVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::GetQuickBestSize()
   Returns true if the control will use a quick calculation for the best size, looking only at the first and last items. */
PHP_METHOD(php_wxTreeCtrl, GetQuickBestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetQuickBestSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetQuickBestSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::GetQuickBestSize())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->GetQuickBestSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetQuickBestSize\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetRootItem()
   Returns the root item for the tree control. */
PHP_METHOD(php_wxTreeCtrl, GetRootItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetRootItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetRootItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetRootItem() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetRootItem();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetRootItem\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::GetSelection()
   Returns the selection, or an invalid item if there is no selection. */
PHP_METHOD(php_wxTreeCtrl, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetSelection() to return new object\n\n");
				#endif
				wxTreeItemId value_to_return0;
				value_to_return0 = ((wxTreeCtrl_php*)_this)->GetSelection();
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto wxImageList wxTreeCtrl::GetStateImageList()
   Returns the state image list (from which application-defined state images are taken). */
PHP_METHOD(php_wxTreeCtrl, GetStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::GetStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::GetStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::GetStateImageList() to return object pointer\n\n");
				#endif
				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxTreeCtrl_php*)_this)->GetStateImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImageList_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxImageList));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value, "wxTreeCtrl::GetStateImageList at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::GetStateImageList\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::HitTest(wxPoint point, int &flags)
   Calculates which (if any) item is under the given point, returning the tree item id at this point plus extra information flags. */
PHP_METHOD(php_wxTreeCtrl, HitTest)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::HitTest\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::HitTest\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* point0 = 0;
	void* object_pointer0_0 = 0;
	long flags0;
	zval* flags0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&point0, php_wxPoint_entry, &flags0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point0, php_wxPoint_entry, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(point0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(point0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(point0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &flags0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::HitTest(*(wxPoint*) object_pointer0_0, (int&) flags0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->HitTest(*(wxPoint*) object_pointer0_0, (int&) flags0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(point0, "wxTreeCtrl::HitTest at call with 2 argument(s)");
				ZVAL_LONG(flags0_ref, flags0);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::HitTest\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::InsertItem(wxTreeItemId parent, wxTreeItemId previous, string text, int image, int selImage, wxTreeItemData &data)
   Inserts an item after a given one (previous). */
PHP_METHOD(php_wxTreeCtrl, InsertItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::InsertItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::InsertItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	zval* previous0 = 0;
	void* object_pointer0_1 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_5 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	void* object_pointer1_0 = 0;
	long before1;
	char* text1;
	long text_len1;
	long image1;
	long selImage1;
	zval* data1 = 0;
	void* object_pointer1_5 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOs|llz' (&parent0, php_wxTreeItemId_entry, &previous0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "OOs|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &previous0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(previous0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(previous0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(previous0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_5 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ols|llz' (&parent1, php_wxTreeItemId_entry, &before1, &text1, &text_len1, &image1, &selImage1, &data1)\n");
		#endif
		char parse_parameters_string[] = "Ols|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, php_wxTreeItemId_entry, &before1, &text1, &text_len1, &image1, &selImage1, &data1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 6){
				if(Z_TYPE_P(data1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_5 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_5 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::InsertItem at call with 3 argument(s)");
				references->AddReference(previous0, "wxTreeCtrl::InsertItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::InsertItem at call with 4 argument(s)");
				references->AddReference(previous0, "wxTreeCtrl::InsertItem at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::InsertItem at call with 5 argument(s)");
				references->AddReference(previous0, "wxTreeCtrl::InsertItem at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_5) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return6;
				value_to_return6 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer0_0, *(wxTreeItemId*) object_pointer0_1, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::InsertItem at call with 6 argument(s)");
				references->AddReference(previous0, "wxTreeCtrl::InsertItem at call with 6 argument(s)");
				references->AddReference(data0, "wxTreeCtrl::InsertItem at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1, "wxTreeCtrl::InsertItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1, "wxTreeCtrl::InsertItem at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1, "wxTreeCtrl::InsertItem at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1, (wxTreeItemData*) object_pointer1_5) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return6;
				value_to_return6 = ((wxTreeCtrl_php*)_this)->InsertItem(*(wxTreeItemId*) object_pointer1_0, (size_t) before1, wxString(text1, wxConvUTF8), (int) image1, (int) selImage1, (wxTreeItemData*) object_pointer1_5);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return6, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent1, "wxTreeCtrl::InsertItem at call with 6 argument(s)");
				references->AddReference(data1, "wxTreeCtrl::InsertItem at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::InsertItem\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::IsBold(wxTreeItemId item)
   Returns true if the given item is in bold state. */
PHP_METHOD(php_wxTreeCtrl, IsBold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsBold\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsBold\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsBold(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsBold(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::IsBold at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::IsBold\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::IsEmpty()
   Returns true if the control is empty (i.e. */
PHP_METHOD(php_wxTreeCtrl, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsEmpty\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsEmpty())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::IsEmpty\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::IsExpanded(wxTreeItemId item)
   Returns true if the item is expanded (only makes sense if it has children). */
PHP_METHOD(php_wxTreeCtrl, IsExpanded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsExpanded\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsExpanded\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsExpanded(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsExpanded(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::IsExpanded at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::IsExpanded\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::IsSelected(wxTreeItemId item)
   Returns true if the item is selected. */
PHP_METHOD(php_wxTreeCtrl, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsSelected(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsSelected(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::IsSelected at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::IsVisible(wxTreeItemId item)
   Returns true if the item is visible on the screen. */
PHP_METHOD(php_wxTreeCtrl, IsVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::IsVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::IsVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::IsVisible(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->IsVisible(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::IsVisible at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::IsVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxTreeCtrl::ItemHasChildren(wxTreeItemId item)
   Returns true if the item has children. */
PHP_METHOD(php_wxTreeCtrl, ItemHasChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ItemHasChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ItemHasChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeCtrl::ItemHasChildren(*(wxTreeItemId*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxTreeCtrl_php*)_this)->ItemHasChildren(*(wxTreeItemId*) object_pointer0_0));

				references->AddReference(item0, "wxTreeCtrl::ItemHasChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ItemHasChildren\n");
	}
}
/* }}} */

/* {{{ proto wxTreeItemId wxTreeCtrl::PrependItem(wxTreeItemId parent, string text, int image, int selImage, wxTreeItemData &data)
   Appends an item as the first child of parent, return a new item id. */
PHP_METHOD(php_wxTreeCtrl, PrependItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::PrependItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::PrependItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	long image0;
	long selImage0;
	zval* data0 = 0;
	void* object_pointer0_4 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os|llz' (&parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0)\n");
		#endif
		char parse_parameters_string[] = "Os|llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry, &text0, &text_len0, &image0, &selImage0, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8)) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return2;
				value_to_return2 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::PrependItem at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return3;
				value_to_return3 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::PrependItem at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return4;
				value_to_return4 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::PrependItem at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4) to return new object\n\n");
				#endif
				wxTreeItemId value_to_return5;
				value_to_return5 = ((wxTreeCtrl_php*)_this)->PrependItem(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8), (int) image0, (int) selImage0, (wxTreeItemData*) object_pointer0_4);
				void* ptr = safe_emalloc(1, sizeof(wxTreeItemId_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxTreeItemId));
				object_init_ex(return_value, php_wxTreeItemId_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxTreeItemId));

				references->AddReference(parent0, "wxTreeCtrl::PrependItem at call with 5 argument(s)");
				references->AddReference(data0, "wxTreeCtrl::PrependItem at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::PrependItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::ScrollTo(wxTreeItemId item)
   Scrolls the specified item into view. */
PHP_METHOD(php_wxTreeCtrl, ScrollTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ScrollTo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ScrollTo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ScrollTo(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ScrollTo(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::ScrollTo at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ScrollTo\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SelectChildren(wxTreeItemId parent)
   Select all the immediate children of the given parent. */
PHP_METHOD(php_wxTreeCtrl, SelectChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SelectChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SelectChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&parent0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(parent0, "wxTreeCtrl::SelectChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SelectChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SelectItem(wxTreeItemId item, bool select)
   Selects the given item. */
PHP_METHOD(php_wxTreeCtrl, SelectItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SelectItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SelectItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &select0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &select0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SelectItem at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SelectItem(*(wxTreeItemId*) object_pointer0_0, select0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SelectItem(*(wxTreeItemId*) object_pointer0_0, select0);

				references->AddReference(item0, "wxTreeCtrl::SelectItem at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SelectItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetFocusedItem(wxTreeItemId item)
   Sets the currently focused item. */
PHP_METHOD(php_wxTreeCtrl, SetFocusedItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetFocusedItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetFocusedItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetFocusedItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetFocusedItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SetFocusedItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetFocusedItem\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetImageList(wxImageList &imageList)
   Sets the normal image list. */
PHP_METHOD(php_wxTreeCtrl, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeCtrl::SetImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetIndent(int indent)
   Sets the indentation for the tree control. */
PHP_METHOD(php_wxTreeCtrl, SetIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetIndent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetIndent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetIndent((unsigned int) indent0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetIndent((unsigned int) indent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetIndent\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemBackgroundColour(wxTreeItemId item, wxColour col)
   Sets the colour of the item's background. */
PHP_METHOD(php_wxTreeCtrl, SetItemBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemBackgroundColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBackgroundColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(item0, "wxTreeCtrl::SetItemBackgroundColour at call with 2 argument(s)");
				references->AddReference(col0, "wxTreeCtrl::SetItemBackgroundColour at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemBold(wxTreeItemId item, bool bold)
   Makes item appear in bold font if bold parameter is true or resets it to the normal state. */
PHP_METHOD(php_wxTreeCtrl, SetItemBold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemBold\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemBold\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool bold0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &bold0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &bold0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBold(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBold(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SetItemBold at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemBold(*(wxTreeItemId*) object_pointer0_0, bold0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemBold(*(wxTreeItemId*) object_pointer0_0, bold0);

				references->AddReference(item0, "wxTreeCtrl::SetItemBold at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemBold\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemData(wxTreeItemId item, wxTreeItemData &data)
   Sets the item client data. */
PHP_METHOD(php_wxTreeCtrl, SetItemData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* data0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&item0, php_wxTreeItemId_entry, &data0)\n");
		#endif
		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(data0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(data0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemData(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemData*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemData(*(wxTreeItemId*) object_pointer0_0, (wxTreeItemData*) object_pointer0_1);

				references->AddReference(item0, "wxTreeCtrl::SetItemData at call with 2 argument(s)");
				references->AddReference(data0, "wxTreeCtrl::SetItemData at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemData\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemDropHighlight(wxTreeItemId item, bool highlight)
   Gives the item the visual feedback for Drag'n'Drop actions, which is useful if something is dragged from the outside onto the tree control (as opposed to a DnD operation within the tree control, which already is implemented internally). */
PHP_METHOD(php_wxTreeCtrl, SetItemDropHighlight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemDropHighlight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemDropHighlight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool highlight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &highlight0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &highlight0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SetItemDropHighlight at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0, highlight0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemDropHighlight(*(wxTreeItemId*) object_pointer0_0, highlight0);

				references->AddReference(item0, "wxTreeCtrl::SetItemDropHighlight at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemDropHighlight\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemFont(wxTreeItemId item, wxFont font)
   Sets the item's font. */
PHP_METHOD(php_wxTreeCtrl, SetItemFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* font0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemFont(*(wxTreeItemId*) object_pointer0_0, *(wxFont*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemFont(*(wxTreeItemId*) object_pointer0_0, *(wxFont*) object_pointer0_1);

				references->AddReference(item0, "wxTreeCtrl::SetItemFont at call with 2 argument(s)");
				references->AddReference(font0, "wxTreeCtrl::SetItemFont at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemFont\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemHasChildren(wxTreeItemId item, bool hasChildren)
   Force appearance of the button next to the item. */
PHP_METHOD(php_wxTreeCtrl, SetItemHasChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemHasChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemHasChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool hasChildren0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&item0, php_wxTreeItemId_entry, &hasChildren0)\n");
		#endif
		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &hasChildren0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SetItemHasChildren at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0, hasChildren0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemHasChildren(*(wxTreeItemId*) object_pointer0_0, hasChildren0);

				references->AddReference(item0, "wxTreeCtrl::SetItemHasChildren at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemHasChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemImage(wxTreeItemId item, int image, wxTreeItemIcon which)
   Sets the specified item's image. */
PHP_METHOD(php_wxTreeCtrl, SetItemImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long image0;
	long which0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|l' (&item0, php_wxTreeItemId_entry, &image0, &which0)\n");
		#endif
		char parse_parameters_string[] = "Ol|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &image0, &which0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0);

				references->AddReference(item0, "wxTreeCtrl::SetItemImage at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0, (wxTreeItemIcon) which0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemImage(*(wxTreeItemId*) object_pointer0_0, (int) image0, (wxTreeItemIcon) which0);

				references->AddReference(item0, "wxTreeCtrl::SetItemImage at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemImage\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemState(wxTreeItemId item, int state)
   Sets the specified item state. */
PHP_METHOD(php_wxTreeCtrl, SetItemState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&item0, php_wxTreeItemId_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemState(*(wxTreeItemId*) object_pointer0_0, (int) state0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemState(*(wxTreeItemId*) object_pointer0_0, (int) state0);

				references->AddReference(item0, "wxTreeCtrl::SetItemState at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemState\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemText(wxTreeItemId item, string text)
   Sets the item label. */
PHP_METHOD(php_wxTreeCtrl, SetItemText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&item0, php_wxTreeItemId_entry, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &text0, &text_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemText(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8))\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemText(*(wxTreeItemId*) object_pointer0_0, wxString(text0, wxConvUTF8));

				references->AddReference(item0, "wxTreeCtrl::SetItemText at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemText\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetItemTextColour(wxTreeItemId item, wxColour col)
   Sets the colour of the item's text. */
PHP_METHOD(php_wxTreeCtrl, SetItemTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetItemTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetItemTextColour\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	zval* col0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetItemTextColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetItemTextColour(*(wxTreeItemId*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				references->AddReference(item0, "wxTreeCtrl::SetItemTextColour at call with 2 argument(s)");
				references->AddReference(col0, "wxTreeCtrl::SetItemTextColour at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetItemTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetQuickBestSize(bool quickBestSize)
   If true is passed, specifies that the control will use a quick calculation for the best size, looking only at the first and last items. */
PHP_METHOD(php_wxTreeCtrl, SetQuickBestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetQuickBestSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetQuickBestSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool quickBestSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&quickBestSize0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &quickBestSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetQuickBestSize(quickBestSize0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetQuickBestSize(quickBestSize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetQuickBestSize\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetStateImageList(wxImageList &imageList)
   Sets the state image list (from which application-defined state images are taken). */
PHP_METHOD(php_wxTreeCtrl, SetStateImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetStateImageList\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetStateImageList\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(imageList0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetStateImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetStateImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxTreeCtrl::SetStateImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetStateImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SetWindowStyle(int styles)
   Sets the mode flags associated with the display of the tree control. */
PHP_METHOD(php_wxTreeCtrl, SetWindowStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SetWindowStyle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SetWindowStyle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long styles0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&styles0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &styles0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SetWindowStyle((long) styles0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SetWindowStyle((long) styles0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SetWindowStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::SortChildren(wxTreeItemId item)
   Sorts the children of the given item using OnCompareItems(). */
PHP_METHOD(php_wxTreeCtrl, SortChildren)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::SortChildren\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::SortChildren\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::SortChildren(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->SortChildren(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::SortChildren at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::SortChildren\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::Toggle(wxTreeItemId item)
   Toggles the given item between collapsed and expanded states. */
PHP_METHOD(php_wxTreeCtrl, Toggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Toggle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Toggle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Toggle(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Toggle(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::Toggle at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Toggle\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::ToggleItemSelection(wxTreeItemId item)
   Toggles the given item between selected and unselected states. */
PHP_METHOD(php_wxTreeCtrl, ToggleItemSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::ToggleItemSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::ToggleItemSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::ToggleItemSelection(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->ToggleItemSelection(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::ToggleItemSelection at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::ToggleItemSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::Unselect()
   Removes the selection from the currently selected item (if any). */
PHP_METHOD(php_wxTreeCtrl, Unselect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::Unselect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::Unselect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::Unselect()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->Unselect();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::Unselect\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::UnselectAll()
   This function either behaves the same as Unselect() if the control doesn't have wxTR_MULTIPLE style, or removes the selection from all items if it does have this style. */
PHP_METHOD(php_wxTreeCtrl, UnselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::UnselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::UnselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::UnselectAll()\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->UnselectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::UnselectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxTreeCtrl::UnselectItem(wxTreeItemId item)
   Unselects the given item. */
PHP_METHOD(php_wxTreeCtrl, UnselectItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeCtrl::UnselectItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxTreeCtrl::UnselectItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxTreeCtrl){
				references = &((wxTreeCtrl_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* item0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&item0, php_wxTreeItemId_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, php_wxTreeItemId_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTreeCtrl::UnselectItem(*(wxTreeItemId*) object_pointer0_0)\n\n");
				#endif
				((wxTreeCtrl_php*)_this)->UnselectItem(*(wxTreeItemId*) object_pointer0_0);

				references->AddReference(item0, "wxTreeCtrl::UnselectItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeCtrl::UnselectItem\n");
	}
}
/* }}} */

void php_wxVListBox_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVListBox_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxVListBox_php* object = static_cast<wxVListBox_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxVListBox done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
/* {{{ proto  wxVListBox::wxVListBox(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Normal constructor which calls Create() internally. */
PHP_METHOD(php_wxVListBox, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 3 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(pos0, "wxVListBox::wxVListBox at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 4 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(pos0, "wxVListBox::wxVListBox at call with 4 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(size0, "wxVListBox::wxVListBox at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 5 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(pos0, "wxVListBox::wxVListBox at call with 5 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(size0, "wxVListBox::wxVListBox at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8))\n");
				#endif
				_this = new wxVListBox_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8));

				((wxVListBox_php*) _this)->references.Initialize();
				((wxVListBox_php*) _this)->references.AddReference(parent0, "wxVListBox::wxVListBox at call with 6 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(pos0, "wxVListBox::wxVListBox at call with 6 argument(s)");
				((wxVListBox_php*) _this)->references.AddReference(size0, "wxVListBox::wxVListBox at call with 6 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxVListBox_php();

				((wxVListBox_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxVListBox);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		((wxVListBox_php*) _this)->phpObj = getThis();
		
		((wxVListBox_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxVListBox_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxVListBox::__constructor\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxVListBox::Toggle(int item)
   Toggles the state of the specified item, i.e. */
PHP_METHOD(php_wxVListBox, Toggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Toggle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Toggle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::Toggle((size_t) item0)\n\n");
				#endif
				((wxVListBox_php*)_this)->Toggle((size_t) item0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::Toggle\n");
	}
}
/* }}} */

/* {{{ proto  wxVListBox::SetSelectionBackground(wxColour col)
   Sets the colour to be used for the selected cells background. */
PHP_METHOD(php_wxVListBox, SetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetSelectionBackground\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(col0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetSelectionBackground(*(wxColour*) object_pointer0_0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetSelectionBackground(*(wxColour*) object_pointer0_0);

				references->AddReference(col0, "wxVListBox::SetSelectionBackground at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SetSelectionBackground\n");
	}
}
/* }}} */

/* {{{ proto  wxVListBox::SetSelection(int selection)
   Set the selection to the specified item, if it is -1 the selection is unset. */
PHP_METHOD(php_wxVListBox, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long selection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&selection0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &selection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetSelection((int) selection0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetSelection((int) selection0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SetSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxVListBox::SetMargins(int x, int y)
   Set the margins: horizontal margin is the distance between the window border and the item contents while vertical margin is half of the distance between items. */
PHP_METHOD(php_wxVListBox, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pt1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetMargins((wxCoord) x0, (wxCoord) y0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetMargins((wxCoord) x0, (wxCoord) y0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetMargins(*(wxPoint*) object_pointer1_0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetMargins(*(wxPoint*) object_pointer1_0);

				references->AddReference(pt1, "wxVListBox::SetMargins at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SetMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxVListBox::SetItemCount(int count)
   Set the number of items to be shown in the control. */
PHP_METHOD(php_wxVListBox, SetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long count0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&count0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &count0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::SetItemCount((size_t) count0)\n\n");
				#endif
				((wxVListBox_php*)_this)->SetItemCount((size_t) count0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SetItemCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::SelectRange(int from, int to)
   Selects all items in the specified range which may be given in any order. */
PHP_METHOD(php_wxVListBox, SelectRange)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SelectRange\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SelectRange\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long from0;
	long to0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&from0, &to0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &from0, &to0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::SelectRange((size_t) from0, (size_t) to0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->SelectRange((size_t) from0, (size_t) to0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SelectRange\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::SelectAll()
   Selects all the items in the listbox. */
PHP_METHOD(php_wxVListBox, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::SelectAll())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->SelectAll());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::Select(int item, bool select)
   Selects or deselects the specified item which must be valid (i.e. */
PHP_METHOD(php_wxVListBox, Select)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Select\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Select\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool select0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&item0, &select0)\n");
		#endif
		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0, &select0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Select((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Select((size_t) item0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Select((size_t) item0, select0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Select((size_t) item0, select0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::Select\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::OnMeasureItem(int n)
   The derived class must implement this method to return the height of the specified item (in pixels). */
wxCoord wxVListBox_php::OnMeasureItem(size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnMeasureItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnMeasureItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], n);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnMeasureItem", 13, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxVListBox::OnMeasureItem'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (wxCoord) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto  wxVListBox::OnDrawSeparator(wxDC &dc, wxRect &rect, int n)
   This method may be used to draw separators between the lines. */
void wxVListBox_php::OnDrawSeparator(wxDC& dc, wxRect& rect, size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawSeparator", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrawSeparator", 15, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxVListBox::OnDrawSeparator(dc, rect, n);
}
/* }}} */

/* {{{ proto  wxVListBox::OnDrawItem(wxDC &dc, wxRect rect, int n)
   The derived class must implement this function to actually draw the item with the given index on the provided DC. */
void wxVListBox_php::OnDrawItem(wxDC& dc, const wxRect& rect, size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawItem\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawItem", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrawItem", 10, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxVListBox::OnDrawItem'!", "Error");
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxVListBox::OnDrawBackground(wxDC &dc, wxRect rect, int n)
   This method is used to draw the items background and, maybe, a border around it. */
void wxVListBox_php::OnDrawBackground(wxDC& dc, const wxRect& rect, size_t n)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVListBox::OnDrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrawBackground", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxRect_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[2], n);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	//function_called = call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC);
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrawBackground", 16, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxVListBox::OnDrawBackground(dc, rect, n);
}
/* }}} */

/* {{{ proto bool wxVListBox::IsSelected(int item)
   Returns true if this item is selected, false otherwise. */
PHP_METHOD(php_wxVListBox, IsSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::IsSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::IsSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::IsSelected((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->IsSelected((size_t) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::IsSelected\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::IsCurrent(int item)
   Returns true if this item is the current one, false otherwise. */
PHP_METHOD(php_wxVListBox, IsCurrent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::IsCurrent\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::IsCurrent\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::IsCurrent((size_t) item0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->IsCurrent((size_t) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::IsCurrent\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::HasMultipleSelection()
   Returns true if the listbox was created with wxLB_MULTIPLE style and so supports multiple selection or false if it is a single selection listbox. */
PHP_METHOD(php_wxVListBox, HasMultipleSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::HasMultipleSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::HasMultipleSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::HasMultipleSelection())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->HasMultipleSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::HasMultipleSelection\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxVListBox::GetSelectionBackground()
   Returns the background colour used for the selected cells. */
PHP_METHOD(php_wxVListBox, GetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelectionBackground\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetSelectionBackground() to return object reference\n\n");
				#endif
				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxVListBox_php*)_this)->GetSelectionBackground();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxColour));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxVListBox::GetSelectionBackground at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetSelectionBackground\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::GetSelection()
   Get the currently selected item or wxNOT_FOUND if there is no selection. */
PHP_METHOD(php_wxVListBox, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::GetSelectedCount()
   Returns the number of the items currently selected. */
PHP_METHOD(php_wxVListBox, GetSelectedCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetSelectedCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetSelectedCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetSelectedCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetSelectedCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetSelectedCount\n");
	}
}
/* }}} */

/* {{{ proto  wxVListBox::Clear()
   Deletes all items from the control. */
PHP_METHOD(php_wxVListBox, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::Clear()\n\n");
				#endif
				((wxVListBox_php*)_this)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::Clear\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Creates the control. */
PHP_METHOD(php_wxVListBox, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxVListBox::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxVListBox::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxVListBox::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxVListBox::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxVListBox::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxVListBox::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxVListBox::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxVListBox::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxVListBox::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxVListBox::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxVListBox::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxVListBox::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxVListBox::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxVListBox::DeselectAll()
   Deselects all the items in the listbox. */
PHP_METHOD(php_wxVListBox, DeselectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::DeselectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::DeselectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVListBox::DeselectAll())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxVListBox_php*)_this)->DeselectAll());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::DeselectAll\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::GetFirstSelected(int &cookie)
   Returns the index of the first selected item in the listbox or wxNOT_FOUND if no items are currently selected. */
PHP_METHOD(php_wxVListBox, GetFirstSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetFirstSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetFirstSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long cookie0;
	zval* cookie0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&cookie0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cookie0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &cookie0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetFirstSelected((unsigned long&) cookie0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetFirstSelected((unsigned long&) cookie0));

				ZVAL_LONG(cookie0_ref, cookie0);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetFirstSelected\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::GetItemCount()
   Get the number of items in the control. */
PHP_METHOD(php_wxVListBox, GetItemCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetItemCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetItemCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetItemCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetItemCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetItemCount\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxVListBox::GetItemRect(int item)
   Returns the rectangle occupied by this item in physical coordinates. */
PHP_METHOD(php_wxVListBox, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetItemRect((size_t) item0) to return new object\n\n");
				#endif
				wxRect value_to_return1;
				value_to_return1 = ((wxVListBox_php*)_this)->GetItemRect((size_t) item0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetItemRect\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxVListBox::GetMargins()
   Returns the margins used by the control. */
PHP_METHOD(php_wxVListBox, GetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVListBox::GetMargins() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				value_to_return0 = ((wxVListBox_php*)_this)->GetMargins();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetMargins\n");
	}
}
/* }}} */

/* {{{ proto int wxVListBox::GetNextSelected(int &cookie)
   Returns the index of the next selected item or wxNOT_FOUND if there are no more. */
PHP_METHOD(php_wxVListBox, GetNextSelected)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVListBox::GetNextSelected\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxVListBox::GetNextSelected\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxVListBox){
				references = &((wxVListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxHtmlListBox) && (!reference_type_found)){
				references = &((wxHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
			if((parent_rsrc_type == le_wxSimpleHtmlListBox) && (!reference_type_found)){
				references = &((wxSimpleHtmlListBox_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long cookie0;
	zval* cookie0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&cookie0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cookie0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &cookie0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVListBox::GetNextSelected((unsigned long&) cookie0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxVListBox_php*)_this)->GetNextSelected((unsigned long&) cookie0));

				ZVAL_LONG(cookie0_ref, cookie0);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVListBox::GetNextSelected\n");
	}
}
/* }}} */

void php_wxWebView_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxWebView_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
/* {{{ proto bool wxWebView::CanCopy()
   Returns true if the current selection can be copied. */
PHP_METHOD(php_wxWebView, CanCopy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanCopy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanCopy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanCopy())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanCopy());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanCopy\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanCut()
   Returns true if the current selection can be cut. */
PHP_METHOD(php_wxWebView, CanCut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanCut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanCut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanCut())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanCut());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanCut\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanGoBack()
   Returns true if it is possible to navigate backward in the history of visited pages. */
PHP_METHOD(php_wxWebView, CanGoBack)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanGoBack\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanGoBack\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanGoBack())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanGoBack());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanGoBack\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanGoForward()
   Returns true if it is possible to navigate forward in the history of visited pages. */
PHP_METHOD(php_wxWebView, CanGoForward)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanGoForward\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanGoForward\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanGoForward())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanGoForward());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanGoForward\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanPaste()
   Returns true if data can be pasted. */
PHP_METHOD(php_wxWebView, CanPaste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanPaste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanPaste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanPaste())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanPaste());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanPaste\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanRedo()
   Returns true if there is an action to redo. */
PHP_METHOD(php_wxWebView, CanRedo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanRedo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanRedo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanRedo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanRedo());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanRedo\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanSetZoomType(wxWebViewZoomType type)
   Retrieve whether the current HTML engine supports a zoom type. */
PHP_METHOD(php_wxWebView, CanSetZoomType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanSetZoomType\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanSetZoomType\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&type0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanSetZoomType((wxWebViewZoomType) type0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanSetZoomType((wxWebViewZoomType) type0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanSetZoomType\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::CanUndo()
   Returns true if there is an action to undo. */
PHP_METHOD(php_wxWebView, CanUndo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::CanUndo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::CanUndo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::CanUndo())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->CanUndo());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::CanUndo\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::ClearHistory()
   Clear the history, this will also remove the visible page. */
PHP_METHOD(php_wxWebView, ClearHistory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::ClearHistory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::ClearHistory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::ClearHistory()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->ClearHistory();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::ClearHistory\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::ClearSelection()
   Clears the current selection. */
PHP_METHOD(php_wxWebView, ClearSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::ClearSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::ClearSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::ClearSelection()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->ClearSelection();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::ClearSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Copy()
   Copies the current selection. */
PHP_METHOD(php_wxWebView, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Copy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Copy()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Copy();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Copy\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::Create(wxWindow &parent, int id, string url, wxPoint pos, wxSize size, int style, string name)
   Creation function for two-step creation. */
PHP_METHOD(php_wxWebView, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOls' (&parent0, &id0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8)));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxWebView::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxWebView::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxWebView::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxWebView::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxWebView::Create at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (long) style0, wxString(name0, wxConvUTF8)));
				}

				references->AddReference(parent0, "wxWebView::Create at call with 7 argument(s)");
				references->AddReference(pos0, "wxWebView::Create at call with 7 argument(s)");
				references->AddReference(size0, "wxWebView::Create at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Cut()
   Cuts the current selection. */
PHP_METHOD(php_wxWebView, Cut)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Cut\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Cut\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Cut()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Cut();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Cut\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::DeleteSelection()
   Deletes the current selection. */
PHP_METHOD(php_wxWebView, DeleteSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::DeleteSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::DeleteSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::DeleteSelection()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->DeleteSelection();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::DeleteSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::EnableHistory(bool enable)
   Enable or disable the history. */
PHP_METHOD(php_wxWebView, EnableHistory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::EnableHistory\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::EnableHistory\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::EnableHistory()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->EnableHistory();
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::EnableHistory(enable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->EnableHistory(enable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::EnableHistory\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Undo()
   Undos the last action. */
PHP_METHOD(php_wxWebView, Undo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Undo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Undo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Undo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Undo();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Undo\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Stop()
   Stop the current page loading process, if any. */
PHP_METHOD(php_wxWebView, Stop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Stop\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Stop\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Stop()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Stop();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Stop\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::SetZoomType(wxWebViewZoomType zoomType)
   Set how to interpret the zoom factor. */
PHP_METHOD(php_wxWebView, SetZoomType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::SetZoomType\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::SetZoomType\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long zoomType0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&zoomType0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &zoomType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetZoomType((wxWebViewZoomType) zoomType0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetZoomType((wxWebViewZoomType) zoomType0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::SetZoomType\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::SetZoom(wxWebViewZoom zoom)
   Set the zoom factor of the page. */
PHP_METHOD(php_wxWebView, SetZoom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::SetZoom\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::SetZoom\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long zoom0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&zoom0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &zoom0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetZoom((wxWebViewZoom) zoom0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetZoom((wxWebViewZoom) zoom0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::SetZoom\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::SetPage(wxInputStream &html, string baseUrl)
   Set the displayed page source to the contents of the given stream. */
PHP_METHOD(php_wxWebView, SetPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::SetPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::SetPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* html0 = 0;
	void* object_pointer0_0 = 0;
	char* baseUrl0;
	long baseUrl_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* html1;
	long html_len1;
	char* baseUrl1;
	long baseUrl_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Os' (&html0, php_wxInputStream_entry, &baseUrl0, &baseUrl_len0)\n");
		#endif
		char parse_parameters_string[] = "Os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &html0, php_wxInputStream_entry, &baseUrl0, &baseUrl_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(html0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(html0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(html0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss' (&html1, &html_len1, &baseUrl1, &baseUrl_len1)\n");
		#endif
		char parse_parameters_string[] = "ss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &html1, &html_len1, &baseUrl1, &baseUrl_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetPage(*(wxInputStream*) object_pointer0_0, wxString(baseUrl0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetPage(*(wxInputStream*) object_pointer0_0, wxString(baseUrl0, wxConvUTF8));
				}

				references->AddReference(html0, "wxWebView::SetPage at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetPage(wxString(html1, wxConvUTF8), wxString(baseUrl1, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetPage(wxString(html1, wxConvUTF8), wxString(baseUrl1, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::SetPage\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::SetEditable(bool enable)
   Set the editable property of the web control. */
PHP_METHOD(php_wxWebView, SetEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::SetEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::SetEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetEditable()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetEditable();
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SetEditable(enable0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SetEditable(enable0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::SetEditable\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::SelectAll()
   Selects the entire page. */
PHP_METHOD(php_wxWebView, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::SelectAll\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::SelectAll()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->SelectAll();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::RunScript(string javascript)
   Runs the given javascript code. */
PHP_METHOD(php_wxWebView, RunScript)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::RunScript\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::RunScript\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* javascript0;
	long javascript_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&javascript0, &javascript_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &javascript0, &javascript_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::RunScript(wxString(javascript0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->RunScript(wxString(javascript0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::RunScript\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Reload(wxWebViewReloadFlags flags)
   Reload the currently displayed URL. */
PHP_METHOD(php_wxWebView, Reload)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Reload\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Reload\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&flags0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Reload()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Reload();
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Reload((wxWebViewReloadFlags) flags0)\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Reload((wxWebViewReloadFlags) flags0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Reload\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Redo()
   Redos the last action. */
PHP_METHOD(php_wxWebView, Redo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Redo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Redo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Redo()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Redo();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Redo\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Print()
   Opens a print dialog so that the user may print the currently displayed page. */
PHP_METHOD(php_wxWebView, Print)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Print\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Print\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Print()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Print();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Print\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::Paste()
   Pastes the current data. */
PHP_METHOD(php_wxWebView, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::Paste\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::Paste()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->Paste();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::Paste\n");
	}
}
/* }}} */

/* {{{ proto wxWebView wxWebView::New(wxWindow &parent, int id, string url, wxPoint pos, wxSize size, wxWebViewBackend backend, int style, string name)
   Factory function to create a new wxWebView. */
PHP_METHOD(php_wxWebView, NewObject)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::New\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::New\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	char* url0;
	long url_len0;
	zval* pos0 = 0;
	void* object_pointer0_3 = 0;
	zval* size0 = 0;
	void* object_pointer0_4 = 0;
	long backend0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	long backend1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|sOOlls' (&parent0, &id0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &backend0, &style0, &name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "zl|sOOlls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &url0, &url_len0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &backend0, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxWebView && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_4 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&backend1)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &backend1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return2;
				value_to_return2 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0);
				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxWebView));
				}



				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return3;
				value_to_return3 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8));
				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxWebView));
				}



				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return4;
				value_to_return4 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3);
				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxWebView));
				}



				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return5;
				value_to_return5 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4);
				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxWebView));
				}



				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return6;
				value_to_return6 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0);
				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxWebView));
				}



				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0, (long) style0) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return7;
				value_to_return7 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0, (long) style0);
				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return7, le_wxWebView));
				}



				return;
				break;
			}
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0, (long) style0, wxString(name0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return8;
				value_to_return8 = (wxWebView_php*) wxWebView::New((wxWindow*) object_pointer0_0, (wxWindowID) id0, wxString(url0, wxConvUTF8), *(wxPoint*) object_pointer0_3, *(wxSize*) object_pointer0_4, (wxWebViewBackend) backend0, (long) style0, wxString(name0, wxConvUTF8));
				if(value_to_return8 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return8->references.IsUserInitialized()){
					if(value_to_return8->phpObj != NULL){
						*return_value = *value_to_return8->phpObj;
						zval_add_ref(&value_to_return8->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return8, le_wxWebView));
				}



				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New() to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return0;
				value_to_return0 = (wxWebView_php*) wxWebView::New();
				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWebView));
				}



				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxWebView::New((wxWebViewBackend) backend1) to return object pointer\n\n");
				#endif
				wxWebView_php* value_to_return1;
				value_to_return1 = (wxWebView_php*) wxWebView::New((wxWebViewBackend) backend1);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWebView_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxWebView));
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::New\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::LoadURL(string url)
   Load a web page from a URL. */
PHP_METHOD(php_wxWebView, LoadURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::LoadURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::LoadURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::LoadURL(wxString(url0, wxConvUTF8))\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->LoadURL(wxString(url0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::LoadURL\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::IsEditable()
   Returns whether the web control is currently editable. */
PHP_METHOD(php_wxWebView, IsEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::IsEditable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::IsEditable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::IsEditable())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->IsEditable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::IsEditable\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::IsBusy()
   Returns whether the web control is currently busy (e.g. */
PHP_METHOD(php_wxWebView, IsBusy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::IsBusy\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::IsBusy\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::IsBusy())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->IsBusy());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::IsBusy\n");
	}
}
/* }}} */

/* {{{ proto bool wxWebView::HasSelection()
   Returns true if there is a current selection. */
PHP_METHOD(php_wxWebView, HasSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::HasSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::HasSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxWebView::HasSelection())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_BOOL(return_value, ((wxWebView_php*)_this)->HasSelection());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::HasSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::GoForward()
   Navigate forward in the history of visited pages. */
PHP_METHOD(php_wxWebView, GoForward)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GoForward\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GoForward\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::GoForward()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->GoForward();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GoForward\n");
	}
}
/* }}} */

/* {{{ proto  wxWebView::GoBack()
   Navigate back in the history of visited pages. */
PHP_METHOD(php_wxWebView, GoBack)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GoBack\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GoBack\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWebView::GoBack()\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					((wxWebView_php*)_this)->GoBack();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GoBack\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetCurrentTitle()
   Get the title of the current web page, or its URL/path if title is not available. */
PHP_METHOD(php_wxWebView, GetCurrentTitle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetCurrentTitle\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetCurrentTitle\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetCurrentTitle().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetCurrentTitle();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetCurrentTitle\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetCurrentURL()
   Get the URL of the currently displayed document. */
PHP_METHOD(php_wxWebView, GetCurrentURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetCurrentURL\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetCurrentURL\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetCurrentURL().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetCurrentURL();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetCurrentURL\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetPageSource()
   Get the HTML source code of the currently displayed document. */
PHP_METHOD(php_wxWebView, GetPageSource)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetPageSource\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetPageSource\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetPageSource().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetPageSource();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetPageSource\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetPageText()
   Get the text of the current page. */
PHP_METHOD(php_wxWebView, GetPageText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetPageText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetPageText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetPageText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetPageText();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetPageText\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetSelectedSource()
   Returns the currently selected source, if any. */
PHP_METHOD(php_wxWebView, GetSelectedSource)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetSelectedSource\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetSelectedSource\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetSelectedSource().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetSelectedSource();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetSelectedSource\n");
	}
}
/* }}} */

/* {{{ proto string wxWebView::GetSelectedText()
   Returns the currently selected text, if any. */
PHP_METHOD(php_wxWebView, GetSelectedText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetSelectedText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetSelectedText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxWebView::GetSelectedText().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				if(parent_rsrc_type == le_wxWebView)
				{
					value_to_return0 = ((wxWebView_php*)_this)->GetSelectedText();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetSelectedText\n");
	}
}
/* }}} */

/* {{{ proto wxWebViewZoom wxWebView::GetZoom()
   Get the zoom factor of the page. */
PHP_METHOD(php_wxWebView, GetZoom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetZoom\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetZoom\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxWebView::GetZoom())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_LONG(return_value, ((wxWebView_php*)_this)->GetZoom());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetZoom\n");
	}
}
/* }}} */

/* {{{ proto wxWebViewZoomType wxWebView::GetZoomType()
   Get how the zoom factor is currently interpreted. */
PHP_METHOD(php_wxWebView, GetZoomType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWebView::GetZoomType\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxWebView::GetZoomType\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxWebView){
				references = &((wxWebView_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxWebView::GetZoomType())\n\n");
				#endif
				if(parent_rsrc_type == le_wxWebView)
				{
					ZVAL_LONG(return_value, ((wxWebView_php*)_this)->GetZoomType());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWebView::GetZoomType\n");
	}
}
/* }}} */

